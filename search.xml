<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hash 实现]]></title>
    <url>%2F2017%2F09%2F10%2FHash%20%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[C语言标准库中未实现hashtable, 在编程练习时经常使用该数据结构，以备不时之需 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;typedef unsigned char u8_t;typedef char s8_t;typedef unsigned short u16_t;typedef signed short s16_t;typedef unsigned int u32_t;typedef signed int s32_t;typedef long long s64_t;typedef unsigned long long u64_t;typedef s32_t err_t;typedef unsigned long ulong_t;void* xxx_malloc(int size)&#123; void* ret = malloc(size); printf("malloc %p\n", ret); return ret;&#125;void xxx_free(void* ptr)&#123; printf("free %p\n", ptr); free(ptr);&#125;#define offset_of(type, member) ((unsigned long)&amp;((type *)0)-&gt;member)#define container_of(ptr, type, member) \ ((type *)((unsigned char *)ptr - offset_of(type,member)))#define hlist_entry(ptr, type, member) container_of(ptr,type,member)#define hlist_for_each(pos, head) for (pos = (head)-&gt;first; pos; pos = pos-&gt;next)#define hlist_for_each_safe(pos, n, head) \ for (pos = (head)-&gt;first; pos &amp;&amp; (n = pos-&gt;next, 1); pos = n)#define hlist_for_each_entry(type_pos, ptr, pos, head, member) \ for (pos = (head)-&gt;first; pos &amp;&amp; (ptr = hlist_entry(pos, type_pos, member), 1); pos = pos-&gt;next)#define hlist_for_each_entry_safe(type_pos, tpos, pos, n, head, member) \ for (pos = (head)-&gt;first; \ pos &amp;&amp; (&#123; n = pos-&gt;next; 1; &#125;) &amp;&amp; \ (&#123; tpos = hlist_entry(pos, type_pos, member); 1;&#125;); \ pos = n)#define INIT_HLIST_HEAD(ptr) ((ptr)-&gt;first = NULL)struct hlist_head &#123; struct hlist_node *first;&#125;;struct hlist_node &#123; struct hlist_node *next, **pprev;&#125;;static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)&#123; struct hlist_node *first = h-&gt;first; n-&gt;next = first; if (first) first-&gt;pprev = &amp;n-&gt;next; h-&gt;first = n; n-&gt;pprev = &amp;h-&gt;first;&#125;static inline void INIT_HLIST_NODE(struct hlist_node *h)&#123; h-&gt;next = NULL; h-&gt;pprev = NULL;&#125;static inline int hlist_unhashed(const struct hlist_node *h)&#123; return !h-&gt;pprev;&#125;static inline int hlist_empty(const struct hlist_head *h)&#123; return !h-&gt;first;&#125;static inline void __hlist_del(struct hlist_node *n)&#123; struct hlist_node *next = n-&gt;next; struct hlist_node **pprev = n-&gt;pprev; *pprev = next; if (next) next-&gt;pprev = pprev;&#125;static inline void hlist_del_init(struct hlist_node *n)&#123; if (!hlist_unhashed(n)) &#123; __hlist_del(n); &#125;&#125;typedef struct _xxx_hash_bucket_head &#123; struct hlist_head chain; // hash 桶的头结点&#125; xxx_hash_bucket_head;typedef struct _xxx_hashtable &#123; xxx_hash_bucket_head *tbl; // hash 表中的 hash 桶 s8_t *name; // hash 表的名称, 未使用 u32_t cnt; // 保存关键字 hash 后的最大值 u32_t element_cnt; // 记录当前 hash 表中的元素数量 u32_t offset; // hlist_node 成员与包含该成员结构体的地址偏移 u32_t (*hash)(void *); // 关键字的 hash 算法函数 s32_t (*compare)(void *, void *); // 元素的比较函数 void (*destroy)(void *); // 反初始化时对每个元素的反初始化操作函数&#125; xxx_hashtable_t;void *hashtable_init(s8_t *name, u32_t cnt, u32_t offset, u32_t (*hash)(void *), s32_t (*compare)(void *, void *), void (*destroy)(void *))&#123; xxx_hashtable_t *tbl; u32_t i; u32_t size; assert(!(cnt &amp; (cnt - 1))); assert(NULL != hash); assert(NULL != compare); if (NULL == (tbl = (xxx_hashtable_t*)xxx_malloc(sizeof(xxx_hashtable_t)))) &#123; return NULL; &#125; size = sizeof(xxx_hash_bucket_head) * cnt; if (NULL == (tbl-&gt;tbl = xxx_malloc(size))) &#123; xxx_free(tbl); return NULL; &#125; tbl-&gt;name = name; tbl-&gt;cnt = cnt; tbl-&gt;element_cnt = 0; tbl-&gt;offset = offset; tbl-&gt;hash = hash; tbl-&gt;compare = compare; tbl-&gt;destroy = destroy; for (i = 0; i &lt; cnt; i++) &#123; INIT_HLIST_HEAD(&amp;(tbl-&gt;tbl[i].chain)); &#125; return tbl;&#125;void hashtable_fini(void *tbl)&#123; u32_t i; struct hlist_node *pos, *n; xxx_hash_bucket_head *h; u32_t size; u32_t offset; if (NULL == tbl) &#123; return; &#125; offset = ((xxx_hashtable_t *)tbl)-&gt;offset; for (i = 0; i &lt; ((xxx_hashtable_t *)tbl)-&gt;cnt; i++) &#123; h = &amp;((xxx_hashtable_t *)tbl)-&gt;tbl[i]; hlist_for_each_safe(pos, n, &amp;h-&gt;chain) &#123; if (NULL != ((xxx_hashtable_t *)tbl)-&gt;destroy) &#123; ((xxx_hashtable_t *)tbl)-&gt;destroy((void *)((u8_t *)pos - offset)); &#125; &#125; &#125; size = sizeof(struct hlist_head) * ((xxx_hashtable_t *)tbl)-&gt;cnt; xxx_free(((xxx_hashtable_t *)tbl)-&gt;tbl); xxx_free(tbl);&#125;static inline void *hashtable_find(void *tbl, void *elem)&#123; struct hlist_node *pos; xxx_hash_bucket_head *h; u32_t hash; hash = ((xxx_hashtable_t *)tbl)-&gt;hash(elem); assert(hash &lt; ((xxx_hashtable_t *)tbl)-&gt;cnt); h = &amp;((xxx_hashtable_t *)tbl)-&gt;tbl[hash]; hlist_for_each(pos, &amp;h-&gt;chain) &#123; if (!((xxx_hashtable_t *)tbl)-&gt;compare(elem, (u8_t *)pos - ((xxx_hashtable_t *)tbl)-&gt;offset)) &#123; return (void *)((u8_t *)pos - ((xxx_hashtable_t *)tbl)-&gt;offset); &#125; &#125; return NULL;&#125;static err_t hashtable_insert(void* hashtable, void* elem)&#123; struct hlist_node* pos; xxx_hash_bucket_head* bucket; u32_t hash; hash = ((xxx_hashtable_t *)hashtable)-&gt;hash(elem); assert(hash &lt; ((xxx_hashtable_t *)hashtable)-&gt;cnt); bucket = &amp;((xxx_hashtable_t *)hashtable)-&gt;tbl[hash]; hlist_for_each(pos, &amp;bucket-&gt;chain) &#123; if (!((xxx_hashtable_t *)hashtable)-&gt;compare(elem, (u8_t *)pos - ((xxx_hashtable_t *)hashtable)-&gt;offset)) &#123; return -1; &#125; &#125; hlist_add_head((struct hlist_node *)((u8_t *)elem + ((xxx_hashtable_t *)hashtable)-&gt;offset), &amp;bucket-&gt;chain); ((xxx_hashtable_t *)hashtable)-&gt;element_cnt++; return 0;&#125;static inline void hashtable_delete(void *hashtable, void *elem)&#123; xxx_hash_bucket_head *bucket; u32_t hash; hash = ((xxx_hashtable_t *)hashtable)-&gt;hash(elem); assert(hash &lt; ((xxx_hashtable_t *)hashtable)-&gt;cnt); bucket = &amp;((xxx_hashtable_t *)hashtable)-&gt;tbl[hash]; hlist_del_init((struct hlist_node *)((u8_t *)elem + ((xxx_hashtable_t *)hashtable)-&gt;offset)); if (NULL != ((xxx_hashtable_t *)hashtable)-&gt;destroy) &#123; ((xxx_hashtable_t *)hashtable)-&gt;destroy(elem); &#125; ((xxx_hashtable_t *)hashtable)-&gt;element_cnt--;&#125;/* Hash map 实现 */#define MAP_BUCKET_CNT (1 &lt;&lt; 6)typedef struct _str_map_t&#123; int m_value; struct hlist_node hash_node;&#125; str_map_t;/* 创建 str_map_t 对象 */str_map_t* str_map_init();/* 销毁 str_map_t 对象 */void str_map_fini(str_map_t* p_str_map);/* 插入元素 */void str_map_insert(str_map_t* p_str_map);/* 删除元素 */void str_map_erase(str_map_t* p_str_map);/* 查找元素 */void str_map_erase(str_map_t* p_str_map);/* 测试函数 */typedef struct _hlist_demo_t&#123; int m_value; struct hlist_node hash_node;&#125; hlist_demo_t;static u32_t demo_hash(void *pkt)&#123; return (u32_t)(((hlist_demo_t*)pkt)-&gt;m_value) % BUCKET_CNT;&#125;static s32_t demo_compare(void *pkt, void *pkt2)&#123; if (((hlist_demo_t*)pkt)-&gt;m_value == ((hlist_demo_t*)pkt2)-&gt;m_value) &#123; return 0; &#125; return -1;&#125;static void demo_destroy(void *arg)&#123; xxx_free(arg);&#125;int main()&#123;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>hash</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F09%2F10%2Fhello-world.html</url>
    <content type="text"><![CDATA[用于展示不同的MarkDown语法 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. blah blah blah Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>教程实例</category>
      </categories>
      <tags>
        <tag>demo</tag>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
