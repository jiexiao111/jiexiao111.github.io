<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用操作汇总]]></title>
    <url>%2F2017%2F09%2F17%2Fuseful_operate.html</url>
    <content type="text"><![CDATA[汇总一些琐碎的, 非快捷键的操作, 当某个工具的操作过多时再独立为一篇博客jupyter.ipynb 转 .md1jupyter nbconvert --to markdown README.ipynbjupyter取消密码生成配置文件1jupyter notebook --generate --allow-root编辑/root/.jupyter/jupyter_notebook_config.py，然后重启jupyter1c.NotebookApp.token = '';显示多行结果修改前12345line1 = "this is from line 1"line2 = "this is from line 2"line1line2‘this is from line 2’修改永久生效，编辑.ipython/profile_default/ipython_config.py，然后重启jupyter12ipython profile create # 如果没有默认配置文件， 则生成一个新的c.InteractiveShell.ast_node_interactivity = 'all'修改临时生效12from IPython.core.interactiveshell import InteractiveShellInteractiveShell.ast_node_interactivity = "all"修改后12345line1 = "this is from line 1"line2 = "this is from line 2"line1line2‘this is from line 1’‘this is from line 2’git保存提交密码更好的方式是使用秘钥1git config --global credential.helper store生成秘钥git 官方帮助 描述的非常清楚, 如果是 Linux 系统, 首先通过命令生成秘钥, 注意下面命令中的 jiexiao111@gmail.com 是你注册 github 时的邮箱1ssh-keygen -t rsa -C jiexiao111@gmail.com想办法把下面这个文件的内容拷贝出来1~/.ssh/id_rsa.pub然后打开你的 github 主页, 依次点击 Settings-&gt;SSH and GPG keys-&gt;New SSH key, 然后 Title 随便取个名字，再把 ~/.ssh/id_rsa.pub 中的内容拷贝到 Key 中, Add SSH key 完成添加解决git中文乱码1git config --global core.quotepath false撤销 commit 但是保留修改1git reset --soft [commit_id] 就可以回滚到某一个commit，然后保留下修改的内容比较文件https://gist.github.com/jhjguxin/3271961chrome分析网页加载速度在 chrome 流量器中按 F12 或者单击鼠标右键-&gt;检查, 打开调试栏-&gt;Network, 刷新网页就可以看到以下信息了vim无法 undo如果文件名中包含中文, 则无法 undo保存折叠.vimrc 添加以下12au BufWinLeave *.* mkviewau BufWinEnter *.* silent loadview]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用快捷键汇总]]></title>
    <url>%2F2017%2F09%2F17%2Fkeboard_shortcuts.html</url>
    <content type="text"><![CDATA[日常使用的快捷键太多, 分散存储不易查找, 得益于 Next 主题优秀的目录导航, 可以将所有的快捷键统一记录Item2Mac 下的 Item2 真心好用标签新建标签: command + t关闭标签: command + w切换标签: command + 数字选择标签: command + 左右方向键窗口垂直分屏: command + d水平分屏: command + shift + d切换屏幕: command + option + 方向键 command + [ 或 command + ]预览所有窗口+搜索: command+option+e历史上一条命令历史: ctrl + p搜索命令历史: ctrl + r查看命令历史: command + ;查看剪贴板历史: command + shift + h移动移动到行首: ctrl + a移动到行尾: ctrl + e移动到前一个字符: ctrl + f移动到前一个字符: ctrl + b编辑剪切当前光标的字符: ctrl + d剪切光标之前的字符: ctrl + h剪切光标之前的单词: ctrl + w剪切整行: ctrl + u (本来 ctrl + u 是删至命令行首，但iterm中是删掉整行)剪切至行末尾: ctrl + k粘贴至光标后: ctrl + y交换光标处文本: ctrl + t其他切换全屏: command + enter查找: command + f清屏: ctrl + lChrome通常只需要查看帮助[?]即可, 不过自己写的东西理解起来还是要容易些滚动向下滚动: j向上滚动: k向左滚动: h向右滚动: l滚动到最上方: gg滚动到最下方: G滚动到最左方: zH滚动到最右方: zL向下滚动半页: d向上滚动半页: u常用后退: H前进: L刷新: r查找: /下一个匹配: n上一个匹配: N选中地址栏: command/Ctrl + lURL 相关操作拷贝当前URL: yy拷贝指定 URL: yf *相当于鼠标右键-&gt;复制链接*打开上一级 URL: gu打开最上级 URL: gU在当前标签打开链接: f *最常用的键, 相当于鼠标左键*在新建标签打开链接: F在当前标签页中打开剪切板中的 URL: p在新建标签页中打开剪切板中的 URL: P输入进入编辑模式: i *比如说要在 jupyter 中编辑的时候, 要先切换至编辑模式, 否则快捷键均被覆盖*选择输入框: gi *相当于鼠标左键点击输入框*选择下一个frame: gf *很多页面只有一个 frame 所以不常用*选择上一个frame: gF快速检索打开快速检索窗口, 搜索书签/历史记录: o打开快速检索窗口, 搜索书签/历史记录, 在新建标签中打开链接: O打开快速检索窗口, 搜索书签: b打开快速检索窗口, 搜索书签, 在新建标签中打开链接: B打开快速检索窗口, 将当前 URL 自动填入便于编辑: ge打开快速检索窗口, 将当前 URL 自动填入便于编辑, 在新建标签中打开链接: gE打开快速检索窗口, 搜索 Tab 标签: T *在 Tab 页很多的时候很好用*Tab 页新建 Tab 页: t关闭当前标签页: x打开最近关闭的标签页: X选择上一个 Tab 页: J/gT *经常遇到不能使用 vimium 的网页只能使用 Tab 键替代*选择下一个 Tab 页: K/gt *经常遇到不能使用 vimium 的网页只能使用 Shift Tab 键替代*选择最近浏览的 Tab 页: ^选择第一个 Tab 页: g0选择最后一个 Tab 页: g$将当前标签页向左移动: &lt;&lt;将当前标签页向右移动: &gt;&gt;在新建页中打开当前页面:yt *很常用, 相当于 yy 复制当前链接, P 打开新的链接*将当前标签移至新窗口: W *相当于鼠标拖拽标签页至窗口外*其他帮助: ?查看网页源码: gs不知道能干什么…Open multiple links in a new tab: &lt; a-f &gt;Enter visual mode: vEnter visual line mode: VFollow the link labeled previous or &lt;: [[Follow the link labeled next or &gt;: ]]Create a new mark: mGo to a mark: `Pin or unpin current tab: &lt; a-p &gt;Mute or unmute current tab: &lt; a-m &gt;Vimvim 需要记得太多了, 用了几年有些都还不知道zi 在vim中取消、生效折叠Tumx从 window 连接 Ubuntu, 实在不喜欢太多窗口, 只能用 Tmux 了参考http://www.cnblogs.com/congbo/archive/2012/08/30/2649420.htmlJupyter帮助: h]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Github + Hexo 搭建个人博客]]></title>
    <url>%2F2017%2F09%2F14%2FGithub%2BHexo_BLOG.html</url>
    <content type="text"><![CDATA[Github 让个人技术博客的创建变得异常简单，Hexo 框架 + Next 主题提供了高度定制且美观的个人博客，本文记录了搭建过程Hexo 与 jekyll 框架的选择经过两天的折腾，彻底放弃使用 jekyll 搭建自己的技术 Blog，究其原因就是目录、sitemap无法自动生成，一个没有前端开发经验的我最终发现Hexo。Hexo能够满足我对Blog的所有想法：1、我只负责写内容，至于文章的按标签分类还是按日期归档我都不关心，但是我需要使用这些功能2、文章要有一个漂亮的内容导航栏，开发做多了，对始终能在一屏内了解当前文件的整体结构有着某种偏执3、sitemap、文章目录最好能够复用网页位置，以便留出更多的位置显示正文，尽量少的翻页绝对能提升生产效率个人博客搭建依次安装 git、node.js、hexo、next主题安装 git官网描述的很清楚我最常用的是Ubuntu，只需要执行以下命令即可:1apt-get install git安装 node.js一开始，我以为使用的 Ubuntu-16.04LTS 已经很新了，所以就直接使用 apt-get 安装了，结果在安装 hexo 时出现错误。网上整了一堆高级方法都没能解决。最终参考node.js 官网，直接download官方的首页的最新的LTS版本 node-v6.11.3-linux-x64.tar.xz，解压至 /usr 目录1tar -vxf node-v6.11.3-linux-x64.tar.xz -C /usr/默认 hexo 安装的位置与 npm 一致，所以如果没有把 npm 所在路径加入环境变量，则安装 hexo 后会发现无法找到 hexo 命令，所以建议将 node.js 的安装路径加入 ~/.bashrc1echo 'export PATH="/usr/node-v6.11.3-linux-x64/bin:$PATH' &gt;&gt; ~/.bashrc如果你和我一样使用 zsh，就放到 ~/.zshrc 中1echo 'export PATH="/usr/node-v6.11.3-linux-x64/bin:$PATH' &gt;&gt; ~/.zshrc添加环境变量后记得 source12source ~/.bashrcsource ~/.zshrc安装 hexo创建一个目录, 比如 hexo_dir, 用于安装 hexo, 通过 npm 命令安装 hexo123mkdir hexo_dircd hexo_dirnpm install -g hexo-cli安装 next 主题hexo 的安装路径下有一个 themes 目录，hexo 默认会使用该目录下的主题，所以一定要在 hexo 安装目录下执行1git clone https://github.com/iissnan/hexo-theme-next themes/next如果你想能够更新 next 主题，且又想通过 github 管理你的主题定制信息，那么需要麻烦一些, 可以参考下面的 多平台共同编辑博客Github 创建博客只需要在 github 上创建 用户名+github.io 的 Repo 即可创建成功后，就可以通过 https://用户名.github.io/ 访问了, 比如我就是通过 https://jiexiao111.github.io/ 访问站点配置文件修改在 hexo 安装目录下可以找到 _config.yml 文件, 这个文件就是站点配置文件, 修改站点配置文件后，需要重起 hexo 服务，才能生效1hexo s启用 next 主题编辑站点配置文件1theme: next验证next主题，在 hexo 安装目录下执行 hexo s –debug，如果未出现错误，则在浏览器中访问以下位置1http://localhost:4000/修改默认标题、子标题、描述、作者、字符集编辑站点配置文件123456# Sitetitle: JieXiao's Blogsubtitle:description:author: JIE XIAOlanguage: zh-Hans主题配置文件修改hexo 目录下的 themes/next/ 子目录中也有一个 _config.yml 文件, 这个文件就是主题配置文件，修改主题配置文件后立即生效，无需重启 hexo 服务修改 Next 主题风格个人偏向于在一屏内显示更多的内容所以选择了 Mist 风格12345# Schemes# scheme: Musescheme: Mist# scheme: Pisces# scheme: Gemini设置侧边栏Next 主题的文章目录导航和作者介绍复用了侧边栏，非常不错123sidebar: position: left display: always修改字体12345678910111213141516171819202122232425262728293031font: enable: true # 外链字体库地址，例如 //fonts.googleapis.com (默认值) host: # 全局字体，应用在 body 元素上 global: external: true family: Monda # 标题字体 (h1, h2, h3, h4, h5, h6) headings: external: true family: Roboto Slab # 文章字体 posts: external: true family: # Logo 字体 logo: external: true family: Lobster Two size: 24 # 代码字体，应用于 code 以及代码块 codes: external: true family: PT Mono修改代码风格1highlight_theme: night侧边栏中增加社交信息123456social: GitHub: https://github.com/jiexiao111 E-Mail: mailto:jiexiao111@gmail.comsocial_icons: GitHub: github E-Mail: email开启背景动画1canvas_nest: true开启公式显示12mathjax: enable: true开启访问统计123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; 访问 site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 浏览 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; 阅读 page_pv_footer:第三方插件安装主要包括本地搜索服务、git部署本地搜索插件考虑到博文多了以后方便自己查阅，搜索功能必不可少安装 searchdb1npm install hexo-generator-searchdb --save修改主题配置文件123# Local searchlocal_search: enable: true修改站点配置文件12345search: path: search.xml field: post format: html limit: 10000git部署插件安装1npm install hexo-deployer-git --save修改站点配置文件1234deploy: type: git repository: git@github.com:jiexiao111/jiexiao111.github.io.git branch: master部署命令使用1hexo deploy压缩网页插件安装 hexo-neat1npm install hexo-neat --save修改站点配置，增加以下信息12345678910111213141516171819# hexo neat configneat_enable: trueneat_html: enable: true exclude: neat_css: enable: true exclude: - '*.min.css'neat_js: enable: true mangle: true output: compress: exclude: - '*.min.js'留言插件http://barrysite.me/2017/05/08/hexo%E7%BD%91%E7%AB%99NexT%E4%B8%BB%E9%A2%98%E5%A2%9E%E5%8A%A0%E7%95%99%E8%A8%80%E9%A1%B5/多平台共同编辑博客通常我们需要在多个环境下，编辑/发布博客生成秘钥git 官方帮助 描述的非常清楚, 如果是 Linux 系统, 首先通过命令生成秘钥, 注意下面命令中的 jiexiao111@gmail.com 是你注册 github 时的邮箱1ssh-keygen -t rsa -C jiexiao111@gmail.com想办法把下面这个文件的内容拷贝出来1~/.ssh/id_rsa.pub然后打开你的 github 主页, 依次点击 Settings-&gt;SSH and GPG keys-&gt;New SSH key, 然后 Title 随便取个名字，再把 ~/.ssh/id_rsa.pub 中的内容拷贝到 Key 中, Add SSH key 完成添加新建 repo 用于保存站点配置在 github 中新建 repo, 进入 hexo 安装目录, 将以下文件/目录同步至 repo123456README.md _config.ymlpackage.jsonscaffolds source themesfork Next 主题用于保存主题配置为了能够随时更新 Next 主题, 又能保存自己的主题配置及相关修改, 可以参考同步一个 fork或者官方帮助第一步, fork Next 主题第二步, 进入 hexo 的安装目录, 将 fork 好的 Next 主题 clone 到本地, 注意 hexo 目录下应该是默认存在 themes 目录的1git clone git@github.com:jiexiao111/hexo-theme-next.git themes/next第三步, 进入 themes/next 目录, 增加上游仓库12cd themes/nextgit remote add upstream https://github.com/iissnan/hexo-theme-next.git第四步, 通过git remote -v确认执行结果正确12345$ git remote -vorigin git@github.com:jiexiao111/hexo-theme-next.git (fetch)origin git@github.com:jiexiao111/hexo-theme-next.git (push)upstream https://github.com/iissnan/hexo-theme-next.git (fetch)upstream https://github.com/iissnan/hexo-theme-next.git (push)第五步, 获取变更（获取next主题最新的修改），切换到master（一般不需要切换，可以通过git branch看到应该是处于 master 分支），合并更改(获取next主题主线版本的最新修改)，最后把修改推送到fork的分支里1234git fetch upstreamgit checkout mastergit merge upstream/mastergit push origin master在新的环境上部署安装 git、node.js、hexo 后clone hexo相关配置12git clone git@github.com:jiexiao111/hexo_jiexiao.gitcd hexo_jiexiaoclone hexo相关配置1git clone git@github.com:jiexiao111/hexo-theme-next.git themes/next安装相关插件1npm install测试新环境的部署功能1hexo d -g其他设置及常用操作一些不好分类但是非常有用的设置及操作设置正文页面宽度编辑hexo_dir/themes/next/source/css/_variables/custom.styl12345// 修改成你期望的宽度$content-desktop = 1000px// 当视窗超过 1600px 后的宽度$content-desktop-large = 1400px解决网页分类/标签显示错误1234rm db.jsonhexo cleanhexo ghexo s创建分类和标签在 hexo 安装目录下执行以下命令, 用于增加标签和分类目录12hexo new page tagshexo new page categories在生成的文件中分别写入以下信息12345678910111213cat &gt; source/tags/index.md ---title: tagsdate: 2017-09-10 12:21:49type: "tags"---cat &gt; source/categories/index.md---title: categoriesdate: 2017-09-10 12:25:38type: "categories"---使用 chrome 分析网页加载速度在 chrome 流量器中按 F12 或者单击鼠标右键-&gt;检查, 打开调试栏-&gt;Network, 刷新网页就可以看到以下信息了Hexo 框架及 Next 主题相关文档链接提供一些高质量的链接，便于参考Hexo 的官方文档，满满的诚意next 官方文档，进去就充满了好感从 jekyll 转换到 hexo 多亏了下面这篇文章]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法示例]]></title>
    <url>%2F2017%2F09%2F10%2Fhello-world.html</url>
    <content type="text"><![CDATA[本篇博文不仅仅包含 Markdown 基础语法, 也有 Hexo 定义的一些标签, 主要是自己 copy 起来方便, 所有的章节一定是语法+示例, 不用怀疑标题markdown 标题语法, # 号个数代表标题级别12345## 二级标题示例### 三级标题示例#### 四级标题示例##### 五级标题示例###### 六级标题示例二级标题示例三级标题示例四级标题示例五级标题示例六级标题示例列表无序列表懒得记, 无序列表我只用 * 开头12345* 一级无序列表 * 二级无序列表 * 三级无序列表 * 四级无序列表* 一级无序列表一级无序列表二级无序列表三级无序列表四级无序列表一级无序列表有序列表有序列表以 1. 2. 3. 开头, 注意第四行, 真实显示的需要是自动生成的123451. 一级有序列表 1. 二级有序列表 2. 三级有序列表 4. 注意序号是自动生成的2. 有序列表一级有序列表二级有序列表二级有序列表注意序号是自动生成的有序列表待办列表语法应该就是 - [x] 开头的行1234- [x] @mentions, #refs, [links](), **formatting**, and &lt;del&gt;tags&lt;/del&gt; are supported - [x] list syntax is required (any unordered or ordered list supported) - [x] this is a complete item - [ ] this is an incomplete item@mentions, #refs, links, formatting, and tags are supportedlist syntax is required (any unordered or ordered list supported)this is a complete itemthis is an incomplete item引用标准引用引用以一个或多个 &gt; 开头, 注意第四行的空行, 如果没有空行第五行也会是三级引用12345&gt; 这是一级引用&gt;&gt; 这是二级引用&gt;&gt;&gt; 这是三级引用&gt; 这是一级引用这是一级引用这是二级引用这是三级引用这是一级引用centerquote 标签非常适合单行的引用, 比较好看1&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125;blah blah blahblockquote 标签123&#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&#125;Every interaction is both precious and an opportunity to delight.&#123;% endblockquote %&#125;Every interaction is both precious and an opportunity to delight.Seth GodinWelcome to Island Marketingnote 标签1&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125;其中，class_name 可以是以下列表中的一个值：defaultprimarysuccessinfowarningdanger123&#123;% note warning %&#125;举个例子&#123;% endnote %&#125;举个例子代码块用 ``` 包围起来的就是代码块, 这个没法演示, 这里展示使用标签的方式, 下面是代码标签的语法123&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125;举两个例子:最简单的例子123&#123;% codeblock %&#125;print(&apos;Hello World!&apos;);&#123;% endcodeblock %&#125;效果如下:1print(&apos;Hello World!&apos;);附加说明和网址, 其中 [title] 是 _.compact, [lang:language] 是 lang:objc, [url] 是 http://underscorejs.org/#compact [link text] 是 Underscore.js123&#123;% codeblock lang:objc _.compact http://underscorejs.org/#compact Underscore.js %&#125;[rectangle setX: 10 y: 10 width: 20 height: 20];&#123;% endcodeblock %&#125;效果如下:_.compactUnderscore.js1[rectangle setX: 10 y: 10 width: 20 height: 20];链接行内式链接行内式链接的语法结构为 [链接的描述](link &quot;鼠标放到链接上后的提示&quot;)1这就是行内链接：[李阿昀的简书](http://www.jianshu.com &quot;李阿昀的简书&quot;)这就是行内链接：李阿昀的简书参考式链接12341. [李阿昀的简书][1]2. [Hexo 中文文档][2][1]: &lt;http://www.jianshu.com/p/250e36bb5690#fn_lemma_footer&gt;[2]: &lt;https://hexo.io/zh-cn/docs/tag-plugins.html&gt;李阿昀的简书Hexo 中文文档自动链接用 &lt;&gt; 包围的就是自动链接, 没有 http 就不会显示12&lt;http://example.com/&gt;&lt;example.com/&gt;http://example.com/博客内部链接1&#123;% post_link &quot;Hash_implement&quot; %&#125;Hash 实现1&#123;% post_link &quot;hello-world&quot; &quot;Deploy to remote sites&quot; %&#125;Deploy to remote sites锚点点击位置1[点击跳转](#jump)目标位置1&lt;span id=&quot;jump&quot;&gt;跳转到的地方&lt;/span&gt;可以看到 jump 关联了点击位置和目标位置点击跳转图片插入图片与插入链接的语法很像，区别在一个!号，而且也有行内式和参考式两种。行内式图片行内式优势在于简单, 图片语法为：![无法显示图片时的说明](图片地址或者链接 &quot;鼠标悬停提示&quot;)显示链接图片1![图灵社区](http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg)显示失效链接图片1![图灵社区](http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg1)显示本地图片1![github](/images/github-page.png)参考式图片参考式优势在于可以多次引用网址, 类似声明 Constant 变量, 参考式图片我没有找到使用本地图片的办法12![链接图片][3][3]: http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg标签显示图片标签显示图片的语法1&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125;基础应用1&#123;% img &apos;/images/github-page.png&apos; %&#125;标签放大显示图片优势是可以强调图片显示1&#123;% fi &apos;/images/github-page.png&apos;, alt, title %&#125;字体/行内代码/删除线使用**表示粗体, 使用*表示斜体。符号和文字间不能有空格使用 `` 包围表示行内代码使用 ~~ 包围表示删除线123456**粗体***斜体*~~删除线~~*~~斜体删除线~~*``行内代码``普通字体粗体斜体删除线斜体删除线行内代码普通字体表格用|表示表格纵向边界，表头和表内容用-隔开，并可用:进行对齐设置，两边都有:则表示居中，若不加:则默认左对齐。详细说明：----:为右对齐:----为左对齐:---:为居中对齐-----为默认左对齐正常的表格12345dog | bird | cat----|------|----foo | foo | foobar | bar | barbaz | baz | bazdogbirdcatfoofoofoobarbarbarbazbazbaz复杂的表格12345| 序号 | 交易名 | 交易说明 | 备注 || ---: | :----: | :------- | ---- || 1 | prfcfg | 菜单配置 | 可以通过此交易查询到所有交易码和菜单的对应关系 || 2 | gentmo | 编译所有交易 | || 100000 | sysdba | 数据库表模型汇总 | |序号交易名交易说明备注1prfcfg菜单配置可以通过此交易查询到所有交易码和菜单的对应关系2gentmo编译所有交易100000sysdba数据库表模型汇总分割线使用---表示分割线, 其他形式不管1---LaTeX 公式行内公式$ 表示行内公式1质能方程 $E=mc^2$质能方程 $E=mc^2$整行公式$$ 表示整行公式1$$\sum_&#123;i=1&#125;^n a_i=0$$$$\sum_{i=1}^n a_i=0$$访问 MathJax 参考更多使用方法。暂不使用的高级特性内嵌图标, 更多的图标和玩法可以参看 font-awesome 官方网站。定义型列表注脚流程图, 更多语法参考：流程图语法参考序列图, 更多语法参考：序列图语法参考参考跳转到的地方李阿昀的简书Hexo 中文文档Github Page 官方帮助作业部落]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hash 实现]]></title>
    <url>%2F2017%2F09%2F10%2FHash_implement.html</url>
    <content type="text"><![CDATA[C语言标准库中未实现hashtable, 在编程练习时经常使用该数据结构，以备不时之需实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;typedef unsigned char u8_t;typedef char s8_t;typedef unsigned short u16_t;typedef signed short s16_t;typedef unsigned int u32_t;typedef signed int s32_t;typedef long long s64_t;typedef unsigned long long u64_t;typedef s32_t err_t;typedef unsigned long ulong_t;void* xxx_malloc(int size)&#123; void* ret = malloc(size); printf("malloc %p\n", ret); return ret;&#125;void xxx_free(void* ptr)&#123; printf("free %p\n", ptr); free(ptr);&#125;#define offset_of(type, member) ((unsigned long)&amp;((type *)0)-&gt;member)#define container_of(ptr, type, member) \ ((type *)((unsigned char *)ptr - offset_of(type,member)))#define hlist_entry(ptr, type, member) container_of(ptr,type,member)#define hlist_for_each(pos, head) for (pos = (head)-&gt;first; pos; pos = pos-&gt;next)#define hlist_for_each_safe(pos, n, head) \ for (pos = (head)-&gt;first; pos &amp;&amp; (n = pos-&gt;next, 1); pos = n)#define hlist_for_each_entry(type_pos, ptr, pos, head, member) \ for (pos = (head)-&gt;first; pos &amp;&amp; (ptr = hlist_entry(pos, type_pos, member), 1); pos = pos-&gt;next)#define hlist_for_each_entry_safe(type_pos, tpos, pos, n, head, member) \ for (pos = (head)-&gt;first; \ pos &amp;&amp; (&#123; n = pos-&gt;next; 1; &#125;) &amp;&amp; \ (&#123; tpos = hlist_entry(pos, type_pos, member); 1;&#125;); \ pos = n)#define INIT_HLIST_HEAD(ptr) ((ptr)-&gt;first = NULL)struct hlist_head &#123; struct hlist_node *first;&#125;;struct hlist_node &#123; struct hlist_node *next, **pprev;&#125;;static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)&#123; struct hlist_node *first = h-&gt;first; n-&gt;next = first; if (first) first-&gt;pprev = &amp;n-&gt;next; h-&gt;first = n; n-&gt;pprev = &amp;h-&gt;first;&#125;static inline void INIT_HLIST_NODE(struct hlist_node *h)&#123; h-&gt;next = NULL; h-&gt;pprev = NULL;&#125;static inline int hlist_unhashed(const struct hlist_node *h)&#123; return !h-&gt;pprev;&#125;static inline int hlist_empty(const struct hlist_head *h)&#123; return !h-&gt;first;&#125;static inline void __hlist_del(struct hlist_node *n)&#123; struct hlist_node *next = n-&gt;next; struct hlist_node **pprev = n-&gt;pprev; *pprev = next; if (next) next-&gt;pprev = pprev;&#125;static inline void hlist_del_init(struct hlist_node *n)&#123; if (!hlist_unhashed(n)) &#123; __hlist_del(n); &#125;&#125;typedef struct _xxx_hash_bucket_head &#123; struct hlist_head chain; // hash 桶的头结点&#125; xxx_hash_bucket_head;typedef struct _xxx_hashtable &#123; xxx_hash_bucket_head *tbl; // hash 表中的 hash 桶 s8_t *name; // hash 表的名称, 未使用 u32_t cnt; // 保存关键字 hash 后的最大值 u32_t element_cnt; // 记录当前 hash 表中的元素数量 u32_t offset; // hlist_node 成员与包含该成员结构体的地址偏移 u32_t (*hash)(void *); // 关键字的 hash 算法函数 s32_t (*compare)(void *, void *); // 元素的比较函数 void (*destroy)(void *); // 反初始化时对每个元素的反初始化操作函数&#125; xxx_hashtable_t;void *hashtable_init(s8_t *name, u32_t cnt, u32_t offset, u32_t (*hash)(void *), s32_t (*compare)(void *, void *), void (*destroy)(void *))&#123; xxx_hashtable_t *tbl; u32_t i; u32_t size; assert(!(cnt &amp; (cnt - 1))); assert(NULL != hash); assert(NULL != compare); if (NULL == (tbl = (xxx_hashtable_t*)xxx_malloc(sizeof(xxx_hashtable_t)))) &#123; return NULL; &#125; size = sizeof(xxx_hash_bucket_head) * cnt; if (NULL == (tbl-&gt;tbl = xxx_malloc(size))) &#123; xxx_free(tbl); return NULL; &#125; tbl-&gt;name = name; tbl-&gt;cnt = cnt; tbl-&gt;element_cnt = 0; tbl-&gt;offset = offset; tbl-&gt;hash = hash; tbl-&gt;compare = compare; tbl-&gt;destroy = destroy; for (i = 0; i &lt; cnt; i++) &#123; INIT_HLIST_HEAD(&amp;(tbl-&gt;tbl[i].chain)); &#125; return tbl;&#125;void hashtable_fini(void *tbl)&#123; u32_t i; struct hlist_node *pos, *n; xxx_hash_bucket_head *h; u32_t size; u32_t offset; if (NULL == tbl) &#123; return; &#125; offset = ((xxx_hashtable_t *)tbl)-&gt;offset; for (i = 0; i &lt; ((xxx_hashtable_t *)tbl)-&gt;cnt; i++) &#123; h = &amp;((xxx_hashtable_t *)tbl)-&gt;tbl[i]; hlist_for_each_safe(pos, n, &amp;h-&gt;chain) &#123; if (NULL != ((xxx_hashtable_t *)tbl)-&gt;destroy) &#123; ((xxx_hashtable_t *)tbl)-&gt;destroy((void *)((u8_t *)pos - offset)); &#125; &#125; &#125; size = sizeof(struct hlist_head) * ((xxx_hashtable_t *)tbl)-&gt;cnt; xxx_free(((xxx_hashtable_t *)tbl)-&gt;tbl); xxx_free(tbl);&#125;static inline void *hashtable_find(void *tbl, void *elem)&#123; struct hlist_node *pos; xxx_hash_bucket_head *h; u32_t hash; hash = ((xxx_hashtable_t *)tbl)-&gt;hash(elem); assert(hash &lt; ((xxx_hashtable_t *)tbl)-&gt;cnt); h = &amp;((xxx_hashtable_t *)tbl)-&gt;tbl[hash]; hlist_for_each(pos, &amp;h-&gt;chain) &#123; if (!((xxx_hashtable_t *)tbl)-&gt;compare(elem, (u8_t *)pos - ((xxx_hashtable_t *)tbl)-&gt;offset)) &#123; return (void *)((u8_t *)pos - ((xxx_hashtable_t *)tbl)-&gt;offset); &#125; &#125; return NULL;&#125;static err_t hashtable_insert(void* hashtable, void* elem)&#123; struct hlist_node* pos; xxx_hash_bucket_head* bucket; u32_t hash; hash = ((xxx_hashtable_t *)hashtable)-&gt;hash(elem); assert(hash &lt; ((xxx_hashtable_t *)hashtable)-&gt;cnt); bucket = &amp;((xxx_hashtable_t *)hashtable)-&gt;tbl[hash]; hlist_for_each(pos, &amp;bucket-&gt;chain) &#123; if (!((xxx_hashtable_t *)hashtable)-&gt;compare(elem, (u8_t *)pos - ((xxx_hashtable_t *)hashtable)-&gt;offset)) &#123; return -1; &#125; &#125; hlist_add_head((struct hlist_node *)((u8_t *)elem + ((xxx_hashtable_t *)hashtable)-&gt;offset), &amp;bucket-&gt;chain); ((xxx_hashtable_t *)hashtable)-&gt;element_cnt++; return 0;&#125;static inline void hashtable_delete(void *hashtable, void *elem)&#123; xxx_hash_bucket_head *bucket; u32_t hash; hash = ((xxx_hashtable_t *)hashtable)-&gt;hash(elem); assert(hash &lt; ((xxx_hashtable_t *)hashtable)-&gt;cnt); bucket = &amp;((xxx_hashtable_t *)hashtable)-&gt;tbl[hash]; hlist_del_init((struct hlist_node *)((u8_t *)elem + ((xxx_hashtable_t *)hashtable)-&gt;offset)); if (NULL != ((xxx_hashtable_t *)hashtable)-&gt;destroy) &#123; ((xxx_hashtable_t *)hashtable)-&gt;destroy(elem); &#125; ((xxx_hashtable_t *)hashtable)-&gt;element_cnt--;&#125;/* Hash map 实现 */#define MAP_BUCKET_CNT (1 &lt;&lt; 6)typedef struct _str_map_t&#123; int m_value; struct hlist_node hash_node;&#125; str_map_t;/* 创建 str_map_t 对象 */str_map_t* str_map_init();/* 销毁 str_map_t 对象 */void str_map_fini(str_map_t* p_str_map);/* 插入元素 */void str_map_insert(str_map_t* p_str_map);/* 删除元素 */void str_map_erase(str_map_t* p_str_map);/* 查找元素 */void str_map_erase(str_map_t* p_str_map);/* 测试函数 */typedef struct _hlist_demo_t&#123; int m_value; struct hlist_node hash_node;&#125; hlist_demo_t;static u32_t demo_hash(void *pkt)&#123; return (u32_t)(((hlist_demo_t*)pkt)-&gt;m_value) % BUCKET_CNT;&#125;static s32_t demo_compare(void *pkt, void *pkt2)&#123; if (((hlist_demo_t*)pkt)-&gt;m_value == ((hlist_demo_t*)pkt2)-&gt;m_value) &#123; return 0; &#125; return -1;&#125;static void demo_destroy(void *arg)&#123; xxx_free(arg);&#125;int main()&#123;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>hash</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
</search>
