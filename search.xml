<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[手写汉字识别]]></title>
    <url>%2F2018%2F01%2F02%2FHandwritten-Chinese-Character-Recogition.html</url>
    <content type="text"><![CDATA[部门组织的 AI 编程比赛，正好拿来熟悉下数据集下载12wget http://www.nlpr.ia.ac.cn/databases/download/feature_data/HWDB1.1trn_gnt.zipwget http://www.nlpr.ia.ac.cn/databases/download/feature_data/HWDB1.1tst_gnt.zip解压文件，需要注意的是 HWDB1.1trn_gnt.zip 需要解压两次读取数据1234567891011121314151617181920212223242526272829import osimport numpy as npimport structtrain_data_dir = &quot;HWDB1.1trn_gnt&quot;test_data_dir = &quot;HWDB1.1tst_gnt&quot;# 读取图像和对应的汉字def read_from_gnt_dir(gnt_dir=train_data_dir): def one_file(f): header_size = 10 while True: header = np.fromfile(f, dtype=&apos;uint8&apos;, count=header_size) if not header.size: break sample_size = header[0] + (header[1]&lt;&lt;8) + (header[2]&lt;&lt;16) + (header[3]&lt;&lt;24) tagcode = header[5] + (header[4]&lt;&lt;8) width = header[6] + (header[7]&lt;&lt;8) height = header[8] + (header[9]&lt;&lt;8) if header_size + width*height != sample_size: break image = np.fromfile(f, dtype=&apos;uint8&apos;, count=width*height).reshape((height, width)) yield image, tagcode for file_name in os.listdir(gnt_dir): if file_name.endswith(&apos;.gnt&apos;): file_path = os.path.join(gnt_dir, file_name) with open(file_path, &apos;rb&apos;) as f: for image, tagcode in one_file(f): yield image, tagcode在 Tensorboard 中显示图片http://www.blogs8.cn/posts/Ezqbef9https://zhuanlan.zhihu.com/p/30197320参考手写汉字识别使用 Tensorboard 显示图片]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 下代理配置]]></title>
    <url>%2F2018%2F01%2F02%2Flinux-proxy-config.html</url>
    <content type="text"><![CDATA[经常会用到一些代理配置，这里做个汇总wget1234567cat &gt; ~/.wgetrc# For example ftp_proxy, ftp-proxy and ftpproxy are the same.https_proxy = http://USERNAME:PASSWD@URL:PORThttp_proxy = http://USERNAME:PASSWD@URL:PORTftp_proxy = http://USERNAME:PASSWD@URL:PORT# If you do not want to use proxy at all, set this to off.use_proxy = oncurl12cat &gt; ~/.curlrc--proxy http://USERNAME:PASSWD@URL:PORTglobal12345678cat &gt; /home/proxy.sh# http 配置ftp_proxy=http://USERNAME:PASSWD@URL:PORTexport ftp_proxyhttps_proxy=http://USERNAME:PASSWD@URL:PORTexport https_proxyhttp_proxy=http://USERNAME:PASSWD@URL:PORTexport http_proxygit123# git 配置git config --global http.proxy http://china\\\USERNAME:PASSWD@URL:PORTgit config --global https.proxy https://china\\\USERNAME:PASSWD@URL:PORTpip1pip3 --proxy=http://USERNAME:PASSWD@URL:PORT install tensorflowconda1234567891011121314$ cat ~/.condarcchannels:- defaults# Show channel URLs when displaying what is going to be downloaded and# in &apos;conda list&apos;. The default is False.show_channel_urls: Trueallow_other_channels: Trueproxy_servers: http: http://USERNAME:PASSWD@URL:PORT https: http://USERNAME:PASSWD@URL:PORTssl_verify: Falseapt-get123$ cat /etc/apt/apt.confAcquire::http::Proxy &quot;http://USERNAME:PASSWD@URL:PORT&quot;;Acquire::https::Proxy &quot;http://USERNAME:PASSWD@URL:PORT&quot;;yum1234cat /etc/yum.confproxy=http://URL:PORTproxy_username=USERNAMEproxy_password=PASSWD]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 程序调试]]></title>
    <url>%2F2018%2F01%2F02%2Fc-debug.html</url>
    <content type="text"><![CDATA[调试 C 语言多年，简单总结一下自己的心得一些想法作为开发人员，我们每天大部分的时间都在进行调试，只有清晰的认识我们的工具才能更高效的进行工作。一般来说，我们遇到的大部分问题都是业务流程出现了问题，这里的业务流程不仅仅指的是报文收发，也包括引用计数器的操作，对象成员的读写等等，这类问题的特点是，各个函数实现本身没有问题，但是以某种特殊的序列执行后就引入了问题，通常来说充满各种回调的模块我们通过代码可能无法预见到所有的调用顺序。GDB 脚本开销：2ms 每次命中优势：GDB 脚本是调试最高效的办法，我们无需修改和编译代码就能够掌握程序的动态信息。劣势：GDB 断点命中后，会触发中断、进程切换、系统调用、文件读写等一系列高消耗的操作，所以高频率的命中会占用很高的 CPU，在 Microkernel 中很可能导致定时器紊乱、用户无法发起等异常。适用场景：断点命中频率小于每秒 100 次（断点命中占用 CPU 20%），或者更本不在乎 CPU 是否过载的场景。通常开发在进行功能自验证时或者走读陌生模块的代码时，这种方式是最为实用的。日志打印开销： 2us 每行日志优势： 流程相关的问题，日志基本上是万能的方法劣势： 通常需要反复增加日志进行问题复现，反复的进行修改代码——编译 —— 复现，定位效率并不高 。另外，日志打印的信息占用的硬盘空间大，3M 行日志差不多需要占用 1G 的硬盘空间。适用场景： 日志打印速率小于 100K 行的场景（打印日志占用 CPU 20%）流程信息保存至内存开销： 平均 20ns 每写入 8 字节优势： 极其高效的记录速率，在定位 Microkernel 中状态机、Socket 相关问题时非常有效劣势： 依赖于良好的代码实现，否则需要进行较多调整适用场景： 每秒写入流程信息小于 10M 条的场景，如，高频读写的对象出现异常GDB 脚本和日志打印较为常用，不再累述，主要通过定位 Microkernel 状态跃迁异常的问题来说明一下如何将流程信息保存至内存。我们 NTE 的执行的大致流程为：1、平台调用协议的接口执行 action，协议执行完成后向平台发送 event；2、平台遍历 event 链表，修改 event 对应的 FSM 的状态；3、平台遍历 fsm 链表，根据 fsm 的状态确定下一个动作，然后调用协议的执行接口执行下一个 action。如果在第三步中协议发现平台调用了错误的 action，我们只能知道 FSM 的状态出现了错误，但是如何出错的已经无法知晓，因为在第二步遍历 event 链表后，该链表的资源已经被完全清空。定位这个问题，我们至少需要打印每一个 FSM 的每一次状态跃迁以及每一个 FSM 收到的每一个 event，此时问题就来了，FSM 的状态切换和 event 的触发都是极其频繁的调用，打印日志导致 CPU 负载进一步升高，很容易导致其他异常，另外，如果用户使用自动化运行测试，很可能出现日志被覆盖的情况。我计算过打印一条日志大致需要 2us，现在需要进一步减少记录流程的消耗，只有考虑把日志写入内存了，一般来说 8 字节写入 L1cache 小于 1ns, L2 cache 小于 10ns， L3 cache 小于 50ns，写入主存小于 100ns，高频度的写入，意味着高的 Cache 命中率，所以写入内存的时间期望在 20ns 左右，相较日志打印提升了 100 倍性能。以 1W 用户在线，每个用户每秒需要记录 20 次信息为例，每秒打印日志需要消耗 1W 20 2us = 400ms，即 40% CPU，如果场景本身消耗的 CPU 超过 50% 则会出现 CPU 过载等异常。可以看出就必须把流程信息保存至内存。现在有两个问题：1、保存在哪； 2、保存哪些信息。第一个问题：我们可以看到问题的重点为 FSM 对象，所以，这些信息我们保存至 FSM 对象的结构体中，以每个 FSM 保存 640 字节信息来算，20K 在线用户仅需要消耗 13M 空间第二个问题：需要保存触发 FSM 状态跃迁和 event 触发的位置，通常这些位置处于公共接口，所以还需要打印上几层调用栈所在的位置，通常我们只需要保存 5 层栈信息就足够了（每个栈指针 8 字节）。历史栈信息我们只需要保存最近 16 次的信息即可。所以只需要 5 8 16 * 20K 就能够记录所有用户最近二十次重要的修改记录，如果出现问题，只需要打印指定的 FSM 中保存的信息即可。其他需要将流程信息保存至内存场景举例：协议栈中 Socket 引用计数器发生错误。我们按照典型场景 1024 包长打满 10Gpbs 流量进行估算，每个 Microkernel 需要达到 10Gpbs / 1024 / 3 = 3Mpps，这种高负载场景，GDB 脚本就不要想了，我们假设每发送一个报文打印一条日志，3M / 50K * 20% = 1200% ，显然通过 Microkernel 日志接口打印信息也是不现实的。即使 CPU 不是瓶颈，3M 行日志大致要占用 1G 的空间，也就是说 10s 就会打印 10G 的日志，这个大小的文件打开和操作已经非常慢了，如果定位问题需要打印超过 10s 日志就更加艰难了，而我们最常见的问题通常复现时间是几分钟或者几个小时，这种情况下，通过将流程信息保存至 Socket 结构体中就很很好的定位。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 使用]]></title>
    <url>%2F2017%2F12%2F31%2Fgit-zsh-plugin.html</url>
    <content type="text"><![CDATA[经常在使用 git，但是使用的命令都是那几个，有时候想达到特殊目的时都要查半天，所以决定整理一下，如果安装了 oh-my-zsh，则快捷命令均能生效table th:nth-of-type(1){width:100px}table th:nth-of-type(2){width:500px}table th{font-weight:700;font-size:12pt;text-align:center!important;background:rgba(158,188,226,.2)}git 基础功能git clone 克隆版本库开始一个项目时，第一步就是将远程代码 clone 到本地1gcl https://github.com/jiexiao111/hexo_jiexiao.gitAliasBriefCMDgcl递归的 clonegit clone --recursivegit config 配置环境可以通过 gcf 查看已经配置的环境变量AliasBriefCMDgcf查看 git 的配置git config --listgit clean 清理工作目录如果想要放弃工作区中所有变更，可以使用 git clean1gcleanAliasBriefCMDgclean删除当前目录下没有 git add 的文件git clean -dfgit status 状态概览如果需要查看当前目录下文件的状态则需要使用 git status 命令1gssAliasBriefCMDgst显示工作区状态git statusgss简洁的显示工作区状态git status -sgsb简洁的显示工作区状态，同时展示分支状态git status -sbgit add 保存至暂存区git 在 commit 时，仅会提交暂存区中的变更，所以新增或删除文件时，可以使用 git add 将修改保存至暂存区1gaaAliasBriefCMDga添加指定修改至暂存区git addgaa添加所有修改至暂存区git add --allgapa添加指定修改至暂存区，但是可以对提交结果进行编辑git add --patchgit commit 提交至仓库使用 git commit 将暂存区的变更提交1gcamAliasBriefCMDgcmsg提交暂存区指定文件到仓库区git commit -mgcam提交暂存区所有修改到仓库区git commit -a -mgca提交暂存区所有修改到仓库区，通过 vi 查看修改详情，并添加提交备注git commit -v -agc!通过 vi 查看上一次修改详情，并添加提交备注git commit -v --amendgca!提交暂存区所有修改到仓库区，与上一次 commit 合并，通过 vi 查看修改详情，并添加提交备注git commit -v -a --amendgcan!提交暂存区所有修改到仓库区，与上一次 commit 合并git commit -v -a -s --no-edit --amendgit diff 差异比较经常需要查看修改的详情，如果是需要查看未执行 gaa 的变更，则使用 gd, 如果需要查看已经执行 gaa 的变更，则需要执行 gdcaAliasBriefCMDgd查看未暂存的修改git diffgdw查看未暂存的修改，以单词的维度，很适合长句中修改了个别单词的对比git diff --word-diffgdca查看已暂存的修改git diff --cachedgit blame 查看某个文件的提交历史AliasBriefCMDgbl查看某个文件的提交历史git blame -b -wgdt查看某次提交修改了哪些文件git diff-tree --no-commit-id --name-only -rgsps查看某次提交的详情，通常配合 gbl 使用git show --pretty=short --show-signaturegwch查看某一个文件的变更记录git whatchanged -p --abbrev-commit --pretty = mediumgit log 查看提交历史AliasBriefCMDglg查看提交日志，显示提交代码量的统计信息git log --stat --colorglgg查看提交日志，以简单图形的方式显示git log --graph --colorglgga同上，显示所有 branchgit log --graph --decorate --allglgm查看提交日志，最多显示 10 条git log --graph --max-count = 10glgp查看提交日志，同时查看变更详情git log --stat --color -pglo查看提交日志，在一行内显示git log --oneline --decorate --colorglog查看提交日志，在一行内显示，以简单图形的方式显示git log --oneline --decorate --color --graphglol查看提交日志，在一行内显示，以简单图形的方式显示，显示提交日期和提交人见 glol 章节glola同上，显示所有 branch见 glola 章节gcount统计每个人提交的次数git shortlog -sngit reset 撤销AliasBriefCMDgru不知道与 grh 的区别git reset --grh放弃暂存区的修改git reset HEADgrhh放弃暂存区的修改，同时放弃工作区中已经暂存的修改git reset HEAD --hardgpristine放弃暂存区的修改，同时放弃工作区的全部修改git reset --hard &amp;&amp; git clean -dfxgit bisect 错误提交定位当你需要找出某次提交引入的错误时，就需要使用git bisect做二分查找首先，进入 bisect 模型，然后标记一个有问题的版本和一个没问题的版本123gbssgbsb # 当前版本是有问题的gbsg v2.6 # 2.6 版本是没有问题的此时，版本已经切换到中间的某个版本了，我们可以验证这个版本是否正常，如果正常，则使用1gbsg此时，版本又切换到某个中间版本，继续验证，如果有问题，则使用1gbsb最终肯定能找到出现问题的提交记录，最后使用 gbsr 切换至输入 gbss 前的版本AliasBriefCMDgbsNAgit bisectgbsb标记为有问题提交git bisect badgbsg标记为无问题提交git bisect goodgbsr回到gbss前的状态git bisect resetgbss开始定位提交错误git bisect startgit remote 远程仓库管理运行 git remote add &lt;shortname&gt; &lt;url&gt; 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：12345678$ git remoteorigin$ git remote add pb https://github.com/paulboone/ticgit$ git remote -vorigin https://github.com/schacon/ticgit (fetch)origin https://github.com/schacon/ticgit (push)pb https://github.com/paulboone/ticgit (fetch)pb https://github.com/paulboone/ticgit (push)AliasBriefCMDgr查看远程仓库git remotegrv查看远程仓库及其对应的 URLgit remote -vgra添加远程仓库git remote addgrmv重命名远程仓库git remote renamegrrm删除远程仓库git remote removegrset修改远程仓库的 URLgit remote set-urlgrupgit remote updategit fetch 拉取远程分支AliasBriefCMDgfgit fetchgfagit fetch --all --prunegfogit fetch origingit checkout 分支创建与切换如果想放弃工作区的某个文件的修改可以使用 git checkout -- filenamegco -- filenameAliasBriefCMDgco切换至指定分支git checkoutgcb创建并切换至分支git checkout -bgcm切换至 master 分支git checkout mastergcd切换至 develop 分支git checkout developgit branch 分支查询与删除AliasBriefCMDgb查看本地分支，如果指定branch name则新建分支，但停留在当前分支git branchgbr查看远程分支git branch --remotegba查看本地及远程分支git branch -agbnm查看未 merge 的分支git branch --no-mergedgbd删除branch name分支git branch -dgbda删除已经 merge 的分支，不包括：当前分支、master/develop/dev 分支见 gbda 章节ggsup建立本地分支和远端分支的关系git branch --set-upstream-to=origin/$(git_current_branch)git merge 合并分支AliasBriefCMDgm合并指定分支至当前分支git mergegmom合并 origin 分支至当前分支git merge origin/mastergmum合并 upstream 分支至当前分支git merge upstream/mastergmtgit mergetool --no-promptgmtvimgit mergetool --no-prompt --tool = vimdiff忽略文件AliasBriefCMDgignore忽略文件git update-index --assume-unchangedgunignore取消忽略文件git update-index --no-assume-unchangedgignored查看忽略的文件git ls-files -v grep &quot;^[[:lower:]]&quot;git submodule 子模块AliasBriefCMDgsigit submodule initgsugit submodule updategit stash 保存工作进度AliasBriefCMDgstagit stash savegstaagit stash applygstdgit stash dropgstlgit stash listgstpgit stash popgstcgit stash cleargstsgit stash show –textgwip见 gwip 章节gunwip见 gunwip 章节git push 推送至远程仓库AliasBriefCMDggp见 ggp 章节gpgit pushgpdgit push –dry-rungpoatgit push origin –all &amp;&amp; git push origin –tagsgpugit push upstreamgpvgit push -vggfgit push –force origin $(current_branch)gpsupgit push –set-upstream origin $(current_branch)git pull 拉取远程仓库AliasBriefCMDggl将 origin 的变更更新至指定分支，若未指定则默认当前分支见 ggl 章节glgit pullgupgit pull –rebasegupvgit pull –rebase -vglumgit pull upstream masterggu见 ggu 章节git rebase 合并AliasBriefCMDgrbgit rebasegrbagit rebase –abortgrbcgit rebase –continuegrbigit rebase -igrbmgit rebase mastergrbsgit rebase –skipgit cherry-pick 选择某次 commit 再次提交git cherry-pick 可以选择某一个分支中的一个或几个 commit(s) 来进行操作。例如，假设我们有个稳定版本的分支，叫 v2.0，另外还有个开发版本的分支 v3.0，我们不能直接把两个分支合并，这样会导致稳定版本混乱，但是又想增加一个 v3.0 中的功能到 v2.0 中，这里就可以使用 cherry-pick 了，其实也就是对已经存在的 commit 进行再次提交。AliasBriefCMDgcpgit cherry-pick再次提交 commitgit cherry-pickgcpagit cherry-pick –abortgcpcgit cherry-pick –continue杂项AliasBriefCMDgrt进入 git 仓库的根路径cd $(git rev-parse --show-toplevel)ghh帮助git helpgit svn 通过 git 管理 svnAliasBriefCMDgit-svn-dcommit-pushgit svn dcommit &amp;&amp; git push github master:svntrunkgsdgit svn dcommitgsrgit svn rebase长命令说明gbda1git branch --no-color --merged | command grep -vE &quot;^(\*|\s*(master|develop|dev)\s*$)&quot; | command xargs -n 1 git branch -dglol1git log --graph --pretty=&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commitglola1git log --graph --pretty=&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --allgwip1git add -A; git rm $(git ls-files --deleted) 2&gt; /dev/null; git commit --no-verify -m &quot;--wip-- [skip ci]&quot;gunwip1git log -n 1 | grep -q -c &quot;\-\-wip\-\-&quot; &amp;&amp; git reset HEAD~1git修改默认编辑器为 vimgit config –global core.editor vim保存提交密码更好的方式是使用秘钥1git config --global credential.helper store生成秘钥git 官方帮助 描述的非常清楚，如果是 Linux 系统，首先通过命令生成秘钥，注意下面命令中的 jiexiao111@gmail.com 是你注册 github 时的邮箱1ssh-keygen -t rsa -C jiexiao111@gmail.com想办法把下面这个文件的内容拷贝出来1~/.ssh/id_rsa.pub然后打开你的 github 主页，依次点击 Settings-&gt;SSH and GPG keys-&gt;New SSH key, 然后 Title 随便取个名字，再把 ~/.ssh/id_rsa.pub 中的内容拷贝到 Key 中，Add SSH key 完成添加-解决 git 中文乱码1git config --global core.quotepath false撤销 commit 但是保留修改1git reset --soft [commit_id] 就可以回滚到某一个 commit，然后保留下修改的内容比较文件https://gist.github.com/jhjguxin/3271961git clone 时 Resolving deltas 后卡住具体原因不清楚，最后的解决方案是：将其他环境已经 git clone 的目录拷贝至当前环境执行 git fsck执行 ggl参考oh-my-zsh:Plugin:GitGit 常用命令速查表GitbookGit 最常用功能，这一篇就够了！（结合开发场景）]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anaconda 安装]]></title>
    <url>%2F2017%2F12%2F29%2Fubuntu-install-anaconda.html</url>
    <content type="text"><![CDATA[安装 anaconda检查操作系统类型12root@jiexiao:~/hexo_jiexiao# uname -aLinux jiexiao 4.13.0-16-generic #19-Ubuntu SMP Wed Oct 11 18:35:14 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux可以看出是 64 位操作系统下载和安装 anaconda去官网 下载安装包，通过 wget 下载，例如：1wget https://repo.continuum.io/archive/Anaconda3-5.0.1-Linux-x86_64.sh其中 5.0.1 表示 anaconda 的版本，x86_64 表示 64 位操作系统安装多版本 anaconda123456789101112bash Anaconda3-4.4.0-Linux-x86_64.shbash Anaconda2-4.4.0-Linux-x86_64.sh -b -p $HOME/anaconda3/envs/py2rm -f $HOME/anaconda3/envs/py2/bin/conda*rm -f $HOME/anaconda3/envs/py2/conda-meta/conda-*rm -f $HOME/anaconda3/envs/py2/bin/activaterm -f $HOME/anaconda3/envs/py2/bin/deactivatecd $HOME/anaconda3/envs/py2/binln -s ../../../bin/conda .ln -s ../../../bin/activate .ln -s ../../../bin/deactivate .多版本切换 anaconda[http://www.jianshu.com/p/d2e15200ee9b]1234# 显示可用的 python 环境conda info --envs# 激活 python 环境source activate py2]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过密钥进行 ssh 连接]]></title>
    <url>%2F2017%2F12%2F29%2Fvps-ssh-key.html</url>
    <content type="text"><![CDATA[每次连接 vps 都需要一个超长的密码，很不方便，所以考虑通过秘钥连接生成秘钥命令：1ssh-keygen -t rsa执行过程如下：123456789101112131415161718192021222324$ ssh-keygen -t rsaGenerating public/private rsa key pair.Enter file in which to save the key (/Users/jiexiao/.ssh/id_rsa): # 默认路径直接回车/Users/jiexiao/.ssh/id_rsa already exists.Overwrite (y/n)? yEnter passphrase (empty for no passphrase): # 这里直接回车，否则登录时还需要输入密码Enter same passphrase again:Your identification has been saved in /Users/jiexiao/.ssh/id_rsa.Your public key has been saved in /Users/jiexiao/.ssh/id_rsa.pub.The key fingerprint is:SHA256:NPT4fMqObmmFfnjIl0Ea+icJh56hLFhmSzqM1mfo+Bc jiexiao@MACThe key&apos;s randomart image is:+---[RSA 2048]----+| . || . o || + . || ..+. || oS=o . || = E= +.oo ||oB.o.o.O *oo ||=o+oo+o %o* ||.oo++ +o*. |+----[SHA256]-----+上传秘钥命令：1ssh-copy-id -i ~/.ssh/id_rsa.pub root@45.32.90.198执行过程如下：12345678910$ ssh-copy-id -i ~/.ssh/id_rsa.pub root@45.32.90.198 # 注意 45.32.90.198 应该是目标主机的 IP/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;/Users/jiexiao/.ssh/id_rsa.pub&quot;/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keysroot@45.32.90.198&apos;s password: # 输入密码Number of key(s) added: 1Now try logging into the machine, with: &quot;ssh &apos;root@45.32.90.198&apos;&quot;and check to make sure that only the key(s) you wanted were added.连接验证执行过程如下，可以看出登录不需要密码了12$ ssh root@45.32.90.198Welcome to Ubuntu 17.10 (GNU/Linux 4.13.0-16-generic x86_64)配置只允许通过秘钥登录命令：123sed -i &quot;s/#PasswordAuthentication yes/PasswordAuthentication no/g&quot; /etc/ssh/sshd_configsed -i &quot;s/#PubkeyAuthentication yes/PubkeyAuthentication yes/g&quot; /etc/ssh/sshd_configservice sshd restart重装系统后，ssh 失败错误如下：1234$ ssh root@45.32.90.198@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@编辑 vi ~/.ssh/known_hosts，删除 45.32.90.198 相关信息参考vultr 官方帮助网页ssh 通过密钥进行连接]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过 AES 加解密]]></title>
    <url>%2F2017%2F12%2F17%2FAES_encode_decode.html</url>
    <content type="text"><![CDATA[公司 IT 提出一个很奇葩的需求，他们要给我一个账户和密码，但是要求不给我明文密码，要我做一个密码输入框类似的东西，然后我自己加密保存，我着实不能理解，但是为了要到权限，我忍了……实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344import getpassfrom Crypto.Cipher import AESfrom binascii import b2a_hex, a2b_hexclass prpcrypt(): def __init__(self, key): self.key = key self.mode = AES.MODE_CBC #加密函数，如果 text 不是 16 的倍数【加密文本 text 必须为 16 的倍数！】，那就补足为 16 的倍数 def encrypt(self, text): cryptor = AES.new(self.key, self.mode, self.key) #这里密钥 key 长度必须为 16（AES-128）、24（AES-192）、或 32（AES-256）Bytes 长度。目前 AES-128 足够用 length = 16 count = len(text) if(count % length != 0) : add = length - (count % length) else: add = 0 text = text + ('\0' * add) self.ciphertext = cryptor.encrypt(text) #因为 AES 加密时候得到的字符串不一定是 ascii 字符集的，输出到终端或者保存时候可能存在问题 #所以这里统一把加密后的字符串转化为 16 进制字符串 return b2a_hex(self.ciphertext) #解密后，去掉补足的空格用 strip() 去掉 def decrypt(self, text): cryptor = AES.new(self.key, self.mode, self.key) plain_text = cryptor.decrypt(a2b_hex(text)) return plain_text.rstrip(b'\0')if __name__ == '__main__': pc = prpcrypt('keyskeyskeyskeys') #初始化密钥 count = input('Input username: ') while(True): passwd = getpass.getpass('Input passwd: ') passwd_copy = getpass.getpass('Repeat Passwd: ') if passwd == passwd_copy: break else: print('Entered passwords inconsistent, please try again.') e = pc.encrypt(passwd) d = pc.decrypt(e) print('%s' % (e))问题运行提示如下：1ModuleNotFoundError: No module named &apos;Crypto&apos;估计是 crypto 和 pycrypto 存在冲突，全部卸载后，重装 pycrypto 即可123pip3 uninstall cryptopip3 uninstall pycryptopip3 install pycrypto参考使用 Python 进行 AES 加密和解密解决 python 种输入 from Crypto.Cipher import AES 报错 ImportError: No module named Crypto.Cipher]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标签云制作]]></title>
    <url>%2F2017%2F12%2F02%2Fcreate-tag-cloud.html</url>
    <content type="text"><![CDATA[经常看人些 PPT 的时候弄一个张铺满关键字的图，装 X 到爆炸，想我 PPT 写的那么 low，于是默默的打开了 google 说来搜索过程有趣，我并不知道那种图叫什么，于是我输入了“布满关键字的图”，于是啥都没搜到… 坐在床上思考了五分钟， 这么装逼的图肯定有个装逼的名字，于是打开 Google 图片，输入“数据可视化”，emmm… 果然看到一张类似的图片，致此终于知道这个装 X 利器名为“标签云”貌似 wordart 很不错，有机会试一试安装插件Tagxedo 这个网站需要安装 Silverlight 插件 , 需要注意的是，我直接点击install for Macintosh是不行的，需要拷贝链接，然后拿到迅雷里下载。安装后重新打开浏览器依然无法显示。仔细看了下说明，才发现 Chrome 不支持 Silverligth上传标签调整颜色调整形状保存最终效果设置中文词连续显示家里的 VPN 太懒了，演示不了中文标签，但是中文标签一定会出现每个字被分开显示的问题，可以通过以下设置修改参考教你如何制作高大上的标签云]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>Tag Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组名退化]]></title>
    <url>%2F2017%2F11%2F30%2Fc-array-name-degradation.html</url>
    <content type="text"><![CDATA[之前看到的一篇文章，出处忘了，以后打算按自己的理解重新写一下数组名退化2016 年 2 月 1 日10:41个人的浅显认识， 欢迎批评指正.什么是数组类型？下面是 C99 中原话：An array type describes a contiguously allocated nonempty set of objects with aparticular member object type, called the element type.36) Array types are characterized by their element type and by the number of elements in the array. An array type is said to be derived from its element type, and if its element type is T , the array type is sometimes called ‘‘array of T ’’. The construction of an array type from an element type is called ‘‘array type derivation’’.很显然， 数组类型也是一种数据类型， 其本质功能和其他类型无异：定义该类型的数据所占内存空间的大小以及可以对该类型数据进行的操作（及如何操作）.数组类型定义的数据是什么？它是变量还是常量？char s[10] = “china”;在这个例子中， 数组类型为 array of 10 chars（姑且这样写）, 定义的数据显然是一个数组 s.下面是 C99 中原话：An lvalue is an expression with an object type or an incomplete type other than void; if an lvalue does not designate an object when it is evaluated, the behavior is undefined. When an object is said to have a particular type, the type is specified by the lvalue used to designate the object. A modifiable lvalue is an lvalue that does not have array type, does not have an incomplete type, does not have a const-qualified type, and if it is a structure or union, does not have any member (including, recursively, any member or element of all contained aggregates or unions) with a const-qualified type.看了上面的定义， 大家应该明白了 modifiable lvalue 和 lvalue 的区别， 大家也应该注意到 array type 定义的是 lvalue 而不是 modifiable lvalue. 所以说 s 是 lvalue.s 指代的是整个数组， s 的内容显然是指整个数组中的数据， 它是 china\0**（这里*表示任意别的字符）.s 的内容是可以改变的， 从这个意义上来说， s 显然是个变量.数组什么时候会”退化”下面是 C99 中原话：Except when it is the operand of the sizeof operator or the unary &amp; operator, or is a string literal used to initialize an array, an expression that has type ‘‘array of type’’ is converted to an expression with type ‘‘pointer to type’’ that points to the initial element of the array object and is not an lvalue.上面这句话说的很清楚了， 数组在除了 3 种情况外， 其他时候都要”退化”成指向首元素的指针.比如对 char s[10] = “china”;这 3 中例外情况是：(1) sizeof(s)(2) &s;(3) 用来初始化 s 的”china”;除了上述 3 种情况外，s 都会退化成 &amp;s[0], 这就是数组变量的操作方式数组与指针有什么不同？4.1 初始化的不同char s[] = “china”;char *p = “china”;在第一句中，以 &amp;s[0] 开始的连续 6 个字节内存分别被赋值为：‘c’, ‘h’, ‘i’, ‘n’, ‘a’, ‘\0’第二句中，p 被初始化为程序 data 段的某个地址，该地址是字符串”china”的首地址4.2 sizeof 的不同sizeof 就是要求一种数据（类型）所占内存的字节数. 对于 4.1 中的 s 和 psizeof(s) 应为 6, 而 sizeof(p) 应为一个”指针”的大小.这个结果可以从 1 中对于数组类型的定义和 3 中数组什么时候不会”退化”中得出来.4.3 &amp; 操作符对于 &amp; 操作符， 数组同样不会退化.4.1 中的 s 和 p 分别取地址后，其意义为：&amp;s 的类型为 pointer to array of 6 chars.&amp;p 的类型为 pointer to pointer to char.4.4 s 退化后为什么不可修改除 3 种情况外，数组 s 在表达式中都会退化为”指向数组首元素的指针”, 既 &amp;s[0]举个例子int a;(&amp;a)++; // 你想对谁 ++? 这显然是不对的对 (&amp;s[0])++ 操作犹如 (&amp;a)++, 同样是不对的，这就导致退化后的 s 变成不可修改的了.4.5 二维数组与二级指针char s[10]; 与 char p;char s2[10][8]; 与 char *p2;s 与 p 的关系，s2 与 p2 的关系，两者相同吗？紧扣定义的时候又到了.除 3 种情况外，数组在表达式中都会退化为”指向数组首元素的指针”.s 退化后称为 &amp;s[0], 类型为 pointer to char, 与 p 相同s2 退化后称为 &amp;s2[0], 类型为 pointer to array of 8 chars, 与 p2 不同&amp;s2[0] 时 s2[0] 还未退化，表示一个包含 8 个字节的数组4.6 数组作为函数参数毫无疑问， 数组还是会退化.void func(char s[10]); &lt;===&gt; void func(char *s);void func(char s[10][8]); &lt;===&gt; void func(char (*s)[8]);4.7 在一个文件中定义 char s[8], 在另外一个文件中声明 extern char *s. 这样可以吗？———file1.c———char s[8];———file2.c———extern char *s;答案是不可以. 一般来说，在 file2.c 中使用*s 会引起 core dump, 这是为什么呢？先考虑 int 的例子.———file1.c———int a;———file2.c———extern int a;file1.c 和 file2.c 经过编译后， 在 file2.o 的符号表中， a 的地址是尚未解析的file1.o 和 file2.o 在链接后， file2.o 中 a 的地址被确定。假设此地址为 0xbf8eafaefile2.o 中对该地址的使用，完全是按照声明 extern int a; 进行的，即 0xbf8eafae 会被认为是整形 a 的地址比如 a = 2; 其伪代码会对应为 ((int )0xbf8eafae) = 2;现在再看原来的例子.———file1.c———char s[8];———file2.c———extern char *s;同样， file1.c 和 file2.c 经过编译后， 在 file2.o 的符号表中， s 的地址是尚未解析的file1.o 和 file2.o 在链接后， file2.o 中 s 的地址被确定。假设此地址为 0xbf8eafaefile2.o 中对该地址的使用，完全是按照声明 extern char s; 进行的，即 0xbf8eafae 会被认为是指针 s 的地址比如 s = 2; 其伪代码会对应为 (((char **)0xbf8eafae)) = 2;((char *)0xbf8eafae) 会是什么结果呢？这个操作的意思是：将 0xbf8eafae 做为一个二级字符指针， 将 0xbf8eafae 为始址的 4 个字节 (32 位机）作为一级字符指针也就是将 file1.o 中的 s[0], s[1], s[2], s[3] 拼接成一个字符指针.那么(((char **)0xbf8eafae)) = 2; 的结果就是对 file1.o 中 s[0], s[1], s[2], s[3] 拼接成的这个地址对应的内存赋值为 2.这样怎么会正确呢？下面看看正确的写法：———file1.c———char s[8];———file2.c———extern char s[];同样， file1.c 和 file2.c 经过编译后， 在 file2.o 的符号表中， s 的地址是尚未解析的file1.o 和 file2.o 在链接后， file2.o 中 s 的地址被确定。假设此地址为 0xbf8eafaefile2.o 中对该地址的使用，完全是按照声明 extern char s[]; 进行的，即 0xbf8eafae 会被认为是数组 s 的地址比如 s = 2; 其伪代码会对应为 (((char ()[])0xbf8eafae)) = 2;((char ()[])0xbf8eafae) 会是什么结果呢？这个操作的意思是：将 0xbf8eafae 做为一个指向字符数组的指针， 然后对该指针进行操作.这就用到了数组的一个重要性质：对于数组 char aaa[10]; 来说， &amp;aaa[0], &amp;aaa, (&amp;aaa) 在数值上是相同的（其实， (&amp;aaa) 之所以在程序中会在值上等于 &amp;aaa[0], 这也是退化的结果： (&amp;aaa) 就是数组名 aaa, aaa 退化为 &amp;aaa[0]).所以， ((char ()[])0xbf8eafae) 的结果在值上还是 0xbf8eafae, 在类型上退化成”指向数组首元素的指针”那么(((char ()[])0xbf8eafae)) = 2;其伪代码就成为((char *)0xbf8eafae) = 2; 即将数组 s 的第一个元素设为 2小结论(a). 数组类型是一种特殊类型， 它定义的是数组变量， 是 lvalue 但不是 modifiable lvalue(b). 除了 3 种情况外 (sizeof, &amp;, 用做数组初始化的字符串数组）, 数组会退化成”指向数组首元素的指针”(c). 不要将数组名简单的看作不可修改的相应的指针， 它们还是有很多不同的]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c 语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 设置 ntp 服务]]></title>
    <url>%2F2017%2F11%2F30%2FNTP-service.html</url>
    <content type="text"><![CDATA[用 putty 在 linux 上写代码，如果 Windows 和 linux 时间不一致，每次保存时 vim 都会报错，非常麻烦ntp 服务方式：编辑 /etc/ntp.conf 中的 pool 10.169.103.58 iburst 行，指定需要同步的 IPservice ntp startcrontab 方式：Windows 启用 NTP 服务端通过开始菜单，输入 regedit 命令后打开注册表设定画面，此时请一定备份注册表文件。修改以下选项的键值 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\ NtpServer 内的「Enabled」设定为 1，打开 NTP 服务器功能修改以下键值 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\Config\ AnnounceFlags 设定为 5, 该设定强制主机将它自身宣布为可靠的时间源，从而使用内置的互补金属氧化物半导体 (CMOS) 时钟。在 dos 命令行执行以下命令，确保以上修改起作用net stop w32timenet start w32timelinux 启动定时循环对时linux 下执行 crontab -e输入：*/1 * * * * /usr/sbin/ntpdate 192.168.255.55 &gt; /var/log/cron 2&gt;&amp;1注： 2&gt;&amp;1 表示将错误信息也打印至文件执行 crontab -l 查看是否设置成功service cron restart 重启服务ps -A|grep cron 查看进程tail /var/log/cron 查看对时结果apt install sysv-rc-conf 安装服务管理工具关闭 ntp 服务]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改 CapsLock 为 Ctrl]]></title>
    <url>%2F2017%2F11%2F30%2Fmac-win-switch-Caps-Ctrl.html</url>
    <content type="text"><![CDATA[CapsLock 比 Ctrl 容易按，修改一下还是挺方便的MAC选取苹果菜单 &gt;“系统偏好设置”，然后点按“键盘”。点按“修饰键”按钮。从想要更改的修饰键旁边的弹出式菜单中选取一项操作，然后点按“好”。Win7点击 Win+R 键在输入框键入 regedit，打开注册表进入 HKEY_LOCAL_MACHINE -&gt; System -&gt; CurrentControlSet -&gt; Control -&gt; KeyBoard Layout。记住，一定是 keyBoard Layout，而不是 KeyBoard Layouts右键菜单，然后选择 New -&gt; Binary value重命名 New Value #1 -&gt; Scancode Map右键菜单 Scancode Map -&gt; Modify输入如下值，保存0000 00 00 00 00 00 00 00 000008 03 00 00 00 1D 00 3A 000010 3A 00 1D 00 00 00 00 000018前两行和最后一行，都是固定的，全部为 0。第三行，表示你修改了几个键，其实我们只是改了两个键，不过最后那一行也要算进去，所以是 3。重点是在第四行和第五行。3A00，代表 Caps Lock， 1D00，代表 Ctrl。这一行，意思即为，将 Caps Lock 映射为 Ctrl第五行，就不用说了，意思刚好相反。修改完毕后，重新登录 Windows 即可生效！下面附上各个键位值的参考：12345678910111213141516171819202122Escape 01 00Tab 0F 00Caps Lock 3A 00Left Alt 38 00Left Ctrl 1D 00Left Shift 2A 00Left Windows 5B E0Right Alt 38 E0Right Ctr l1D E0Right Shift 36 00Right Windows 5C E0Backspace 0E 00Delete 53 E0Enter 1C 00Space 39 00Insert 52 E0HOME 47 E0End 4F E0Num Lock 45 00Page Down 51 E0Page Up 49 E0Scroll Lock 46 00]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双向链表]]></title>
    <url>%2F2017%2F11%2F30%2Fdouble-linked-list.html</url>
    <content type="text"><![CDATA[OJ 常用数据结构备份双向链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;stdio.h&gt;#define prefetch(X) X#define offset_of(type, member) ((size_t)&amp;((type *)0)-&gt;member)#define container_of(ptr, type, member) ((type *)((unsigned char *)ptr - offset_of(type,member)))/* XXX list 结构体定义 */struct list_head &#123; struct list_head *next, *prev;&#125;;#define LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;/* XXX 局部、全局 list 初始化接口 */#define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)/* XXX 初始化已经存在的 list 头节点对象 */static inline void INIT_LIST_HEAD(struct list_head *list)&#123; list-&gt;next = list; list-&gt;prev = list;&#125;/* 插入元素的内部实现 */static inline void __list_add(struct list_head *nnew, struct list_head *prev, struct list_head *next)&#123; next-&gt;prev = nnew; nnew-&gt;next = next; nnew-&gt;prev = prev; prev-&gt;next =nnew;&#125;/* XXX 将元素插入链表头部 */static inline void list_add(struct list_head *nnew, struct list_head *head)&#123; __list_add(nnew, head, head-&gt;next);&#125;/* XXX 将元素插入链表尾部 */static inline void list_add_tail(struct list_head *nnew, struct list_head *head)&#123; __list_add(nnew, head-&gt;prev, head);&#125;/* 删除元素的内部实现 */static inline void __list_del(struct list_head * prev, struct list_head * next)&#123; next-&gt;prev = prev; prev-&gt;next = next;&#125;/* XXX 删除指定元素 */static inline void list_del(struct list_head *entry)&#123; __list_del(entry-&gt;prev, entry-&gt;next);&#125;/* XXX 判断该节点是否为尾节点 */static inline int list_is_last(const struct list_head *list, const struct list_head *head)&#123; return list-&gt;next == head;&#125;/* XXX 判断链表是否为空，仅检查后向指针 */static inline int list_empty(const struct list_head *head)&#123; return head-&gt;next == head;&#125;/* XXX 判断链表中是否仅有一个元素 */static inline int list_is_singular(const struct list_head *head)&#123; return !list_empty(head) &amp;&amp; (head-&gt;next == head-&gt;prev);&#125;#define list_entry(ptr, type, member) container_of(ptr, type, member)#define list_first_entry(ptr, type, member) list_entry((ptr)-&gt;next, type, member)#define list_last_entry(ptr, type, member) list_entry((ptr)-&gt;prev, type, member)#define list_for_each_entry(type_pos, pos, head, member) \ for (pos = list_entry((head)-&gt;next, type_pos, member); \ &amp;pos-&gt;member != (head); \ pos = list_entry(pos-&gt;member.next, type_pos, member))#define list_for_each_entry_safe(type_pos, pos, ptr, head, member) \ for (pos = list_entry((head)-&gt;next, type_pos, member), \ ptr = list_entry(pos-&gt;member.next, type_pos, member); \ &amp;pos-&gt;member != (head); \ pos = ptr, ptr = list_entry(ptr-&gt;member.next, type_pos, member))#define list_for_each_entry_reverse(type_pos, pos, head, member) \ for (pos = list_entry((head)-&gt;prev, type_pos, member); \ &amp;pos-&gt;member != (head); \ pos = list_entry(pos-&gt;member.prev, type_pos, member))#define list_for_each_entry_safe_reverse(type_pos, pos, n, head, member) \ for (pos = list_entry((head)-&gt;prev, type_pos, member), \ n = list_entry(pos-&gt;member.prev, type_pos, member); \ &amp;pos-&gt;member != (head); \ pos = n, n = list_entry(n-&gt;member.prev, type_pos, member))/* 示例 */#include &lt;stdlib.h&gt;typedef struct _list_demo_t&#123; int value; struct list_head node;&#125; list_demo_t;int main()&#123; LIST_HEAD (local_list); printf("list_empty [%d]\n", list_empty(&amp;local_list)); list_demo_t* list_node_1 = (list_demo_t*)malloc(sizeof(list_demo_t)); list_node_1-&gt;value = 1; list_demo_t* list_node_2 = (list_demo_t*)malloc(sizeof(list_demo_t)); list_node_2-&gt;value = 2; list_demo_t* list_node_3 = (list_demo_t*)malloc(sizeof(list_demo_t)); list_node_3-&gt;value = 3; list_demo_t* list_node_4 = (list_demo_t*)malloc(sizeof(list_demo_t)); list_node_4-&gt;value = 4; list_demo_t* list_node_5 = (list_demo_t*)malloc(sizeof(list_demo_t)); list_node_5-&gt;value = 5; list_demo_t* list_node_6 = (list_demo_t*)malloc(sizeof(list_demo_t)); list_node_6-&gt;value = 6; list_add(&amp;list_node_1-&gt;node, &amp;local_list); list_add(&amp;list_node_2-&gt;node, &amp;local_list); list_add(&amp;list_node_3-&gt;node, &amp;local_list); list_add_tail(&amp;list_node_4-&gt;node, &amp;local_list); list_add_tail(&amp;list_node_5-&gt;node, &amp;local_list); list_add_tail(&amp;list_node_6-&gt;node, &amp;local_list); printf("list_empty [%d]\n", list_empty(&amp;local_list)); list_demo_t* tmp; list_demo_t* for_safe; printf("list_for_each_entry\n"); list_for_each_entry(list_demo_t, tmp, &amp;local_list, node) &#123; printf("[%d]\n", tmp-&gt;value); &#125; printf("list_first_entry [%d]\n", list_first_entry(&amp;local_list, list_demo_t, node)-&gt;value); list_del(&amp;list_first_entry(&amp;local_list, list_demo_t, node)-&gt;node); printf("list_first_entry [%d]\n", list_first_entry(&amp;local_list, list_demo_t, node)-&gt;value); printf("list_last_entry [%d]\n", list_last_entry(&amp;local_list, list_demo_t, node)-&gt;value); list_del(&amp;list_last_entry(&amp;local_list, list_demo_t, node)-&gt;node); printf("list_last_entry [%d]\n", list_last_entry(&amp;local_list, list_demo_t, node)-&gt;value); printf("list_for_each_entry_safe\n"); list_for_each_entry_safe(list_demo_t, tmp, for_safe, &amp;local_list, node) &#123; printf("[%d]\n", tmp-&gt;value); &#125; printf("list_for_each_entry_safe_reverse\n"); list_for_each_entry_safe_reverse(list_demo_t, tmp, for_safe, &amp;local_list, node) &#123; list_del(&amp;tmp-&gt;node); printf("[%d]\n", tmp-&gt;value); free(tmp); &#125; printf("list_for_each_entry_reverse\n"); list_for_each_entry_reverse(list_demo_t, tmp, &amp;local_list, node) &#123; printf("[%d]\n", tmp-&gt;value); &#125;&#125;]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c 语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2017%2F11%2F30%2Flinked-list.html</url>
    <content type="text"><![CDATA[OJ 常用数据结构备份单向链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616#include "stdafx.h"#include "stdio.h"#include "stdlib.h"#include "string.h"typedef int elemType;struct Node&#123; elemType element; Node *next;&#125;;// 1. 初始化线性表，即置单链表的表头指针为空void initList(Node *pNode)&#123; pNode = NULL; printf("initList 函数执行，初始化成功、n");&#125;//2. 创建线性表，此函数输入负数终止读取数据Node *createList()&#123; Node *p1,*p2,*pNode; p1=p2=pNode=(Node *)malloc(sizeof(Node)); memset(p1,0,sizeof(Node)); scanf("%d",&amp;p1-&gt;element); p1-&gt;next = NULL; // while(p1-&gt;element &gt; 0) &#123; if(NULL == pNode) &#123; pNode = p1; &#125; else &#123; p2-&gt;next = p1; &#125; p2=p1; p1=(Node *)malloc(sizeof(Node)); memset(p1,0,sizeof(Node)); scanf("%d",&amp;p1-&gt;element); p1-&gt;next = NULL; // &#125; return pNode;&#125;//3. 打印链表，链表的遍历void printList(Node *pNode)&#123; if(NULL == pNode) &#123; printf("PrintList 函数执行，链表为空、n"); &#125; else &#123; while(NULL != pNode) &#123; printf("%d\t", pNode-&gt;element); pNode = pNode-&gt;next; &#125; &#125; printf("\n");&#125;// 4. 清除线性表 L 中的所有元素，即释放单链表 L 中所有的结点，使之成为一个空表int clearList(Node *pNode)&#123; Node *pNext; while(NULL != pNode) &#123; pNext = pNode-&gt;next; free(pNode); pNode = pNext; &#125; return 1; //printf("清空链表成功！\n");&#125;// 5. 返回单链表的长度int sizeList(Node *pNode)&#123; int i=0; while(NULL != pNode) &#123; i++; pNode = pNode-&gt;next; &#125; return i;&#125;// 6. 检查单链表是否为空，若为空则返回 1，否则返回 0int isEmptyList(Node *pHead)&#123; if(pHead == NULL) &#123; printf("isEmptyList 函数执行，链表为空、n"); return 1; &#125; printf("isEmptyList 函数执行，链表非空、n"); return 0;&#125;//7. 返回单链表中第 pos 个结点中的元素，若 pos 超出范围，则停止程序运行elemType getElement(Node *pNode,int pos)&#123; int i=0; if(pos &lt; 1) &#123; printf("getElement 函数执行，pos 值非法、n"); return 0; &#125; if(pNode == NULL) &#123; printf("getElement 函数执行，链表为空、n"); return 0; &#125; while(pNode!= NULL) &#123; i++; if(i == pos) return pNode-&gt;element; pNode = pNode-&gt;next; &#125; // 上面的 while 循环也可用 for 循环来代替 if(i &lt; pos) // 链表长度不足则退出 &#123; printf("getElement 函数执行，pos 值超出链表长度、n"); &#125; return 0;&#125;// 8. 从单链表中查找具有给定值 x 的第一个元素，若查找成功则返回该结点 data 域的存储地址，否则返回 NULLelemType *getElemAddr(Node *pNode,elemType elemValue)&#123; if(elemValue &lt;= 0) &#123; printf("getElemAddr 函数执行，给定值不合法、n"); return NULL; &#125; if(pNode == NULL) &#123; printf("getElemAddr 函数执行，链表为空、n"); return NULL; &#125; while(pNode!= NULL) &#123; if(pNode-&gt;element == elemValue) &#123; printf("getElemAddr 函数执行，元素 %d 的地址为 0x%x\n",elemValue,&amp;(pNode-&gt;element)); return &amp;(pNode-&gt;element); // 如果不直接 return 的话，一定记得用 break 跳出循环 &#125; pNode = pNode-&gt;next; &#125; printf("getElemAddr 函数执行，在链表中未找到 %d 值、n",elemValue); return NULL;&#125;//9. 把单链表中第 pos 个结点的值修改为 elemValue 的值，若修改成功返回 1，否则返回 0int modifyElem(Node *pNode,int pos, elemType elemValue)&#123; printf("modifyElem 函数执行，即将把链表的第 %d 个元素的值改为 %d\n",pos,elemValue); if(NULL == pNode) &#123; printf("modifyElem 函数执行，链表为空、n"); &#125; if(pos &lt; 1) &#123; printf("modifyElem 函数执行，pos 值非法、n"); return 0; &#125; if(elemValue &lt; 1) &#123; printf("modifyElem 函数执行，elemValue 值非法、n"); return 0; &#125; int i=0; while(pNode != NULL) &#123; i++; if(i == pos) &#123; pNode-&gt;element = elemValue; return 1; &#125; pNode = pNode-&gt;next; &#125; if(i &lt; pos) // 链表长度不足则退出 &#123; printf("modifyElem 函数执行，pos 值超出链表长度、n"); return 0; &#125; return 0;&#125;//10. 向单链表的表头插入一个元素int insertHeadList(Node **pNode,elemType elemInserted)&#123; if(NULL == *pNode) &#123; printf("insertHeadList 函数执行，链表为空、n"); return 0; &#125; if(elemInserted &lt; 1) &#123; printf("insertHeadList 函数执行，elemInserted 值非法、n"); return 0; &#125; Node *pHead,*pLast; pLast = *pNode; pHead = (Node *)malloc(sizeof(Node)); memset(pHead,0,sizeof(Node)); pHead-&gt;element = elemInserted; pHead-&gt;next = pLast; *pNode = pHead; return 1;&#125;// 11. 向单链表的末尾添加一个元素int insertLastList(Node **pNode,elemType elemInserted)&#123; if(NULL == *pNode) &#123; printf("insertLastList 函数执行，链表为空、n"); return 0; &#125; if(elemInserted &lt; 1) &#123; printf("insertLastList 函数执行，elemInserted 值非法、n"); return 0; &#125; Node *pLast,*pTemp; pTemp = *pNode; // 把*pNode 先赋值给 pTemp，后面的操作（例如循环链表到最后一个节点）主要是对 pTemp 进行操作，否则返回*pNode 的时候，将返回链表*pNode 在当前指针后面的部分，而不是整个链表。 // 因为 pTemp 与*pNode 指向同一个链表，所以对 pTemp 进行节点改动即是对*pNode 作改动 pLast = (Node *)malloc(sizeof(Node)); memset(pLast,0,sizeof(Node)); pLast-&gt;element = elemInserted; pLast-&gt;next = NULL; // 循环链表至最后一个节点 while(pTemp-&gt;next != NULL) &#123; pTemp = pTemp-&gt;next; &#125; // 把新增节点加入到链表中 pTemp-&gt;next = pLast; return 1;&#125;//12. 向单链表中第 pos 个结点位置插入元素为 x 的结点，若插入成功返回 1，否则返回 0int insertList(Node **pNode, int pos, elemType elemInserted)&#123; if(NULL == *pNode) &#123; printf("insertList 函数执行，链表为空、n"); return 0; &#125; if(elemInserted &lt; 1) &#123; printf("insertList 函数执行，elemInserted 值非法、n"); return 0; &#125; if(pos &lt; 1) &#123; printf("insertList 函数执行，pos 值非法、n"); return 0; &#125; Node *pInserted,*pTemp, *pLast; pTemp = *pNode; // 把*pNode 先赋值给 pTemp，后面的操作（例如循环链表到最后一个节点）主要是对 pTemp 进行操作，否则返回*pNode 的时候，将返回链表*pNode 在当前指针后面的部分，而不是整个链表。 // 因为 pTemp 与*pNode 指向同一个链表，所以对 pTemp 进行节点改动即是对*pNode 作改动 pInserted = (Node *)malloc(sizeof(Node)); memset(pInserted,0,sizeof(Node)); pInserted-&gt;element = elemInserted; pInserted-&gt;next = NULL; // 先赋值为 null // 循环链表至 pos 节点 int i = 0; while(pTemp-&gt;next != NULL) &#123; i = i + 1; if(i == pos) &#123; pLast-&gt;next = pInserted; // 让上一个节点的 next 指向插入节点 pInserted-&gt;next = pTemp; // 让插入节点的 next 指向下一节点 break; &#125; pLast = pTemp; // 记住上一个节点的位置 pTemp = pTemp-&gt;next; &#125; return 1;&#125;//13. 从单链表中删除表头结点，并把该结点的值返回，若删除失败则停止程序运行int deleteHeadList(Node **pNode)&#123; int currVal; Node *pTemp; if(NULL == *pNode) &#123; printf("DeleteHeadList 函数执行，链表为空、n"); return 0; &#125; pTemp = *pNode; currVal = (*pNode)-&gt;element; *pNode = (*pNode)-&gt;next; pTemp-&gt;next = NULL; // 将头节点的 next 指针置为 NULL free(pTemp); return currVal;&#125;//14. 从单链表中删除表尾结点并返回它的值，若删除失败则停止程序运行int deleteLastList(Node **pNode)&#123; int currVal; Node *pTemp,*pLast; if(NULL == *pNode) &#123; printf("DeleteLastList 函数执行，链表为空、n"); return 0; &#125; pTemp = *pNode; while(pTemp-&gt;next != NULL) &#123; pLast = pTemp; pTemp = pTemp-&gt;next; &#125; pLast-&gt;next = NULL; currVal = pTemp-&gt;element; free(pTemp); return currVal;&#125;//15. 从单链表中删除第 pos 个结点并返回它的值，若删除失败则停止程序运行int deleteList(Node **pNode, int pos)&#123; int currVal, i; Node *pTemp,*pLast,*pNext; if(NULL == *pNode) &#123; printf("DeleteLastList 函数执行，链表为空、n"); return 0; &#125; if(pos &lt; 1) &#123; printf("DeleteList 函数执行，pos 值非法、n"); return 0; &#125; pTemp = *pNode; i = 0; while(pTemp != NULL) &#123; i = i + 1; if(i == pos) &#123; break; &#125; pLast = pTemp; pTemp = pTemp-&gt;next; &#125; pNext = pTemp; pNext = pNext-&gt;next; pLast-&gt;next = pNext; currVal = pTemp-&gt;element; free(pTemp); return currVal;&#125;//16. 从单链表中删除值为 x 的第一个结点，若删除成功则返回 1, 否则返回 0int deleteXList(Node **pNode, elemType elemVal)&#123; Node *pTemp,*pLast,*pNext; if(NULL == *pNode) &#123; printf("DeleteXList 函数执行，链表为空、n"); return 0; &#125; if(elemVal &lt; 1) &#123; printf("DeleteXList 函数执行，elemVal 值非法、n"); return 0; &#125; pTemp = *pNode; int i = 0; while(pTemp != NULL) &#123; if(pTemp-&gt;element == elemVal) &#123; i = 1; break; &#125; pLast = pTemp; pTemp = pTemp-&gt;next; &#125; if(i == 0) &#123; printf("DeleteXList 函数执行，链表中没有值为 %d 的节点、n",elemVal); return 0; &#125; pNext = pTemp; pNext = pNext-&gt;next; pLast-&gt;next = pNext; free(pTemp); return 1;&#125;//17. 交换 2 个元素的位置int exchangeList(Node **pNode, int pos1, int pos2)&#123; if(NULL == *pNode) &#123; printf("exchangeList 函数执行，链表为空、n"); return 0; &#125; if(pos1 &lt; 1 || pos2 &lt; 1) &#123; printf("exchangeList 函数执行，pos 值非法、n"); return 0; &#125; Node *pTemp, *pFirst, *pSecond; pTemp = *pNode; int i = 0; while(pTemp != NULL) &#123; i++; if(i == pos1) pFirst = pTemp; else if(i == pos2) pSecond = pTemp; pTemp = pTemp-&gt;next; &#125; int p; p = pFirst-&gt;element; pFirst-&gt;element = pSecond-&gt;element; pSecond-&gt;element = p;&#125;//18. 将单链表进行排序int sortList(Node **pNode)&#123; if(NULL == *pNode) &#123; printf("sortList 函数执行，链表为空、n"); return 0; &#125; Node *pTemp; pTemp = *pNode; int Listsize = sizeList(*pNode); // 循环：用 for 循环来取代指针循环，因为指针循环一次后，下次起始的指针将自动转到下一节点，而我们还想从第一个元素开始 for(int i=0; i &lt; Listsize; i++) &#123; Node *pCurr, *pLast; pCurr = pLast = pTemp; for(int k=0; k &lt; Listsize-i; k++) &#123; int p = 0; if(pLast-&gt;element &lt; pCurr-&gt;element) &#123; p = pLast-&gt;element; pLast-&gt;element = pCurr-&gt;element; pCurr-&gt;element = p; &#125; pLast = pCurr; pCurr = pCurr-&gt;next; &#125; &#125;&#125;//19. 向有序单链表中插入元素 x 结点，使得插入后仍然有序 , 假设现在已知一个升序的单链表int insertXList(Node **pNode, elemType elemInserted)&#123; if(NULL == *pNode) &#123; printf("insertList 函数执行，链表为空、n"); return 0; &#125; if(elemInserted &lt; 1) &#123; printf("insertList 函数执行，elemInserted 值非法、n"); return 0; &#125; Node *pInserted,*pTemp, *pLast; pTemp = *pNode; // 把*pNode 先赋值给 pTemp，后面的操作（例如循环链表到最后一个节点）主要是对 pTemp 进行操作，否则返回*pNode 的时候，将返回链表*pNode 在当前指针后面的部分，而不是整个链表。 // 因为 pTemp 与*pNode 指向同一个链表，所以对 pTemp 进行节点改动即是对*pNode 作改动 pInserted = (Node *)malloc(sizeof(Node)); memset(pInserted,0,sizeof(Node)); pInserted-&gt;element = elemInserted; pInserted-&gt;next = NULL; // 先赋值为 null // 寻找该插入的节点 while(pTemp-&gt;next != NULL) &#123; if(pTemp-&gt;element &gt; elemInserted) &#123; pLast-&gt;next = pInserted; // 让上一个节点的 next 指向插入节点，注意：如果该节点是第一节点，没有上一个节点呢？ pInserted-&gt;next = pTemp; // 让插入节点的 next 指向下一节点 break; &#125; pLast = pTemp; // 记住上一个节点的位置 pTemp = pTemp-&gt;next; &#125; return 1;&#125;void main()&#123; Node *pList=NULL; int length = 0; initList(pList); // 链表初始化 printList(pList); // 遍历链表，打印链表 pList=createList(); // 创建链表 printList(pList); sizeList(pList); // 链表的长度 isEmptyList(pList); // 判断链表是否为空链表 elemType posElem; posElem = getElement(pList,3); // 获取第三个元素，如果元素不足 3 个，则返回 0 printf("getElement 函数执行，位置 3 中的元素为 %d\n",posElem); printList(pList); getElemAddr(pList,5); // 获得元素 5 的地址 modifyElem(pList,4,1); // 将链表中位置 4 上的元素修改为 1 printList(pList); insertHeadList(&amp;pList,12); // 表头插入元素 12 printList(pList); insertLastList(&amp;pList,10); // 表尾插入元素 10 printList(pList); insertList(&amp;pList,2,11); // 第 2 个节点插入元素 11 printList(pList); deleteHeadList(&amp;pList); // 删除表头节点 printList(pList); deleteLastList(&amp;pList); // 删除表尾节点 printList(pList); deleteList(&amp;pList,2); // 删除第 2 个节点 printList(pList); deleteXList(&amp;pList,3); // 删除值为 3 的第一个节点 printList(pList); exchangeList(&amp;pList,2,3); // 第 2 个节点与第 3 个节点的值进行交换 printList(pList); sortList(&amp;pList); // 对单链表进行冒泡排序 printList(pList); insertXList(&amp;pList,11); // 向有序链表中插入一个元素 11，使得插入后的链表仍然有序 printList(pList); clearList(pList); // 清空链表 //system("pause");&#125;]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c 语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2017%2F11%2F30%2Fbinary-search.html</url>
    <content type="text"><![CDATA[做 oj 时的常用函数二分查找```cint bin_find(int* nums, int numsSize, int target) {int hi = numsSize - 1;int low = 0;int mid;while (hi &gt;= low) {mid = low + (hi - low) / 2;if (target == nums[mid]) {return mid;}else if (target &gt; nums[mid]) {low = mid + 1;}else {hi = mid - 1;}}return -1;}]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c 语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tensorboard]]></title>
    <url>%2F2017%2F11%2F29%2Ftensorboard.html</url>
    <content type="text"><![CDATA[Tensorboard 非常常用，但是经常临时忘记如何使用，所以自己总结一遍最简 Dome以下四行代码就可以在 tensorboard 中显示 Graphs 了，尽管只有一个节点123456$ ipythonIn [1]: import tensorflow as tfIn [2]: x_data = tf.placeholder(tf.float32) # Graph 中唯一的节点In [3]: sess = tf.Session() # 创建 sessionIn [4]: tf.summary.FileWriter('/tmp/my_test/', sess.graph) # 将信息写入指定目录Out[4]: &lt;tensorflow.python.summary.writer.writer.FileWriter at 0x7f3e60027320&gt;然后执行 tensorboard --logdir=/tmp/my_test/，如果没有报错就可以在浏览器中通过 http://localhost:6006/ 查看效果了正常一些的 Demo计算图只有一个点实在说不过去，MNIST 的计算图我也觉得太复杂，那么一元一次方程就最合适了123456789101112131415161718$ ipython3In [1]: load /Users/jiexiao/workspace/tmp2.pyIn [2]: # %load /Users/jiexiao/workspace/tmp2.py ...: import tensorflow as tf ...: ...: # 定义计算图 ...: in_x = tf.placeholder(tf.float32) # 输入 ...: in_y = tf.placeholder(tf.float32) # 输出 ...: W = tf.Variable(tf.random_uniform([1], -200.0, 200.0)) # 待求的斜率 ...: b = tf.Variable(tf.zeros([1])) # 待求的偏置 ...: y = W * in_x + b # 一元一次方程 ...: loss = tf.reduce_mean(tf.square(y - in_y)) # 模型根据 in_x 计算出的 y 真实的输出 in_y 的差值 ...: optimizer = tf.train.GradientDescentOptimizer(0.7) # 选择优化函数 ...: train = optimizer.minimize(loss) # 梯度下降，使 W 和 b 不断逼近真实值 ...: ...: # 保存可视化信息 ...: sess = tf.Session() ...: writer = tf.summary.FileWriter('/tmp/my_test/', sess.graph)下面的结果看起来就好多啦优化标签显示可以看到 Graph 中的节点名字都是都是 Variable_1 这样的，为了更好的可读性，我们在之前代码的基础上添加 tf.name_scope 和 name 参数1234567891011121314151617181920212223242526272829$ ipython3In [1]: load /Users/jiexiao/workspace/tmp2.pyIn [2]: # %load /Users/jiexiao/workspace/tmp2.py ...: import tensorflow as tf ...: ...: # 定义计算图 ...: in_x = tf.placeholder(tf.float32, name='in_x') # 为单个 tensor 命名 ...: ...: in_y = tf.placeholder(tf.float32, name='in_y') ...: ...: with tf.name_scope('W'): # 将多个 tensor 组合成一个 scope 然后命名 ...: W = tf.Variable(tf.random_uniform([1], -200.0, 200.0)) ...: ...: with tf.name_scope('b'): ...: b = tf.Variable(tf.zeros([1])) ...: ...: with tf.name_scope('y'): ...: y = W * in_x + b ...: ...: with tf.name_scope('loss'): ...: loss = tf.reduce_mean(tf.square(y - in_y)) ...: ...: optimizer = tf.train.GradientDescentOptimizer(0.7) ...: with tf.name_scope('train'): ...: train = optimizer.minimize(loss) ...: ...: # 保存可视化信息 ...: sess = tf.Session() ...: writer = tf.summary.FileWriter('/tmp/my_test/', sess.graph)这样看起来就非常棒了动起来只有计算图，是不能训练的，我们需要定义一个循环，让计算图 run 起来，另外，我们还需要训练数据，训练一元一次方程需要的数据我们很容易构建出来各种图tf.summary.scalartf.summary.histogramtf.summary.imagetf.summary.audiotf.summary.text参考tensorflow 第一个简单案例]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Trick]]></title>
    <url>%2F2017%2F11%2F29%2Fpython-trick.html</url>
    <content type="text"><![CDATA[python 语法糖等等杂项查看 python 版本信息在未进行 Python Shell 之前：1python –version进入 Python Shell 之后，有两种方法12help()import sys sys.versionpip 安装超时12345678$ cat &gt; ~/.pip/pip.conf[global]timeout = 6000index-url = http://pypi.douban.com/simple/[install]use-mirrors = truemirrors = http://pypi.douban.com/simple/trusted-host = pypi.douban.compython 判断是否可迭代123$ ipythonIn [1]: [x for x in [None, '123', '456', 6] if hasattr(x, '__iter__')]Out[1]: ['123', '456']python list 降维123$ ipythonIn [1]: sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [])Out[1]: [1, 2, 3, 4, 5, 6, 7, 8, 9]numpy 打印完整数组12import numpy as npnp.set_printoptions(threshold=np.nan)查看历史命令1vi ~/.python_history]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 常用三方库]]></title>
    <url>%2F2017%2F11%2F28%2Fpython-common.html</url>
    <content type="text"><![CDATA[方便查询tqdm功能进度条描述1234567891011121314151617181920212223__init__(self, iterable=None, # 进度条跟踪控的迭代器 desc=None, total=None, # 有些 iter 无法获取完整长度，需要自行计算 leave=True, file=None, ncols=None, mininterval=0.1, maxinterval=10.0, miniters=None, ascii=None, disable=False, unit='it', unit_scale=False, dynamic_ncols=False, smoothing=0.3, bar_format=None, initial=0, position=None, postfix=None, unit_divisor=1000, gui=False, **kwargs)示例1234567891011121314$ ipythonIn [1]: from time import sleepIn [2]: from tqdm import tqdmIn [3]: for i in tqdm(range(10)): # 基本 Demo ...: sleep(1)100%|#####################################################| 10/10 [00:07&lt;00:00, 1.28it/s]In [5]: import osIn [6]: for x in tqdm(os.walk('/tmp/my_test/')): # os.walk 返回的生成器无法直接获取长度，所以进度条没有完成率 ...: sleep(1)5it [00:05, 1.00s/it]In [7]: count = len([x for x in os.walk('/tmp/my_test/')])In [8]: for x in tqdm(os.walk('/tmp/my_test/'), total=count): # 先计算 os.walk 长度，然后传入 total ...: sleep(1)100%|#####################################################| 5/5 [00:02&lt;00:00, 1.58it/s]multiprocessing.Pool / multiprocessing.dummy.Pool12multiprocessing.Pool(processes=None, initializer=None, initargs=(), maxtasksperchild=None)multiprocessing.dummy.Pool(processes=None, initializer=None, initargs=())map功能并行处理计算密集型任务使用多进程，IO 密集型任务使用多线程描述1map(func, iterable, chunksize=None)示例12345678910111213141516171819$ ipythonIn [1]: %cpastePasting code; enter '--' alone on the line to stop or use Ctrl-D.:def fib(n): if n&lt;= 2: return 1 return fib(n-1) + fib(n-2)::::--In [2]: import timeIn [3]: from multiprocessing import PoolIn [4]: pool = Pool(2)In [5]: %time pool.map(fib, [35] * 2)CPU times: user 8 ms, sys: 0 ns, total: 8 msWall time: 4.02 s # 使用多进程明显提升了效率Out[5]: [9227465, 9227465]In [6]: %time [x for x in map(fib, [35] * 2)]CPU times: user 7.71 s, sys: 4 ms, total: 7.72 sWall time: 7.7 s # 不使用多进程的情况Out[6]: [9227465, 9227465]理解 Python 并发编程一篇就够了 - 进程篇Python 多核并行计算imap / imap_unordered功能监控并行处理的进度描述12imap(func, iterable, chunksize=1)可能会比 map 慢很多示例1234567891011121314$ ipythonIn [1]: from tqdm import tqdmIn [2]: from multiprocessing import PoolIn [3]: def fib(n): ...: if n &lt;= 2: ...: return 1 ...: return fib(n - 1) + fib(n - 2)In [4]: it = [35] * 6In [5]: tmp = tqdm(total=len(it)) 0%| | 0/6 [00:00&lt;?, ?it/s]In [6]: pool = Pool(3)In [7]: for _ in pool.imap_unordered(fib, it): ...: tmp.update()100%|################################################################| 6/6 [00:36&lt;00:00, 12.11s/it]性能对比如下，通常可以接受：12345678910111213141516171819202122232425$ ipythonIn [1]: from multiprocessing import PoolIn [2]: def fib(n): ...: if n &lt;= 2: ...: return 1 ...: return fib(n - 1) + fib(n - 2)In [3]: it = [5] * 10000In [4]: pool = Pool(3)In [5]: def test(): ...: for _ in pool.imap_unordered(fib, it): ...: tmp = _In [6]: def test1(): ...: pool.map(fib, it)In [7]: %time test()CPU times: user 904 ms, sys: 388 ms, total: 1.29 sWall time: 1.05 sIn [8]: %time test1()CPU times: user 4 ms, sys: 4 ms, total: 8 msWall time: 14 msIn [9]: %time test()CPU times: user 1.84 s, sys: 472 ms, total: 2.31 sWall time: 10.8 sIn [10]: %time test1()CPU times: user 12 ms, sys: 0 ns, total: 12 msWall time: 9.75 s]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pandas 使用总结]]></title>
    <url>%2F2017%2F11%2F28%2Fpython-pandas.html</url>
    <content type="text"><![CDATA[pandas 使用整理pandas.DataFrame功能初始化一个 DataFrame 对象描述示例1234567In [1]: import pandas as pdIn [2]: df = pd.DataFrame([['file1', 'path1', 'type1'], ['file2', 'path2', 'type2']], columns=['filename', 'filepath', 'filetype'])In [3]: dfOut[3]: filename filepath filetype0 file1 path1 type11 file2 path2 type2pandas.DataFrame.to_excel功能生成 excel 文件描述示例123456789$ ipythonIn [1]: import pandas as pdIn [2]: df = pd.DataFrame([['file1', 'path1', 'type1'], ['file2', 'path2', 'type2']], columns=['filename', 'filepath', 'filetype'])In [3]: dfOut[3]: filename filepath filetype0 file1 path1 type11 file2 path2 type2In [4]: df.to_excel('foo.xlsx', sheet_name='Sheet1')]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 文件操作相关函数]]></title>
    <url>%2F2017%2F11%2F28%2Fpython-file-op.html</url>
    <content type="text"><![CDATA[方便查询chardet.detect功能检测编码格式描述1detect(byte_str)示例123456789101112131415161718192021$ ipythonIn [1]: import chardetIn [2]: with open('/tmp/my_test/006.tc', 'rb') as f: # 查询编码 ...: encode = chardet.detect(f.read())In [3]: with open('/tmp/my_test/006.tc', encoding=encode['encoding']) as f: ...: tmp = f.read()In [4]: with open('/tmp/my_test/006.tc') as f: # 直接 open 会出现编码问题 ...: tmp = f.read()---------------------------------------------------------------------------UnicodeDecodeError Traceback (most recent call last)&lt;ipython-input-4-fc8ced863c36&gt; in &lt;module&gt;() 1 with open('/tmp/my_test/006.tc') as f:----&gt; 2 tmp = f.read() 3~/anaconda3/lib/python3.6/codecs.py in decode(self, input, final) 319 # decode input (taking the buffer into account) 320 data = self.buffer + input--&gt; 321 (result, consumed) = self._buffer_decode(data, self.errors, final) 322 # keep undecoded input until the next call 323 self.buffer = data[consumed:]UnicodeDecodeError: 'utf-8' codec can't decode byte 0xb0 in position 61: invalid start byteos.listdir功能非递归的返回子目录和子文件描述1listdir(path=None)示例1234$ ipythonIn [2]: import osIn [3]: [x for x in os.listdir(&apos;/tmp/my_test/&apos;)]Out[3]: [&apos;1.MSCP&apos;, &apos;2.VP&apos;, &apos;4.Scene&apos;, &apos;3.vPW&apos;]os.path.relpath功能获取相对路径描述1relpath(path, start=None)示例12345678$ ipythonIn [1]: pwdOut[1]: '/root'In [2]: import osIn [3]: os.path.relpath('/root/workspace/') # 默认相对当前路径Out[3]: 'workspace'In [4]: os.path.relpath('/root/workspace/', '/home/') # 可以指定起始路径Out[4]: '../root/workspace'os.path.splitext功能剥离文件名后缀描述1splitext(p)示例1234567$ ipythonIn [6]: os.path.splitext('/tmp/my_test/parser_result.txt')[-1]Out[6]: '.txt'In [7]: os.path.splitext('/tmp/my_test/parser_result.txt')Out[7]:('/tmp/my_test/parser_result', '.txt')os.walk功能递归的返回子目录和子文件描述1walk(top, topdown=True, onerror=None, followlinks=False)示例1234567891011121314# 遍历目录$ ipythonIn [1]: import osIn [2]: def print_dir(root_dir): ...: list_dirs = os.walk(root_dir) ...: for root, dirs, files in list_dirs: ...: for d in dirs: ...: print(os.path.join(root, d)) ...: for f in files: ...: print(os.path.join(root, f))In [3]: print_dir('/tmp/my_test')/tmp/my_test/1.MSCP/tmp/my_test/2.VP/tmp/my_test/4.Scene]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow API 整理]]></title>
    <url>%2F2017%2F11%2F25%2Ftensorflow-api.html</url>
    <content type="text"><![CDATA[Tensorflow API 整理，方便自己查阅tfBuilding GraphsDefining new operationstf.TensorShape功能表示某个 shape 的 TensorConstants, Sequences, and Random ValuesConstant Value Tensorstf.fill功能创建元素为同一标量的 Tensor描述12345678910111213fill( dims, value, name=None)Args:dims: A Tensor of type int32. 1-D. Represents the shape of the output tensor.value: A Tensor. 0-D (scalar). Value to fill the returned tensor.name: A name for the operation (optional).Returns:A Tensor. Has the same type as value.示例12345678$ ipythonIn [1]: import tensorflow as tfIn [2]: tmp = tf.fill([2, 3], 9)In [3]: with tf.Session().as_default(): ...: tmp.eval()Out[3]:array([[9, 9, 9], [9, 9, 9]], dtype=int32)Sequencestf.range功能构建 tensor 序列描述123456789101112range(limit, delta=1, dtype=None, name=&apos;range&apos;)range(start, limit, delta=1, dtype=None, name=&apos;range&apos;)Args:start: 序列的起点，默认为 0, 包含limit: 序列的终点，不包含delta: 增量，可以为负dtype: 元素类型name: A name for the operation. Defaults to &quot;range&quot;.Returns:An 1-D Tensor of type dtype.示例1234567$ ipython3In [1]: import tensorflow as tfIn [2]: with tf.Session(): ...: tf.range(5).eval() ...: tf.range(3, 1, -0.5).eval()Out[2]: array([0, 1, 2, 3, 4], dtype=int32)Out[2]: array([ 3. , 2.5, 2. , 1.5], dtype=float32)Control FlowDebugging OperationsTensorflow 之调试 (Debug) 及打印变量TensorFlow 打印 tensor 值tf.Print功能在 Graph 在 Evalue 的时候打印数据描述12345678910111213141516171819Print( input_, data, message=None, first_n=None, summarize=None, name=None)Args:input_: 打印的触发条件，即运算到该 tensor 时，打印变量data: 需要被打印的 tensor 的列表message: 消息前缀first_n: 一个 Session 中，如果多次对 input_ 执行 eval, 仅打印 first_n 次，默认 -1，即不限制summarize: 每个 tensor 仅显示前 N 个数据，默认为 3 个name: 操作名Returns:返回与 input_完全一样的 tensor 所以可以在 map 等函数中添加 tf.Print示例基础使用12345678910111213In [1]: import tensorflow as tfIn [2]: tmp1 = tf.range(5)In [3]: tmp2 = tf.constant(3)In [4]: tmp3 = tmp1 * tmp2In [5]: with tf.Session() as sess: ...: tmp3.eval()Out[5]: array([ 0, 3, 6, 9, 12], dtype=int32)In [6]: tmp1 = tf.Print(tmp1, [tmp1, tmp2])In [8]: tmp3 = tmp1 * tmp2In [9]: with tf.Session() as sess: ...: tmp3.eval()2017-12-29 15:41:37.697189: I tensorflow/core/kernels/logging_ops.cc:79] [0 1 2...][3] # 在 tmp3 执行 eval 时，tmp1 肯定也执行了 eval，所以同时打印了 tmp1/tmp2 的值Out[9]: array([ 0, 3, 6, 9, 12], dtype=int32)参数使用示例123456789101112131415161718192021In [1]: import tensorflow as tfIn [2]: tmp1 = tf.range(5)In [3]: tmp2 = tf.constant(3)In [4]: tmp1 = tf.Print(tmp1, [tmp1, tmp2], message='前缀', summarize=5)In [5]: tmp3 = tmp1 * tmp2In [6]: with tf.Session() as sess: ...: tmp3.eval() ...: tmp3.eval()2017-12-29 15:50:05.553299: I tensorflow/core/kernels/logging_ops.cc:79] 前缀 [0 1 2 3 4][3] # 注意 print 了两次，且将 tmp1 的 5 个元素都打印了，'前缀'与设置一直Out[6]: array([ 0, 3, 6, 9, 12], dtype=int32)2017-12-29 15:50:05.559873: I tensorflow/core/kernels/logging_ops.cc:79] 前缀 [0 1 2 3 4][3]Out[6]: array([ 0, 3, 6, 9, 12], dtype=int32)In [10]: tmp1 = tf.range(5)In [11]: tmp1 = tf.Print(tmp1, [tmp1, tmp2], message='前缀', summarize=5, first_n=1)In [12]: tmp3 = tmp1 * tmp2In [13]: with tf.Session() as sess: ...: tmp3.eval() ...: tmp3.eval()2017-12-29 15:50:56.213895: I tensorflow/core/kernels/logging_ops.cc:79] 前缀 [0 1 2 3 4][3] # 注意 Print 了一次Out[13]: array([ 0, 3, 6, 9, 12], dtype=int32)Out[13]: array([ 0, 3, 6, 9, 12], dtype=int32)通过 tf.Print 打印 Dataset 对象1234567891011121314151617181920In [1]: import tensorflow as tfIn [2]: tmp1 = tf.data.Dataset.range(5)In [3]: tmp1 = tmp1.map(lambda x: tf.Print(x, [x]))In [4]: tmp2 = tmp1.filter(lambda x: x &gt; 3)In [5]: def print_dataset(d): ...: d_iter = d.make_one_shot_iterator() ...: with tf.Session() as sess: ...: tf.tables_initializer().run() ...: while True: ...: try: ...: print(sess.run(d_iter.get_next())) ...: except tf.errors.OutOfRangeError: ...: breakIn [6]: print_dataset(tmp2)2017-12-29 17:54:52.859170: I tensorflow/core/kernels/logging_ops.cc:79] [0]2017-12-29 17:54:52.862444: I tensorflow/core/kernels/logging_ops.cc:79] [1]2017-12-29 17:54:52.862759: I tensorflow/core/kernels/logging_ops.cc:79] [2]2017-12-29 17:54:52.862956: I tensorflow/core/kernels/logging_ops.cc:79] [3]2017-12-29 17:54:52.863270: I tensorflow/core/kernels/logging_ops.cc:79] [4]4Logical Operatorstf.logical_and/tf.logical_or/tf.logical_xor/tf.logical_not功能逻辑运算符描述12345678910111213logical_and( x, y, name=None)Args:x: A Tensor of type bool.y: A Tensor of type bool.name: A name for the operation (optional).Returns:A Tensor of type bool.示例12345678910111213$ ipython3In [1]: import tensorflow as tfIn [2]: t1 = tf.constant([True, True, False, False])In [3]: t2 = tf.constant([False, True, False, True])In [4]: with tf.Session(): ...: tf.logical_and(t1, t2).eval() ...: tf.logical_or(t1, t2).eval() ...: tf.logical_xor(t1, t2).eval() ...: tf.logical_not(t1).eval()Out[4]: array([False, True, False, False], dtype=bool)Out[4]: array([ True, True, False, True], dtype=bool)Out[4]: array([ True, False, False, True], dtype=bool)Out[4]: array([False, False, True, True], dtype=bool)MathBasic Math Functionstf.maximum功能取 max…tf.minimum功能取 min…tf.round功能Rounds the values of a tensor to the nearest integer, element-wise.可以简单的理解为四舍五入描述1234567891011round( x, name=None)Args:x: A Tensor of type float32 or float64.name: A name for the operation (optional).Returns:A Tensor of same shape and type as x.示例123456$ ipythonIn [1]: import tensorflow as tfIn [2]: x = tf.constant([1.1, 1.5, 1.6, -1.1, -1.5, -1.6])In [3]: sess = tf.Session()In [4]: sess.run(tf.round(x))Out[4]: array([ 1., 2., 2., -1., -2., -2.], dtype=float32)Reductiontf.reduce_max功能根据指定维度，获取最大值描述1234567891011121314151617reduce_max( input_tensor, axis=None, keep_dims=False, name=None, reduction_indices=None)Args:input_tensor: The tensor to reduce. Should have numeric type.axis: The dimensions to reduce. If None (the default), reduces all dimensions. Must be in the range [-rank(input_tensor), rank(input_tensor)).keep_dims: If true, retains reduced dimensions with length 1.name: A name for the operation (optional).reduction_indices: The old (deprecated) name for axis.Returns:The reduced tensor.示例123456789101112131415$ ipythonIn [1]: import tensorflow as tfIn [2]: tmp = tf.reshape(tf.range(15), [3, -1])In [3]: sess = tf.Session()In [4]: sess.run(tmp)Out[4]:array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]], dtype=int32)In [5]: sess.run(tf.reduce_max(tmp))Out[5]: 14In [6]: sess.run(tf.reduce_max(tmp, 0))Out[6]: array([10, 11, 12, 13, 14], dtype=int32)In [7]: sess.run(tf.reduce_max(tmp, 1))Out[7]: array([ 4, 9, 14], dtype=int32)StringsSplittingtf.string_split功能Split elements of source based on delimiter into a SparseTensor描述12345678910111213string_split( source, delimiter=&apos; &apos;, skip_empty=True)Args:source: 1-D string Tensor, the strings to split.delimiter: 0-D string Tensor, the delimiter character, the string should be length 0 or 1.skip_empty: A bool. 默认值是 True 所以默认不会产生空子串Returns:A SparseTensor of rank 2, the strings split according to the delimiter. The first column of the indices corresponds to the row in source and the second column corresponds to the index of the split component in this row.示例123456789101112131415161718$ ipython3In [1]: load /Users/jiexiao/workspace/tmp.pyIn [2]: # %load /Users/jiexiao/workspace/tmp.py ...: ...: import tensorflow as tf ...: from tensorflow.python.data import Dataset ...: def print_dataset(d): ...: d_iter = d.make_one_shot_iterator() ...: with tf.Session() as sess: ...: while True: ...: try: ...: print(sess.run(d_iter.get_next())) ...: except tf.errors.OutOfRangeError: ...: breakIn [3]: tmp = Dataset.from_tensor_slices(['jie xiao', 'huawei'])In [4]: print_dataset(tmp.map(lambda x: tf.string_split([x]).values))[b'jie' b'xiao'][b'huawei']可以注意到 tf.string_split 函数的参数至少是 1D 的 tensor，另外，tf.string_split 的返回值必须取 value 才能作为 Dataset 的元素，这里给出另一个例子12345678910111213$ ipython3In [1]: import tensorflow as tfIn [2]: with tf.Session() as sess: ...: sess.run(tf.string_split(['jie xiao', 'hua wei', 'gong zuo san nian']))Out[2]:SparseTensorValue(indices=array([[0, 0], [0, 1], [1, 0], [1, 1], [2, 0], [2, 1], [2, 2], [2, 3]]), values=array([b'jie', b'xiao', b'hua', b'wei', b'gong', b'zuo', b'san', b'nian'], dtype=object), dense_shape=array([3, 4]))可以看出，返回的 SparseTensorValue 对象中， values 才是我们需要的内容。dense_shape 表示保存切分后元素的矩阵大小，我的输入有三个元素，切分后，三个元素分别为 2、2、4 个元素，所以最终至少需要 [3, 4] 大小的矩阵保存。 indices 表示 [3, 4] 中有效信息的索引，例如，[0, 0] 对应的是输入的第一个元素被切开后的第一个子串。Tensor TransformationsCastingtf.cast功能类型转换描述12345678910111213cast( x, dtype, name=None)Args:x: A Tensor or SparseTensor.dtype: The destination type.name: A name for the operation (optional).Returns:A Tensor or SparseTensor with same shape as x.示例12345678$ ipython3In [1]: import tensorflow as tfIn [2]: with tf.Session().as_default(): ...: tmp = tf.constant([1.1, 2.8], dtype=tf.float32) ...: tmp.eval() ...: tf.cast(tmp, tf.int32).eval()Out[2]: array([ 1.10000002, 2.79999995], dtype=float32)Out[2]: array([1, 2], dtype=int32)tf.to_int64功能目前的理解等同于 tf.cast(x, dtype=int64)Shapes and Shapingtf.reshape功能Reshape…描述12345678910111213reshape( tensor, shape, name=None)Args:tensor: A Tensor.shape: A Tensor. Must be one of the following types: int32, int64. Defines the shape of the output tensor.name: A name for the operation (optional).Returns:A Tensor. Has the same type as tensor示例123456789101112131415161718$ ipython3In [1]: import tensorflow as tfIn [2]: with tf.Session(): ...: tf.reshape(tf.range(12), [4, 3]).eval() ...: tf.reshape(tf.range(12), [4, -1]).eval() # -1 时自动计算 ...: tf.reshape(tf.range(1), []).eval() # 向量转标量 ...:Out[2]:array([[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11]], dtype=int32)Out[2]:array([[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11]], dtype=int32)Out[2]: 0tf.size功能获取 tensor 中元素个数描述12345678910111213size( input, name=None, out_type=tf.int32)Args:input: A Tensor or SparseTensor.name: A name for the operation (optional).out_type: (Optional) The specified output type of the operation (int32 or int64). Defaults to tf.int32.Returns:A Tensor of type out_type. Defaults to tf.int32.示例123456$ ipython3In [1]: import tensorflow as tfIn [2]: t = tf.constant([[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]])In [3]: with tf.Session() as sess: ...: tf.size(t).eval()Out[3]: 12Slicing and Joiningtf.concat功能按照某个维度连接 Tensor描述12345678910111213concat( values, axis, name=&apos;concat&apos;)Args:values: A list of Tensor objects or a single Tensor.axis: 0-D int32 Tensor. Dimension along which to concatenate. Must be in the range [-rank(values), rank(values)).name: A name for the operation (optional).Returns:A Tensor resulting from concatenation of the input tensors.示例123456789101112131415$ ipython3In [1]: import tensorflow as tfIn [2]: t1 = tf.reshape(tf.range(6), [2, 3]) # [[0, 1, 2], [3, 4, 5]]In [3]: t2 = tf.reshape(tf.range(6, 12), [2, 3]) # [[ 6, 7, 8], [ 9, 10, 11]]In [4]: with tf.Session().as_default(): ...: tf.concat([t1, t2], 0).eval() ...: tf.concat([t1, t2], 1).eval()Out[4]:array([[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11]], dtype=int32)Out[4]:array([[ 0, 1, 2, 6, 7, 8], [ 3, 4, 5, 9, 10, 11]], dtype=int32)tf.reverse功能翻转 tensor 的某个维度中的元素描述123456789reverse( tensor, axis, name=None)tensor: A Tensor. Must be one of the following types: uint8, int8, uint16, int16, int32, int64, bool, half, float32, float64, complex64, complex128, string. Up to 8-D.axis: A Tensor. Must be one of the following types: int32, int64. 1-D. The indices of the dimensions to reverse. Must be in the range [-rank(tensor), rank(tensor)).name: A name for the operation (optional).示例12345678910111213141516171819202122232425262728293031323334$ ipython3In [1]: import tensorflow as tfIn [2]: tmp = tf.reshape(tf.range(12), [1,2,2,3])In [3]: with tf.Session().as_default(): ...: tmp.eval() ...: tf.reverse(tmp, [1]).eval() ...: tf.reverse(tmp, [-1]).eval() ...: tf.reverse(tmp, [3]).eval() ...: tf.reverse(tmp, [1, 2]).eval()Out[3]:array([[[[ 0, 1, 2], [ 3, 4, 5]], [[ 6, 7, 8], [ 9, 10, 11]]]], dtype=int32)Out[3]:array([[[[ 6, 7, 8], [ 9, 10, 11]], [[ 0, 1, 2], [ 3, 4, 5]]]], dtype=int32)Out[3]:array([[[[ 2, 1, 0], [ 5, 4, 3]], [[ 8, 7, 6], [11, 10, 9]]]], dtype=int32)Out[3]:array([[[[ 2, 1, 0], [ 5, 4, 3]], [[ 8, 7, 6], [11, 10, 9]]]], dtype=int32)Out[3]:array([[[[ 9, 10, 11], [ 6, 7, 8]], [[ 3, 4, 5], [ 0, 1, 2]]]], dtype=int32)VariablesSharing Variablestf.random_uniform_initializer功能变量初始化的值符合均匀分布描述12345678910111213__init__( minval=0, maxval=None, seed=None, dtype=tf.float32)Args:minval: A python scalar or a scalar tensor. Lower bound of the range of random values to generate.maxval: A python scalar or a scalar tensor. Upper bound of the range of random values to generate. Defaults to 1 for float types.seed: A Python integer. Used to create random seeds. See tf.set_random_seed for behavior.dtype: The data type.示例123456789$ ipython3In [1]: import tensorflow as tfIn [2]: import matplotlib.pyplot as pltIn [3]: a1 = tf.get_variable(name=&apos;a1&apos;, shape=[2000], initializer=tf.random_uniform_initializer(-1, 1))In [4]: sess = tf.Session()In [5]: sess.run(tf.global_variables_initializer())In [6]: tmp = sess.run(a1)In [7]: plt.hist(tmp, 100)In [8]: plt.show()tf.VariableScopeset_initializer功能设置当前 scope 下的变量初始化函数，描述1set_initializer(initializer)示例12345678910111213141516171819202122232425262728293031323334353637$ ipython3In [1]: import matplotlib.pyplot as pltIn [2]: import tensorflow as tfIn [3]: with tf.variable_scope('my'): ...: a1 = tf.get_variable(name='a1', shape=[1000]) ...: tf.get_variable_scope().set_initializer(tf.keras.initializers.glorot_normal()) ...: a2 = tf.get_variable(name='a2', shape=[1000])In [4]: a3 = tf.get_variable(name='a3', shape=[1000])In [5]: sess = tf.Session()In [6]: sess.run(tf.global_variables_initializer())In [7]: tmp1, tmp2, tmp3 = sess.run([a1, a2, a3])In [8]: plt.hist(tmp1) # 可以看出初始化的值并不符合正态分布，所以 set_initializer 必须在变量定义前执行Out[8]:(array([ 99., 85., 95., 109., 86., 103., 101., 111., 101., 110.]), array([ -5.47123924e-02, -4.37659476e-02, -3.28195028e-02, -2.18730580e-02, -1.09266132e-02, 1.98315829e-05, 1.09662764e-02, 2.19127212e-02, 3.28591660e-02, 4.38056108e-02, 5.47520556e-02]), &lt;a list of 10 Patch objects&gt;)In [9]: plt.show()In [10]: plt.hist(tmp2) # 这里就对了Out[10]:Out[10]:(array([ 33., 61., 99., 157., 168., 160., 132., 103., 61., 26.]), array([-0.0629639 , -0.05034959, -0.03773528, -0.02512098, -0.01250667, 0.00010763, 0.01272194, 0.02533624, 0.03795055, 0.05056485, 0.06317916]), &lt;a list of 10 Patch objects&gt;)In [11]: plt.show()In [12]: plt.hist(tmp3) # 这里已经不属于同一个 scope 了，所以分布也不符合正态分布Out[12]:(array([ 98., 109., 81., 112., 69., 92., 97., 110., 118., 114.]), array([-0.0544718 , -0.04354969, -0.03262758, -0.02170548, -0.01078337, 0.00013874, 0.01106084, 0.02198295, 0.03290506, 0.04382716, 0.05474927]), &lt;a list of 10 Patch objects&gt;)In [13]: plt.show()tf.datatf.data.Datasetapply功能对 Dataset 的元素使用一个转换函数，转换函数目前多定义于 tf.contrib.data描述1234567apply(transformation_func)Args:transformation_func: A function that takes one Dataset argument and returns a Dataset.Returns:The Dataset returned by applying transformation_func to this dataset.示例参考 tf.contrib.data.group_by_windowfilter功能过滤…描述1234567filter(predicate)Args:predicate: A function mapping a nested structure of tensors (having shapes and types defined by self.output_shapes and self.output_types) to a scalar tf.bool tensor.Returns:A Dataset.示例12345678910111213141516171819$ ipython3In [1]: load /Users/jiexiao/workspace/tmp.pyIn [2]: # %load /Users/jiexiao/workspace/tmp.py ...: import tensorflow as tf ...: from tensorflow.python.data import Dataset ...: def print_dataset(d): ...: d_iter = d.make_one_shot_iterator() ...: with tf.Session() as sess: ...: while True: ...: try: ...: print(sess.run(d_iter.get_next())) ...: except tf.errors.OutOfRangeError: ...: breakIn [3]: a = Dataset.range(11)In [4]: print_dataset(a.filter(lambda x: x &gt; 6))78910make_initializable_iterator功能创建一个 Dataset 的迭代器，可以对比 make_one_shot_iterator描述1234567make_initializable_iterator(shared_name=None)Args:shared_name: (Optional.) If non-empty, the returned iterator will be shared under the given name across multiple sessions that share the same devices (e.g. when using a remote server).Returns:An Iterator over the elements of this dataset.示例12345678910111213$ ipythonIn [1]: from tensorflow.python.data import DatasetIn [2]: import tensorflow as tfIn [3]: dataset = Dataset.range(5)In [4]: d_iter = dataset.make_initializable_iterator()In [5]: with tf.Session() as sess: ...: sess.run(d_iter.initializer) ...: print(d_iter.get_next().eval()) ...: sess.run(d_iter.initializer) ...: print(d_iter.get_next().eval()) ...:00make_one_shot_iterator功能创建一个 Dataset 的迭代器，可以对比 make_initializable_iterator, 主要区别是：返回的迭代器不能调用 initializer，所以只能遍历一次描述1make_one_shot_iterator()示例12345678910$ ipythonIn [1]: from tensorflow.python.data import DatasetIn [2]: import tensorflow as tfIn [3]: dataset = Dataset.range(5)In [4]: d_iter = dataset.make_one_shot_iterator()In [5]: with tf.Session() as sess: ...: print(d_iter.get_next().eval()) ...: print(d_iter.get_next().eval())01map功能对 Dataset 中的所有元素执行指定函数描述1234567891011map( map_func, num_parallel_calls=None)Args:map_func: A function mapping a nested structure of tensors (having shapes and types defined by self.output_shapes and self.output_types) to another nested structure of tensors.num_parallel_calls: (Optional.) A tf.int32 scalar tf.Tensor, representing the number elements to process in parallel. If not specified, elements will be processed sequentially.Returns:A Dataset.示例123456789101112131415161718$ ipython3In [1]: load /Users/jiexiao/workspace/tmp.pyIn [2]: # %load /Users/jiexiao/workspace/tmp.py ...: import tensorflow as tf ...: from tensorflow.python.data import Dataset ...: def print_dataset(d): ...: d_iter = d.make_one_shot_iterator() ...: with tf.Session() as sess: ...: while True: ...: try: ...: print(sess.run(d_iter.get_next())) ...: except tf.errors.OutOfRangeError: ...: break ...: a = Dataset.range(1, 4) # &#123;1, 2, 3&#125;In [3]: print_dataset(a.map(lambda x: x * 2))246padded_batch功能将 Dataset 分为固定大小的 batch_size, 同时将每个 batch 进行 padding，padding 长度默认为当前 batch 中的最大值描述12345678910111213padded_batch( batch_size, padded_shapes, padding_values=None)Args:batch_size: A tf.int64 scalar tf.Tensor, 每个 batch 的大小padded_shapes: Dataset 中每个数据的 shape，如果出现 tf.TensorShape([None]) 则表示 padding 至当前 batch 中的最大值padding_values: (Optional.) padding 的值，默认为 0 或者 &apos;&apos;Returns:A Dataset.示例123456789101112131415161718192021222324252627282930313233343536373839404142434445$ ipythonIn [1]: load /root/workspace/tmp.pyIn [2]: # %load /root/workspace/tmp.py ...: import tensorflow as tf ...: from tensorflow.python.data import Dataset ...: def print_dataset(d): ...: d_iter = d.make_one_shot_iterator() ...: with tf.Session() as sess: ...: while True: ...: try: ...: print(sess.run(d_iter.get_next())) ...: except tf.errors.OutOfRangeError: ...: breakIn [3]: dataset = tf.data.Dataset.range(10)In [4]: dataset = dataset.map(lambda x: &#123;'x': tf.fill([tf.cast(x, tf.int32)], x), 'y': tf.fill([tf.cast(x, tf.int32)], x)&#125;)In [5]: print_dataset(dataset) # 这里有 10 个元素，且每个元素包含的子项不一样多&#123;'x': array([], dtype=int64), 'y': array([], dtype=int64)&#125;&#123;'x': array([1]), 'y': array([1])&#125;&#123;'x': array([2, 2]), 'y': array([2, 2])&#125;&#123;'x': array([3, 3, 3]), 'y': array([3, 3, 3])&#125;&#123;'x': array([4, 4, 4, 4]), 'y': array([4, 4, 4, 4])&#125;&#123;'x': array([5, 5, 5, 5, 5]), 'y': array([5, 5, 5, 5, 5])&#125;&#123;'x': array([6, 6, 6, 6, 6, 6]), 'y': array([6, 6, 6, 6, 6, 6])&#125;&#123;'x': array([7, 7, 7, 7, 7, 7, 7]), 'y': array([7, 7, 7, 7, 7, 7, 7])&#125;&#123;'x': array([8, 8, 8, 8, 8, 8, 8, 8]), 'y': array([8, 8, 8, 8, 8, 8, 8, 8])&#125;&#123;'x': array([9, 9, 9, 9, 9, 9, 9, 9, 9]), 'y': array([9, 9, 9, 9, 9, 9, 9, 9, 9])&#125;In [6]: dataset = dataset.padded_batch(4, padded_shapes=&#123;'x': [None], 'y': [None]&#125;)In [7]: print_dataset(dataset) # 这里只剩下 3 个 batch 了，每个 batch 中的元素的子项数量是一致的，都是当前 batch 中的最大值&#123;'x': array([[0, 0, 0], [1, 0, 0], [2, 2, 0], [3, 3, 3]]), 'y': array([[0, 0, 0], [1, 0, 0], [2, 2, 0], [3, 3, 3]])&#125;&#123;'x': array([[4, 4, 4, 4, 0, 0, 0], [5, 5, 5, 5, 5, 0, 0], [6, 6, 6, 6, 6, 6, 0], [7, 7, 7, 7, 7, 7, 7]]), 'y': array([[4, 4, 4, 4, 0, 0, 0], [5, 5, 5, 5, 5, 0, 0], [6, 6, 6, 6, 6, 6, 0], [7, 7, 7, 7, 7, 7, 7]])&#125;&#123;'x': array([[8, 8, 8, 8, 8, 8, 8, 8, 0], [9, 9, 9, 9, 9, 9, 9, 9, 9]]), 'y': array([[8, 8, 8, 8, 8, 8, 8, 8, 0], [9, 9, 9, 9, 9, 9, 9, 9, 9]])&#125;prefetch功能个人感觉就是为了在性能和占用内存间选一个合适的界限描述1234567prefetch(buffer_size)Args:buffer_size: A tf.int64 scalar tf.Tensor, representing the maximum number elements that will be buffered when prefetching.Returns:A Dataset.shard功能将一个 Dataset 切分成 N 份，然后取出 1 份，在分布式训练时，避免资源竞争使用描述1234567891011shard( num_shards, index)Args:num_shards: A tf.int64 scalar tf.Tensor, 切分的份数index: A tf.int64 scalar tf.Tensor, 取出份数的 IDReturns:A Dataset.示例1234567891011121314151617$ ipythonIn [1]: import tensorflow as tfIn [2]: from tensorflow.python.data import DatasetIn [3]: def print_dataset(d): ...: d_iter = d.make_one_shot_iterator() ...: with tf.Session() as sess: ...: while True: ...: try: ...: print(sess.run(d_iter.get_next())) ...: except tf.errors.OutOfRangeError: ...: breakIn [4]: a = Dataset.range(1, 4) # &#123;1, 2, 3&#125;In [5]: print_dataset(a.shard(2, 0))13In [6]: print_dataset(a.shard(2, 1))2shuffle功能对 Dataset 中的数据进行重新排序描述12345678910111213shuffle( buffer_size, seed=None, reshuffle_each_iteration=None)Args:buffer_size: A tf.int64 scalar tf.Tensor, 目前的理解是用于内存管理，控制每次加载到内存中的元素个数seed: (Optional.) A tf.int64 scalar tf.Tensor, representing the random seed that will be used to create the distribution. See tf.set_random_seed for behavior.reshuffle_each_iteration: (Optional.) A boolean, which if true indicates that the dataset should be pseudorandomly reshuffled each time it is iterated over. (Defaults to True.)Returns:A Dataset.buffer_size 使用场景buffer_size 理解示例123456789101112131415161718192021$ ipython3Python 3.6.1 (default, Apr 4 2017, 09:40:21)Type 'copyright', 'credits' or 'license' for more informationIPython 6.1.0 -- An enhanced Interactive Python. Type '?' for help.In [1]: load /Users/jiexiao/workspace/tmp.pyIn [2]: # %load /Users/jiexiao/workspace/tmp.py ...: import tensorflow as tf ...: from tensorflow.python.data import Dataset ...: def print_dataset(d): ...: d_iter = d.make_one_shot_iterator() ...: with tf.Session() as sess: ...: while True: ...: try: ...: print(sess.run(d_iter.get_next())) ...: except tf.errors.OutOfRangeError: ...: break ...: a = Dataset.range(1, 4) # &#123;1, 2, 3&#125;In [3]: print_dataset(a.shuffle(10))213skip功能丢弃一部分数据描述1234567skip(count)Args:count: A tf.int64 scalar tf.Tensor, representing the number of elements of this dataset that should be skipped to form the new dataset. If count is greater than the size of this dataset, the new dataset will contain no elements. If count is -1, skips the entire dataset.Returns:A Dataset.示例1234567891011121314151617$ ipythonIn [1]: import tensorflow as tfIn [2]: from tensorflow.python.data import DatasetIn [3]: def print_dataset(d): ...: d_iter = d.make_one_shot_iterator() ...: with tf.Session() as sess: ...: while True: ...: try: ...: print(sess.run(d_iter.get_next())) ...: except tf.errors.OutOfRangeError: ...: breakIn [4]: a = Dataset.range(1, 4) # &#123;1, 2, 3&#125;In [5]: print_dataset(a.skip(1))23In [6]: print_dataset(a.skip(2))3zip功能与 python 内置的 zip 类似描述1234567zip(datasets)Args:datasets: A nested structure of datasets.Returns:A Dataset.示例12345678910111213141516171819202122232425262728293031$ ipythonIn [1]: from tensorflow.python.data import DatasetIn [2]: import tensorflow as tfIn [3]: def print_dataset(d): ...: d_iter = d.make_one_shot_iterator() ...: with tf.Session() as sess: ...: while True: ...: try: ...: print(sess.run(d_iter.get_next())) ...: except tf.errors.OutOfRangeError: ...: break ...:In [4]: a = Dataset.range(1, 4) # &#123;1, 2, 3&#125;In [5]: b = Dataset.range(4, 7) # &#123;4, 5, 6&#125;In [7]: c = Dataset.zip((Dataset.range(7, 12), Dataset.range(8, 13))) # &#123; (7, 8), (8, 9), (9, 10) &#125;In [8]: d = Dataset.range(13, 15) # &#123;13, 14&#125;In [9]: print_dataset(Dataset.zip((a, b)))(1, 4)(2, 5)(3, 6)In [10]: print_dataset(Dataset.zip((b, a)))(4, 1)(5, 2)(6, 3)In [11]: print_dataset(Dataset.zip((a, b, c)))(1, 4, (7, 8))(2, 5, (8, 9))(3, 6, (9, 10))In [12]: print_dataset(Dataset.zip((a, d)))(1, 13)(2, 14)tf.data.Iteratorget_next功能通过 Iterator 从 Dataset 中取数据描述1234567get_next(name=None)Args:name: (Optional.) A name for the created operation.Returns:A nested structure of tf.Tensor objects.示例12345678910$ ipythonIn [1]: from tensorflow.python.data import DatasetIn [2]: import tensorflow as tfIn [3]: dataset = Dataset.range(5)In [4]: d_iter = dataset.make_one_shot_iterator()In [5]: with tf.Session() as sess: ...: print(d_iter.get_next().eval()) ...: print(d_iter.get_next().eval())01tf.data.TextLineDataset功能按行读取文件，转化为 TextLineDataset 对象描述12345678910__init__( filenames, compression_type=None, buffer_size=None)Args:filenames: A tf.string tensor containing one or more filenames.compression_type: (Optional.) A tf.string scalar evaluating to one of &quot;&quot; (no compression), &quot;ZLIB&quot;, or &quot;GZIP&quot;.buffer_size: (Optional.) A tf.int64 scalar denoting the number of bytes to buffer. A value of 0 results in the default buffering values chosen based on the compression type.示例123456789101112131415161718192021$ cat /tmp/test.txtemersonlakepalmer$ ipythonIn [1]: from tensorflow.python.data import TextLineDatasetIn [2]: import tensorflow as tfIn [3]: def print_dataset(d): ...: d_iter = d.make_one_shot_iterator() ...: with tf.Session() as sess: ...: while True: ...: try: ...: print(sess.run(d_iter.get_next())) ...: except tf.errors.OutOfRangeError: ...: breakIn [4]: tmp = tf.data.TextLineDataset('/tmp/test.txt')In [5]: print_dataset(tmp)b'emerson'b'lake'b'palmer'tf.contrib.datatf.contrib.data.group_by_window功能将训练数据划分为多组，然后对每组数据进行 padding、shuffle、batch 等操作描述123456789101112131415group_by_window( key_func, reduce_func, window_size=None, window_size_func=None)Args:key_func: 将 Tensor 映射为一个 ID。典型场景：根据训练数据的输入输出长度，产生一个合适的 bucket id。reduce_func: 从 Dataset 中取出 window_size 个元素，然后对这些元素进行 padding、shuffle、batch 等操作window_size: 表示 window_size, 作为 reduce_func 的第一个参数传入，与 window_size_func 互斥window_size_func: 通过 key_func 计算的 ID 来计算 window_size, 与 window_size 参数互斥Returns:A Dataset transformation function, which can be passed to tf.data.Dataset.apply.示例1234567891011121314151617181920212223242526272829$ ipythonIn [1]: load /root/workspace/tmp.pyIn [2]: # %load /root/workspace/tmp.py ...: import tensorflow as tf ...: from tensorflow.python.data import Dataset ...: def print_dataset(d): ...: d_iter = d.make_one_shot_iterator() ...: with tf.Session() as sess: ...: while True: ...: try: ...: print(sess.run(d_iter.get_next())) ...: except tf.errors.OutOfRangeError: ...: breakIn [3]: dataset = Dataset.range(12)In [4]: dataset = dataset.apply(tf.contrib.data.group_by_window(key_func=lambda x: x%2, reduce_func=lambda x, els: els.batch(3), window_size=3))In [5]: print_dataset(dataset) # 这里 window_size 为 3，所以首先从双数数列取了 3 个元素，划分为 1 个大小为 3 的 batch，然后从单数数列取了 3 个元素，重复...[0 2 4][1 3 5][ 6 8 10][ 7 9 11]In [6]: dataset = Dataset.range(12)In [7]: dataset = dataset.apply(tf.contrib.data.group_by_window(key_func=lambda x: x%2, reduce_func=lambda x, els: els.batch(3), window_size=5))In [8]: print_dataset(dataset) # 这里 window_size 为 5，所以首先从双数数列取了 5 个元素，划分为 1 个大小为 3 的 batch 和 1 个大小为 2 的 batch，然后从单数数列取了 5 个，重复...[0 2 4][6 8][1 3 5][7 9][10][11]stackoverflow 关于该函数使用的说明tf.contrib.lookuptf.contrib.lookup.HashTablelookup功能根据 token 和 ID 的映射表，给出目标串的 ID描述1234567891011lookup( keys, name=None)Args:keys: Keys to look up. May be either a SparseTensor or dense Tensor.name: A name for the operation (optional).Returns:A SparseTensor if keys are sparse, otherwise a dense Tensor.示例1234567891011$ ipythonIn [1]: import tensorflow as tfIn [2]: with tf.Session().as_default(): ...: default_val = -1 ...: keys = tf.constant(["brain", "salad", "surgery"]) ...: values = tf.constant([0, 1, 2], tf.int64) ...: table = tf.contrib.lookup.HashTable(tf.contrib.lookup.KeyValueTensorInitializer(keys, values), default_val) ...: input_string = tf.constant(["brain", "salad", "tank"]) ...: table.init.run() ...: table.lookup(input_string).eval()Out[2]: array([ 0, 1, -1])tf.contrib.lookup.index_table_from_file功能根据字典文件，建立 token 到 ID 的映射描述1234567891011121314151617181920212223index_table_from_file( vocabulary_file=None, num_oov_buckets=0, vocab_size=None, default_value=-1, hasher_spec=tf.contrib.lookup.FastHashSpec, key_dtype=tf.string, name=None)Args:vocabulary_file: The vocabulary filename, may be a constant scalar Tensor.num_oov_buckets: 如果关键字未在字典里出现，关键字将使用 hash 算法指定 [vocabulary size, vocabulary size + num_oov_buckets - 1] 范围内的 ID, 如果不指定 num_oov_buckets 则未知关键字的 ID 会被指定为 default_valuevocab_size: Number of the elements in the vocabulary, if known.default_value: The value to use for out-of-vocabulary feature values. Defaults to -1.hasher_spec: A HasherSpec to specify the hash function to use for assignation of out-of-vocabulary buckets.key_dtype: The key data type.name: A name for this op (optional).Returns:返回一个 tf.contrib.lookup.HashTable 对象The lookup table to map a key_dtype Tensor to index int64 Tensor.示例123456789101112131415$ cat &gt; /tmp/test.txtemersonlakepalmer$ ipythonIn [1]: import tensorflow as tfIn [2]: features = tf.constant(["emerson", "lake", "and", "palmer"])In [3]: table = tf.contrib.lookup.index_table_from_file(vocabulary_file="/tmp/test.txt", num_oov_buckets=1)In [4]: ids = table.lookup(features)In [5]: with tf.Session().as_default(): ...: tf.tables_initializer().run() ...: ids.eval() ...:Out[5]: array([0, 1, 3, 2])参考TensorFlow 全新的数据读取方式：Dataset API 入门教程]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用深度学习探索代码生成任务]]></title>
    <url>%2F2017%2F11%2F23%2Fgenerate-code.html</url>
    <content type="text"><![CDATA[最近的工作是探索代码生成，记录一些想法写在前面&#8195;&#8195; 最近一段时间主要投入利用深度学习做代码生成的工作，经过一段时间的调研逐步的认识到这个问题的困难，不管后续进展如何，总结一下心得也算是个交代。&#8195;&#8195; 以我浅薄的数学和机器学习相关的知识来看，代码生成问题很可能并不适合使用深度学习来完成。深度学习更适合处理连续空间的问题，因为深度学习中最基本的一个工具：梯度下降，就是假设整个问题就是一个连续的空间。另外，损失函数要求是可微的，可微的就意味着是连续的。由此，我简单的猜测，深度学习更适合图像类的连续问题，那么，为什么在翻译任务中深度学习表现的也那么好呢？我想那是因为翻译任务更加接近优化任务，输出序列存在较少的约束。&#8195;&#8195; 回过头来看看代码生成问题，代码生成是一个有着较多约束的问题。首先，生成的程序如果要能编译通过，就一定要符合语法，而语法就是约束。想来翻译任务也能翻译出符合自然语言语法的内容啊，但是，翻译的结果对语法的要求并不那么严格，同时，模型本身也并不需要学习到诸如 左右括号必须匹配 这样的问题。翻译模型只需要知道 I am Chinese 序列解码后的第一个词很可能是 我，然后在 I am Chinese 的前提下 我 后面有很大概率是 是，以此类推。可以看出翻译模型并不知道约束，只知道在 ‘上下文’ 环境里，下次一个词最有可能是什么就够了，换句话说，翻译模型是在一个完整的 token 空间 内找到那个最可能出现的词。所以，在不存在约束的情况下，我们可以简单的认为，这也是一个连续空间内的搜索的问题。那么，代码生成问题呢？显示不是，我生成了第一个关键字 sys，无论是概率角度还是语法角度，后一个输出都很可能是 .，但是，第三个输出呢？还是在完整的 token 空间 内搜索么？不是的，sys 是个 module, 也就是说第三个输出是 token 空间 中的一个很小的子集。按我的理解，数学上最容易表达约束的就是分段函数，一旦分段，就没有连续性，梯度下降在某个点的偏导就可能是未定义的。&#8195; &#8195; 抱怨困难或者找借口总是简单的，然而却毫无意义，拿着公司的钱只能是硬着头皮上。后续我会继续分析相关的几个 Demo，例如：NMT、Pix2Code、DeepCoder 等模型。#代码生成可行性分析123456789101112131415161718192021222324252627282930搜索空间大小Translate = 40000 ^ 50 = 1.26 e+ 230pix2code =15 ^ 60 = 3.68 e+ 70case2script = 20000 ^ 200 = 1.60 e+ 860 仅预测 AW 接口 1000 ^ 25 = 1. e+ 75目标函数复杂度 输入输出差异性 Translate：自然语言 -&gt; 自然语言 pix2code：图像 -&gt; 代码 case2script：自然语言 -&gt; 代码 case2script = pix2code &gt;Translate pix2code 使用 CNN 捕获图像特征，根据特征进行代码生成，case2script 需要自然语言理解，根据语义进行代码生成，传统的翻译模型是否具有自然语言理解的能力？ 输出输出信息量差异 Translate：信息量一致 pix2code：信息量一致 case2script：输入信息量小于输出信息量 case2script &gt; pix2code = Translate 参考翻译模型：如何由“意图”推理出“实现”？——知识图谱？ 参考 pix2code：如何抽取特征 / 噪声过滤？——有注意力机制的 RNN？CNN 的特性就是抽取图像特性，RNN 的特性是获取时间序列特性是否合适？可用训练集大小 Translate = 2000W pix2code = 1750 case2script = 10W / 4 = 2W 数据质量：pix2code &gt; Translate &gt; case2script 如何清洗数据？训练目标 Translate：勉强可理解 pix2code：77% DSL case2script：100% GIL case2script &gt; pix2code &gt; Translate DSL 相比于 GIL，除了搜索空间较小以外，很重要的一点是绕开了“复杂结构生成“问题，例如，函数名和参数名预测正确的情况下，还要保证函数（参数 1，参数 2）这样的结构，而且无需考虑括号匹配、分支等问题]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 调试技巧]]></title>
    <url>%2F2017%2F11%2F23%2Fpython_debug.html</url>
    <content type="text"><![CDATA[python 调试技巧python 异常退出时进入 ipdb将以下脚本保存至 my_crash.py, 为了方便使用，可以通过 sys.path 查询默认包路径，将 my_crash.py 放至某个默认路径，例如：/root/anaconda3/lib/python3.612345678910111213import sysclass ExceptionHook: instance = None def __call__(self, *args, **kwargs): if self.instance is None: from IPython.core import ultratb self.instance = ultratb.FormattedTB(mode='Plain', color_scheme='Linux', call_pdb=1) return self.instance(*args, **kwargs)sys.excepthook = ExceptionHook()使用时，仅需要 import my_crash 即可以下为完整示例，代码一共就两行，第一行导入 my_crash, 第二行制造异常，运行后就自动进入 ipdb 了1234567891011$ python /tmp/tmp.pyTraceback (most recent call last): File "/tmp/tmp.py", line 2, in &lt;module&gt; 1/0ZeroDivisionError: division by zero&gt; /tmp/tmp.py(2)&lt;module&gt;() 1 import my_crash----&gt; 2 1/0ipdb&gt;ipython 中快速调试函数进入 ipython 的配置目录1cd `ipython locate profile`/startup创建 tool.py 文件，然后把以下代码粘贴进去1234def debug(f, *args, **kwargs): from IPython.core.debugger import Pdb pdb = Pdb(color_scheme='Linux') return pdb.runcall(f, *args, **kwargs)然后就可以在 ipython 中快速 debug 了。 下面这个例子中， f 函数接受三个参数，于是我就可以通过 debug(f, 1, 2, 3) 直接进行调试了1234567891011121314151617181920212223242526272829303132$ ipythonPython 3.6.1 |Anaconda custom (64-bit)| (default, May 11 2017, 13:09:58)Type 'copyright', 'credits' or 'license' for more informationIPython 6.2.0 -- An enhanced Interactive Python. Type '?' for help.In [1]: cat /tmp/tmp.pydef f(x, y, z): tmp = x + y return tmp / zIn [2]: %load /tmp/tmp.pyIn [3]: # %load /tmp/tmp.py ...: def f(x, y, z): ...: tmp = x + y ...: return tmp / z ...:In [4]: debug(f, 1, 2, 3)/root/anaconda3/bin/ipython:3: DeprecationWarning: The `color_scheme` argument is deprecated since version 5.1 # -*- coding: utf-8 -*-&gt; &lt;ipython-input-3-586af56f5d02&gt;(3)f() 1 # %load /tmp/tmp.py 2 def f(x, y, z):----&gt; 3 tmp = x + y 4 return tmp / zipdb&gt; ax = 1y = 2z = 3ipdb&gt;触发断点后进入 ipython优势是 ipython 中可以非常方便的编写包含嵌套的代码，而且可以方便的引用全局 / 局部变量123456789def my_break(local_ns=None, global_ns=None): # An interactive shell is useful for debugging/development. import IPython user_ns = &#123;&#125; if local_ns: user_ns.update(local_ns) if global_ns: user_ns.update(global_ns) IPython.start_ipython(argv=[], user_ns=user_ns)为了使用方便，将以上代码拷贝至 /root/anaconda3/lib/python3.6/my_break.py, 以下为具体实例12345678910111213141516171819202122$ python /tmp/tmp.pyPython 3.6.1 |Anaconda custom (64-bit)| (default, May 11 2017, 13:09:58)Type 'copyright', 'credits' or 'license' for more informationIPython 6.2.0 -- An enhanced Interactive Python. Type '?' for help.In [1]: cat /tmp/tmp.pyfrom my_break import my_breakvar_global = 'global'def f(): var_locals = 'local' my_break(locals(), globals())f()In [2]: var_globalOut[2]: 'global'In [3]: var_localsOut[3]: 'local'In [4]:执行到 my_break() 函数后就进入了 ipython 交互界面，可以看出我们可以使用局部和全局变量使用 pdb 的 command 动态添加日志pdb 的 command 命令非常适合调试，以下为示例：1234567891011121314151617181920212223242526272829303132$ python -m pdb /tmp/tmp.py&gt; /tmp/tmp.py(1)&lt;module&gt;()-&gt; from time import sleep(Pdb) l 1 -&gt; from time import sleep 2 for x in range(3): 3 print(&apos;old log&apos;) 4 sleep(1) 5[EOF](Pdb) b 3Breakpoint 1 at /tmp/tmp.py:3(Pdb) commands(com) print(&apos;new log %d&apos; % x)(com) c(Pdb) cnew log 0&gt; /tmp/tmp.py(3)&lt;module&gt;()-&gt; print(&apos;old log&apos;)old lognew log 1&gt; /tmp/tmp.py(3)&lt;module&gt;()-&gt; print(&apos;old log&apos;)old lognew log 2&gt; /tmp/tmp.py(3)&lt;module&gt;()-&gt; print(&apos;old log&apos;)old logThe program finished and will be restarted&gt; /tmp/tmp.py(1)&lt;module&gt;()-&gt; from time import sleep(Pdb)ipython 粘贴多行代码在 IPython 升级至 6.* 版本后，多行粘贴就只能使用 %cpaste 命令了123456789101112$ ipythonIn [1]: %cpastePasting code; enter &apos;--&apos; alone on the line to stop or use Ctrl-D.:import osdef print_dir(rootDir): list_dirs = os.walk(rootDir) for root, dirs, files in list_dirs: for d in dirs: print(os.path.join(root, d)) for f in files: print(os.path.join(root, f))::::::::--]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[argparse 函数]]></title>
    <url>%2F2017%2F11%2F22%2Fpython-argparse.html</url>
    <content type="text"><![CDATA[python 参数解析函数介绍写在前面尽量用 argparse 替代 optparse设置解析器、定义参数、解析参数设置解析器：使用 argparse 的第一步就是创建一个解析器对象 ArgumentParser定义参数： 通过 add_argument() 指定参数解析参数： 通过 parse_args() 解析命令行参数，默认从 sys.argv[1:] 中获取参数1234import argparseparser = argparse.ArgumentParser(description='This is a PyMOTW sample program')parser.add_argument('-c', type=int, default=32, help="help info.")FLAG = parser.parse_args()将以上代码保存至 /tmp/tmp.py 然后就可以通过 python /tmp/tmp.py -h 查看帮助信息了1234567usage: tmp.py [-h] [-c C]This is a PyMOTW sample programoptional arguments: -h, --help show this help message and exit -c C help info.使用时可以通过 FLAG.c 进行引用设置必选参数1parser.add_argument(&apos;-c&apos;, type=str, required=True)nargsN指定每个参数的个数123456789101112131415161718192021$ ipythonIn [1]: import argparseIn [2]: parser = argparse.ArgumentParser()In [3]: parser.add_argument('arg1', nargs=2)Out[3]: _StoreAction(option_strings=[], dest='arg1', nargs=2, const=None, default=None, type=None, choices=None, help=None, metavar=None)In [5]: parser.add_argument('--arg2', nargs=2)Out[5]: _StoreAction(option_strings=['--arg2'], dest='arg2', nargs=2, const=None, default=None, type=None, choices=None, help=None, metavar=None)In [6]: parser.add_argument('arg3', nargs=3)Out[6]: _StoreAction(option_strings=[], dest='arg3', nargs=3, const=None, default=None, type=None, choices=None, help=None, metavar=None)In [11]: parser.parse_args('--arg2 a b c d e f g'.split())Out[11]: Namespace(arg1=['c', 'd'], arg2=['a', 'b'], arg3=['e', 'f', 'g'])In [12]: parser.parse_args('a b --arg2 c d e f g'.split())Out[12]: Namespace(arg1=['a', 'b'], arg2=['c', 'd'], arg3=['e', 'f', 'g'])# 使用时，务必保证参数个数匹配In [14]: parser.parse_args('--arg2 a b c d e f'.split())usage: ipython [-h] [--arg2 ARG2 ARG2] arg1 arg1 arg3 arg3 arg3ipython: error: the following arguments are required: arg3An exception has occurred, use %tb to see the full traceback.SystemExit: 2/root/anaconda3/lib/python3.6/site-packages/IPython/core/interactiveshell.py:2890: UserWarning: To exit: use 'exit', 'quit', or Ctrl-D. warn("To exit: use 'exit', 'quit', or Ctrl-D.", stacklevel=1)?零个或一个参数12345678910111213141516171819$ ipythonIn [1]: import argparseIn [3]: parser = argparse.ArgumentParser()In [4]: parser.add_argument('arg1', nargs='?', const='c', default='d')Out[4]: _StoreAction(option_strings=[], dest='arg1', nargs='?', const='c', default='d', type=None, choices=None, help=None, metavar=None)In [6]: parser.add_argument('--arg2', nargs='?', const='e', default='f')Out[6]: _StoreAction(option_strings=['--arg2'], dest='arg2', nargs='?', const='e', default='f', type=None, choices=None, help=None, metavar=None)In [9]: parser.parse_args('A --arg2 C'.split())Out[9]: Namespace(arg1='A', arg2='C')In [10]: parser.parse_args('--arg2 A B'.split())Out[10]: Namespace(arg1='B', arg2='A')In [12]: parser.parse_args('--arg2 A '.split())Out[12]: Namespace(arg1='d', arg2='A')# 不包含参数值时，参数等于 ``const``In [13]: parser.parse_args('--arg2'.split())Out[13]: Namespace(arg1='d', arg2='e')# 不包含参数前缀和值的时候，参数等于 ``default``In [14]: parser.parse_args([])Out[14]: Namespace(arg1='d', arg2='f')*任意个数123456789$ ipythonIn [1]: import argparseIn [2]: parser = argparse.ArgumentParser()In [3]: parser.add_argument('arg1', nargs='*')Out[3]: _StoreAction(option_strings=[], dest='arg1', nargs='*', const=None, default=None, type=None, choices=None, help=None, metavar=None)In [4]: parser.add_argument('--arg2', nargs='*')Out[4]: _StoreAction(option_strings=['--arg2'], dest='arg2', nargs='*', const=None, default=None, type=None, choices=None, help=None, metavar=None)In [6]: parser.parse_args('A B --arg2 C D E'.split())Out[6]: Namespace(arg1=['A', 'B'], arg2=['C', 'D', 'E'])+至少一个1234567891011121314151617$ ipythonIn [1]: import argparseIn [2]: parser = argparse.ArgumentParser()In [3]: parser.add_argument('arg1', nargs='+')Out[3]: _StoreAction(option_strings=[], dest='arg1', nargs='+', const=None, default=None, type=None, choices=None, help=None, metavar=None)In [4]: parser.add_argument('--arg2', nargs='+')Out[4]: _StoreAction(option_strings=['--arg2'], dest='arg2', nargs='+', const=None, default=None, type=None, choices=None, help=None, metavar=None)In [5]: parser.parse_args('A --arg2 B'.split())Out[5]: Namespace(arg1=['A'], arg2=['B'])# 至少有一个参数In [6]: parser.parse_args('--arg2 A'.split())usage: ipython [-h] [--arg2 ARG2 [ARG2 ...]] arg1 [arg1 ...]ipython: error: the following arguments are required: arg1An exception has occurred, use %tb to see the full traceback.SystemExit: 2/root/anaconda3/lib/python3.6/site-packages/IPython/core/interactiveshell.py:2890: UserWarning: To exit: use 'exit', 'quit', or Ctrl-D. warn("To exit: use 'exit', 'quit', or Ctrl-D.", stacklevel=1)argparse.REMAINDER剩余的所有1234567891011$ ipythonIn [1]: import argparseIn [2]: parser = argparse.ArgumentParser()In [3]: parser.add_argument('--arg1')Out[3]: _StoreAction(option_strings=['--arg1'], dest='arg1', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)In [4]: parser.add_argument('arg2')Out[4]: _StoreAction(option_strings=[], dest='arg2', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)In [6]: parser.add_argument('arg3', nargs=argparse.REMAINDER)Out[6]: _StoreAction(option_strings=[], dest='arg3', nargs='...', const=None, default=None, type=None, choices=None, help=None, metavar=None)In [7]: parser.parse_args('--arg1 A B C --arg4 D E'.split())Out[7]: Namespace(arg1='A', arg2='B', arg3=['C', '--arg4', 'D', 'E'])参考argparse - 命令行选项与参数解析（译）]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tensorflow update 注意事项]]></title>
    <url>%2F2017%2F11%2F22%2Ftensorflow-update.html</url>
    <content type="text"><![CDATA[tensorflow 1.4 安装遇到的问题记录升级 1.4 问题一注意：pip 命令需要添加代理执行 pip install --ignore-installed --upgrade tensorflow 出现以下错误：1234In [1]: import tensorflow as tf/root/anaconda3/lib/python3.6/importlib/_bootstrap.py:205: RuntimeWarning: compiletime version 3.5 of module &apos;tensorflow.python.framework.fast_tensor_util&apos; does not match runtime version 3.6 return f(*args, **kwds)于是下载了一个特殊版本的 whl 然后安装12curl --insecure -o tensorflow-1.4.0rc1-cp36-cp36m-linux_x86_64.whl https://raw.githubusercontent.com/lakshayg/tensorflow-build/master/tensorflow-1.4.0rc1-cp36-cp36m-linux_x86_64.whlpip install --ignore-installed --upgrade tensorflow-1.4.0rc1-cp36-cp36m-linux_x86_64.whl升级 1.4 问题二运行后出现错误 GLIBCXX_3.4.22&#39; not found1234567add-apt-repository ppa:ubuntu-toolchain-r/testapt-get update # 更新源apt-get upgrade # 更新已安装的包apt-get dist-upgrade # 升级系统apt-get install build-essentialapt-get install aptitudeapt-get install libstdc++6通过strings /usr/lib/x86_64-linux-gnu/libstdc++.so.6 | grep GLIBCXX 检查下GLIBCXX_3.4.22是否存在]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql 安装备忘]]></title>
    <url>%2F2017%2F11%2F21%2Fmysql-install.html</url>
    <content type="text"><![CDATA[做个备忘检查 mysql 是否已经安装1yum list installed | grep mysql删除已经安装的 mysql1yum -y remove mysql-libs.x86_64添加安装源1234567wget dev.mysql.com/get/mysql-community-release-el6-5.noarch.rpmyum localinstall mysql-community-release-el6-5.noarch.rpmyum repolist all | grep mysqlyum-config-manager --disable mysql55-communityyum-config-manager --disable mysql56-communityyum-config-manager --enable mysql57-community-dmryum repolist enabled | grep mysql安装1yum install mysql-community-server启动1service mysqld start自启动12chkconfig --list | grep mysqldchkconfig mysqld on安装 mysqlclient12yum install python-devel mysql-develpip install mysqlclient参考CentOS 6.5/6.6 安装（install）mysql 5.7 最完整版教程mysqlclient 的 github 地址]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用快捷键汇总]]></title>
    <url>%2F2017%2F11%2F11%2Fkeboard_shortcuts.html</url>
    <content type="text"><![CDATA[日常使用的快捷键太多，分散存储不易查找，得益于 Next 主题优秀的目录导航，可以将所有的快捷键统一记录Item2Mac 下的 Item2 真心好用标签新建标签：command + t关闭标签：command + w关闭标签：command + z切换标签：command + 数字选择标签：command + 左右方向键 或者 command + { 或 command + }窗口垂直分屏：command + d水平分屏：command + shift + d最大化当前分屏：command + shift + Enter切换屏幕：command + option + 方向键 或者 command + [ 或 command + ]预览所有窗口 + 搜索：command + option + e历史查看命令历史：command + ;查看剪贴板历史：command + shift + h其他切换全屏：command + enter查找：command + f高亮光标：command + /标记：command + shift + m跳转：command + shift + jChrome通常只需要查看帮助 [?] 即可，不过自己写的东西理解起来还是要容易些滚动向下滚动：j向上滚动：k向左滚动：h向右滚动：l滚动到最上方：gg滚动到最下方：G滚动到最左方：zH滚动到最右方：zL向下滚动半页：d向上滚动半页：u常用后退：H前进：L刷新：r查找：/下一个匹配：n上一个匹配：N选中地址栏：command/Ctrl + l隐藏标签栏：Ctrl + Shift + BURL 相关操作拷贝当前 URL: yy拷贝指定 URL: yf *相当于鼠标右键 -&gt;复制链接*打开上一级 URL: gu打开最上级 URL: gU在当前标签打开链接：f *最常用的键，相当于鼠标左键*在新建标签打开链接：F在当前标签页中打开剪切板中的 URL: p在新建标签页中打开剪切板中的 URL: P输入进入编辑模式：i *比如说要在 jupyter 中编辑的时候，要先切换至编辑模式，否则快捷键均被覆盖*选择输入框：gi *相当于鼠标左键点击输入框*选择下一个 frame: gf *很多页面只有一个 frame 所以不常用*选择上一个 frame: gF快速检索打开快速检索窗口，搜索书签 / 历史记录：o打开快速检索窗口，搜索书签 / 历史记录，在新建标签中打开链接：O打开快速检索窗口，搜索书签：b打开快速检索窗口，搜索书签，在新建标签中打开链接：B打开快速检索窗口，将当前 URL 自动填入便于编辑：ge打开快速检索窗口，将当前 URL 自动填入便于编辑，在新建标签中打开链接：gE打开快速检索窗口，搜索 Tab 标签：T *在 Tab 页很多的时候很好用*Tab 页新建 Tab 页：t关闭当前标签页：x打开最近关闭的标签页：X选择上一个 Tab 页：J/gT *经常遇到不能使用 vimium 的网页只能使用 Tab 键替代*选择下一个 Tab 页：K/gt *经常遇到不能使用 vimium 的网页只能使用 Shift Tab 键替代*选择最近浏览的 Tab 页：^选择第一个 Tab 页：g0选择最后一个 Tab 页：g$将当前标签页向左移动：&lt;&lt;将当前标签页向右移动：&gt;&gt;在新建页中打开当前页面：yt *很常用，相当于 yy 复制当前链接，P 打开新的链接*将当前标签移至新窗口：W *相当于鼠标拖拽标签页至窗口外*其他帮助：?查看网页源码：gs不知道能干什么…Open multiple links in a new tab: &lt; a-f &gt;Enter visual mode: vEnter visual line mode: VFollow the link labeled previous or &lt;: [[Follow the link labeled next or &gt;: ]]Create a new mark: mGo to a mark: `Pin or unpin current tab: &lt; a-p &gt;Mute or unmute current tab: &lt; a-m &gt;Vimvim 需要记得太多了，用了几年有些都还不知道，汇总一下实用的，不常用的就不罗列了普通模式折叠zi 在 vim 中取消、生效折叠移动左右左移：h右移：l行尾：$行首：0非空行首：^前向行内查找：f{char}后向行内查找：F{char}前向行内查找，目标字符前一个位置：t{char}后向行内查找，目标字符后一个位置：T{char}重复行内查找：;反向重复行内查找：,上下上移：k下移：j至尾行：G至首行：gg至第 n 尾行：nG至全文件 %n 处：n%文本对象向右 N 个单词：w向右 N 个单词，停在词尾：e向右 N 个空白隔开的单词：W向右 N 个空白隔开的单词，停在词尾：E向左 N 个单词：b向左 N 个单词，停在词尾：ge向左 N 个空白隔开的单词：B向左 N 个空白隔开的单词，停在词尾：gE向前 N 个句子：)向后 N 个句子：(向前 N 个段落：}向后 N 个段落：{查找向前查找{: ]]向后查找{: [[向前查找}: ][向后查找}: []第一个 [ 表示方向，重复的找 {, 不同的找 }向前查找): ])向后查找(: [(向前查找}: ]}向后查找{: [{向前查找 #else 或 #endif: ]#向后查找 #if 或 #else: [#向前查找 */: ]*向后查找 /*: [*查找：/反向查找：?重复查找：n反向重复查找：N可以使用正则表达式按光标下的单词查找：*按光标下的单词反向查找：#查找高亮的文本：{visual} *反向查找高亮的文本：{visual} #查找光标下的局部变量：gd查找光标下的全局变量：gD标记与跳转标记：m{a-zA-Z}文件内跳转：&#39;{a-z}全局跳转：&#39;{A-Z}跳转至文件最后被改动的位置：&#39;.列出活动的位置标记：:marks向后跳转：Ctrl + o向前跳转：Ctrl + i列出跳转列表：:ju转到当前光标下标签的定义：Ctrl + ]跳转至本行中{ ( [等的对称位置：%窗口顶部：H窗口底部：L窗口中部：M滚动向下滚动一行：Ctrl + e向上滚动一行：Ctrl + y向左滚动一列：zh向右滚动一列：zl向下滚动半屏：Ctrl + d向上滚动半屏：Ctrl + u向左滚动半屏：zH向右滚动半屏：zL当前行置为窗口顶部：zt当前行置为窗口中部：zz当前行置为窗口底部：zb编辑删除整行：dd复制整行：yy删除行内容：D连接行：J连接行，但不插入空格：gJ粘贴至光标后：p粘贴至光标前：P粘贴至光标后，缩进与光标所在行一致：]p粘贴至光标前，缩进与光标所在行一致：]P粘贴至光标后，光标停留在粘贴文本后：gp粘贴至光标前，光标停留在粘贴文本后：gP交换当前光标及下一个字符：xp交换当前光标及上一个字符：Xp替换字符：r替换字符并不影响布局：gr将光标之上或之后的数值增加 N: CTRL-A将光标之上或之后的数值减少 N: CTRL-X进入 visual 模式以字符方式开始高亮：v使用上一次的可视区域开始高亮：gv以行方式开始高亮：V以列块方式开始高亮：CTRL-V选择一个单词：aw选择一个单词，不包括词尾空格：iw选择一段不包含空白符的字串：aW选择一段不包含空白符的字串，不包含词尾空格：iW进入编辑模式光标前插入：i光标后插入：a行首非空插入：I行首插入：gI行末插入：A当前行下方插入新行：o当前行上方插入新行：O插入光标下方的字符：Ctrl + e插入光标上方的字符：Ctrl + y进入替换模式：R进入替换模式，但不影响布局：gR删除行，并进入插入模式：cc删除字符，并进入插入模式：s翻转大小写并前进光标：~###显示当前正在编辑的文件 Ctrl + g编辑模式快捷键补全路径：Ctrl + x Ctrl + f向前删除单词：Ctrl + w删除一段时间内输入的字符：Ctrl + u增加缩进：Ctrl + t减少当前行的缩进：Ctrl + dvisual 模式删除高亮的文本：d删除高亮的文本，进入编辑模式：c删除高亮的行，进入编辑模式：C复制高亮的文本：y替换高亮的文本：r连接高亮行：J连接高亮行，但不插入空格：gJ翻转高亮文本的大小写：~改高亮的文本为小写：u改高亮的文本为大写：U交换高亮区域的开始处和光标位置：o选择 “一个句子” (sentence): as选择 “内含句子”: is选择 “一个段落” (paragraph): ap选择 “内含段落”: ip选择 “一个块” （从 “[(“ 至 “])”) (block): ab选择 “内含块” （从 “[(“ 到 “])”): ib选择 “一个大块” （从 “[{“ 到 “]}”) (Block): aB选择 “内含大块” （从 “[{“ 到 “]}”): iB选择 “一个 &lt;&gt; 块”: a&gt;选择 “内含 &lt;&gt; 块”: i&gt;选择 “一个标签块” （从到) (tag): at选择 “内含标签块” （从到): it选择 “一个单引号字符串”: a&#39;选择 “内含单引号字符串”: i&#39;选择 “一个双引号字符串”: a&quot;选择 “内含双引号字符串”: i&quot;选择 “一个反引号字符串”: ``a1选择 &quot;内含反引号字符串&quot;: ``i命令行将文件的内容插入到下一行：:r {file}将命令结果插入到下一行：:r {file}显示寄存器的内容：:regmotion删除动作 {motion} 覆盖的文本，并进入插入模式：c{motion}将动作 {motion} 覆盖的文本翻转大小写：g~{motion}将动作 {motion} 覆盖的文本改为小写：gu{motion}将动作 {motion} 覆盖的文本改为大写：gU{motion}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665改变文本重复最近一次改动 （将计数改为 N): ``.``记录键入的字符，存入寄存器 &#123;a-z&#125;: ``q&#123;a-z&#125;``记录键入的字符，添加进寄存器 &#123;a-z&#125;: ``q&#123;A-Z&#125;``终止记录：``q``执行寄存器 &#123;a-z&#125; 的内容 (N 次）: ``@&#123;a-z&#125;``重复上次的 @&#123;a-z&#125; 操作 (N 次）: ``@@``将寄存器 &#123;a-z&#125; 的内容当作 Ex 命令来执行：``:@&#123;a-z&#125;``重复上次的 :@&#123;a-z&#125; 操作：``:@@``撤销最近的 N 此改动：``u``重做最近的 N 个被撤销的改动：``CTRL-r``恢复最近被改动的行：``U``执行 shell 命令：``:!&#123;command&#125;``查看光标下的标识符的 man 帮助：``K``显示第 [nr] 个错误 （缺省为同一错误）: ``:cc [nr]``显示下一个错误：``:cn``显示上一个错误：``:cp``列出所有错误：``:cl``显示 quickfix 窗口：``:cw``以十进制、十六进制和八进制显示当前光标下的字符：``ga``重新载入当前文件：``:e``编辑第 N 个轮换文件名：``CTRL-^``显示所有的轮换文件名：``:files``编辑光标下的文件名对应的文件：``gf``显示当前目录名：``:pwd``切换当前目录到 [path]: ``:cd [path]``回到上一次当前目录：``:cd -``将当前文件目录设置为工作目录：``,cd``置光标于第 [num] 行 （缺省：末行）: ``+[num]``置光标于第一次出现 &#123;pat&#125; 的地方：``+/&#123;pat&#125; &#123;file&#125; ..``写入当前文件改动，并退出：``ZZ``放弃当前文件修改退出：``ZQ``挂起 vim: ``CTRL-z``回复 vim: ``fg``写入所有改动的缓冲区并退出：``:xa``退出 Vim，放弃所有改动：``:qa!``快速保存：``,w``分隔窗口并在其中一个编辑 &#123;file&#125;: ``:split &#123;file&#125;``同上，但垂直分割：``:vsplit &#123;file&#125;``分割窗口并跳转到光标下的标签：``CTRL-W ]``分割窗口并编辑光标下的文件名 (file): ``CTRL-W f``分割窗口并编辑轮换文件：``CTRL-W ^``创建新空白窗口 (new): ``CTRL-W n``退出编辑并关闭窗口 (quit): ``CTRL-W q``隐藏当前缓冲区并关闭窗口 (close): ``CTRL-W c``使当前窗口成为唯一窗口 (only): ``CTRL-W o``跳转到下方窗口：``CTRL-j``跳转到上方窗口：``CTRL-k``跳转到左方窗口：``CTRL-h``跳转到右方窗口：``CTRL-l``跳转到顶端窗口 (top): ``CTRL-W t``跳转到底端窗口 (bottom): ``CTRL-W b``跳转到上一次激活的窗口 (previous): ``CTRL-W p``向下旋转窗口 (rotate): ``CTRL-W r``向上旋转窗口 (Rotate): ``CTRL-W R``将当前窗口与下一个窗口对调 (eXchange): ``CTRL-W x``使所有窗口等高：``CTRL-W =``减少当前窗口高度：``CTRL-W -``增加当前窗口高度：``CTRL-W +``设置当前窗口高度 （缺省：很高）: ``CTRL-W _``将当前窗口移动到右侧：``Ctrl + w L``将当前窗口移动到左侧：``Ctrl + w H``将当前窗口移动到下面：``Ctrl + w J``将当前窗口移动到上面：``Ctrl + w K``折叠删除光标下的一个折叠 (delete)zd折叠删除光标下的所有折叠 (Delete)zD折叠打开光标下的折叠 (open)zo折叠打开光标下的所有折叠 (Open)zO折叠关闭光标下的一个折叠 (close)zc折叠关闭光标下的所有折叠 (Close)zC折叠折起更多：减少 &apos;foldlevel&apos; (more)zm折叠关闭所有折叠：置 &apos;foldlevel&apos; 为 0zM折叠减少折叠：增加 &apos;foldlevel&apos; (reduce)zr折叠打开所有折叠：置 &apos;foldlevel&apos; 为最大zR折叠不折叠：复位 &apos;foldenable&apos; (none)zn折叠正常折叠：置位 &apos;foldenable&apos; (Normal)zN折叠反转 &apos;foldenable&apos; (invert)ziMRU打开最近访问的文件，fMRU在当前窗口打开EnterMRU在新建水平窗口打开该文件oMRU在新建垂直打开该文件OMRU只读打开vMRU在新的 tab 打开tMRU在新的 tab 打开错误修改 mru.vim 中对应行 exe &apos;tabnew &apos; . a:esc_fnameCtrlp打开文件模糊搜索Ctrl + Fctrlp设置 ctrlp 垂直分割打开窗口，防止和粘贴重复let g:ctrlp_prompt_mappings = &#123; &apos;AcceptSelection(&quot;v&quot;)&apos;: [&apos;&lt;c-g&gt;&apos;] &#125;ctrlp查看基本操作帮助:csNERD TreeNERDTreeToggle，nnNERD TreeNERDTreeFromBookmark，nbNERD TreeNERDTreeFind，nfNERD Tree打开 / 关闭帮助?tab新建一个标签页，tntab关闭其他标签，totab关闭标签，tctab移动便签至指定标签之后，tmtab打开指定标签，t，tab打开最近访问的标签，tltab打开新的标签页，新页的内容与当前页一致，tetab打开上一标签gTtab打开下一标签gtbuffers关闭当前 buffer，bdbuffers关闭所有 buffer，babuffers显示当前所有 buffers，oAg快速搜索，gAg选取模式下，搜索选中的内容gvAg选取模式下，搜索并替换选中的内容，rAg在新建窗口中显示结果，ccAg在新建窗口显示下一个搜索结果，nAg在新建窗口显示上一个搜索结果，pAg帮助信息:h ag-mappingsbasic.vim取消高亮，&lt;cr&gt;Goyo开启 goyo 模式，zoption设置查找时忽略大小写:set ignorecaseoption设置查找时大小写敏感:set noignorecasesurround可视模式下，添加 ()1surround可视模式下，添加 []2surround可视模式下，添加 &#123;&#125;3surround可视模式下，添加 &quot;&quot;$$surround可视模式下，添加 &apos;&apos;$q命令组合搜索并将 int 替换为 s32_t/intcws32_t&lt;esc&gt;n.cscopefind all references to the token under cursorCTRL-\ scscopeglobal: find global definition(s) of the token under cursorCTRL-\ gcscopecalls: find all calls to the function name under cursorCTRL-\ ccscopetext: find all instances of the text under cursorCTRL-\ tcscopecalls: find all calls to the function name under cursorCTRL-\ ecscopeegrep: egrep search for the word under cursorCTRL-\ fcscopeincludes: find files that include the filename under cursorCTRL-\ icscopecalled: find functions that function under cursor callsCTRL-\ dcscope在新建水平窗口打开CTRL-\ sscscope在新建垂直窗口打开CTRL-\ CTRL-\ scscope设置 cscope 从右边打开新建垂直窗口:set splitrightcscope设置结果显示至 quickfix 窗口h cscopequickfixman快速打开 man 帮助:source $VIMRUNTIME/ftplugin/man.vim:nmap K :Man &lt;c-r&gt;&lt;c-w&gt;&lt;cr&gt;:echo $VIMRUNTIME 修改 man.vim 中的 new 为 vnewYankRing在插入模式下选择上一个粘贴的内容CTRL-pYankRing在插入模式下选择下一个粘贴的内容CTRL-nYankRing显示所有剪切内容:YRShowBufExplorer查看帮助F1commentary注释 / 反注释单行gcccommentary注释 / 反注释高亮部分&#123;visual&#125; gcSnipMate打开可选的补全列表 / 选择可选的补全列表&lt;Tab&gt;SnipMate选择上一个可选项Ctrl - pSnipMate选择下一个可选项Ctrl - nMRU 打开最近访问的文件 ，fMRU 在当前窗口打开 EnterMRU 在新建水平窗口打开该文件 oMRU 在新建垂直打开该文件 oMRU 只读打开 vMRU 在新的 tab 打开 tCtrlp 打开文件模糊搜索 Ctrl + FNERD Tree NERDTreeToggle ，nnNERD Tree NERDTreeFromBookmark ，nbNERD Tree NERDTreeFind ，nftab 新建一个标签页 ，tntab 关闭其他标签 ，totab 关闭标签 ，tctab 移动便签至指定标签之后 ，tmtab 打开指定标签 ，t，tab 打开最近访问的标签 ，tltab 打开新的标签页，新页的内容与当前页一致 ，tetab 打开上一标签 gTtab 打开下一标签 gtwindows 切换至左边窗口 Ctrl + hwindows 切换至下边窗口 Ctrl + jwindows 切换至上边窗口 Ctrl + kwindows 切换至右边窗口 Ctrl + lwindows 打开水平窗口 spwindows 打开垂直窗口 vswindows 关闭非激活窗口 onlywindows 将当前窗口移动到右侧 Ctrl + w Lwindows 将当前窗口移动到左侧 Ctrl + w Hwindows 将当前窗口移动到下面 Ctrl + w Jwindows 将当前窗口移动到上面 Ctrl + w Kwindows 关闭所有窗口 :qawindows 保存所有窗口 :wawindows 保存并关闭所有窗口 :wqawindows 放弃保存并关闭所有窗口 :qa!buffers 关闭当前 buffer ，bdbuffers 关闭所有 buffer ，babuffers 显示当前所有 buffers ，oAck 暂时不知道 ACK 怎么指定搜索路径，可以在 Vim 中通过 cd 命令进入指定目录再搜索 Ag 快速搜索 ，gAg 选取模式下，搜索选中的内容 gvAg 选取模式下，搜索并替换选中的内容 ，rAg 在新建窗口中显示结果 ，ccAg 未知 ，coAg 在新建窗口显示下一个搜索结果 ，nAg 在新建窗口显示上一个搜索结果 ，pbasic.vim 取消高亮 ，&lt;cr&gt;basic.vim 将工作目录指定为当前标签的路径 ，cdbasic.vim 前向搜索 spacebasic.vim 前向搜索光标所在单词 *basic.vim 后向搜索光标所在单词 #合并行 J撤销 u重做 Ctrl + r代码补全 Ctrl + N/P保存文件并退出 vi ZZ放弃更改并退出 vi :q!Goyo 开启 goyo 模式 ，z挂起 vim Ctrl + z恢复 vim fg执行 shell 命令 ！ 动作：文本对象 光标向前移动到下一个单词的词首 w动作：文本对象 光标向后移动到上一个单词的词首 b动作：文本对象 光标向前移动到下一个单词的词末 e动作：文本对象 光标向后移动到上一个单词的词末 ge动作：文本对象 光标向前移动到下一个字串的词首 W动作：文本对象 光标向后移动到上一个字串的词首 B动作：文本对象 光标向前移动到下一个字串的词末 E动作：文本对象 光标向后移动到上一个字串的词末 gE动作：左右 至当前行（加上 N-1 后续行）的行尾 N $动作：左右 至屏幕行（加上 N-1 后续行）的行尾 N g$动作：左右 至当前行的第一个非空字符 ^动作：左右 至屏幕行的第一个非空字符 g^动作：左右 至当前行的第一个字符 0动作：左右 至屏幕行的第一个字符 g0动作：左右 至屏幕行的中点 gm动作：左右 至第 N 列 N |动作：左右 至右边第 N 次出现 &#123;char&#125; 之处——find N f&#123;char&#125;动作：左右 至左边第 N 次出现 &#123;char&#125; 之处——Find N F&#123;char&#125;动作：左右 至右边第 N 次出现 &#123;char&#125; 之前——till N t&#123;char&#125;动作：左右 至左边第 N 次出现 &#123;char&#125; 之前——Till N T&#123;char&#125;动作：左右 重复上次 f、t、F、T 命令 N 次 N ;动作：左右 反方向重复上次 f、t、F、T 命令 N 次 N ,移动到匹配的括号上 %移动到第 n 行 nG移动到第一行 gg移动到最后一行 G移动到视野中接近上方的行 H移动到视野中中部的行 M移动到视野中接近下方的行 L向下滚动一行 Ctrl + y向上滚动一行 Ctrl + e向下滚动一屏 Ctrl + f向上滚动一屏 Ctrl + b向下滚动半屏 Ctrl + d向上滚动半屏 Ctrl + u滚动屏幕使当前行成为靠上的行 zt滚动屏幕使当前行成为靠下的行 zb滚动屏幕使当前行成为靠中的行 zz前向查找字符串 /反向查找字符串 ?重复前一次查找 n反方向重复前一次查找 N设置查找时忽略大小写 :set ignorecase设置查找时大小写敏感 :set noignorecase查找上一次字符串 /&lt;up&gt;查找上一次以 a 开头的字符串 /a&lt;up&gt;向前查找光标下的单词 *向后查找光标下的单词 #查找整个单词 the，其中 \&lt;、\&gt; 分别匹配单词的开头和结尾 /\&lt;the\&gt;查找处于行尾的 the /the$查找处于行首的 the /^the查找 com 或者 cam /c.m查找 .com /\.com在两个位置间跳转，跳转指的是移动到本行以外的命令，但是不包括 j、k 命令 &apos;&apos;跳转至函数定义 Ctrl + ]跳转至一个较新的位置 Ctrl + o跳转至一个较旧的位置 Ctrl + i输出可以跳往的位置 :jumps增加书签，参数可以选择 26 个字母，所以最多可以设置 26 个书签 ma跳转至书签 &apos;a跳转至最近编辑的光标位置 ,&quot;跳转至最近修改的开始位置 ,[跳转至最近修改的结束位置 ,]删除一整行 dd删除 4 个单词 d4w从当前位置一直删除到本行末尾 d$删除一个单词并切换到插入模式 cw修改一整行 cc删除当前光标下的字符，表示 dl x删除光标左边的字符，表示 dh X删除当前位置到行尾，表示 d$ D修改当前位置到行尾，表示 c$ C修改一个字符，表示 c1 s修改一整行，表示 cc S替换一个字符 r修改光标下字符的大小写，并移动到下一个字符 ~使多个字符被同一个字符 x 替换 5rx重复同一个修改 .将 int 型替换为 s32_t /int cws32_t&lt;esc&gt; n .切换至可视模式 v切换至可视模式，按行选择 V切换至可视模式，按列选择 Ctrl + V可视模式下，进行批量插入，编辑完后&lt;ESC&gt;&lt;CR&gt;可完成批量修改 I可视模式下，移动光标至对角上 o可视模式下，移动光标至同一行的另一个角上 O切换至插入模式，在光标前插入字符 i切换至插入模式，在当前行的第一个非空字符处插入 I切换至插入模式，在当前行的末尾插入字符 A切换至插入模式，在光标下方建立一个新的空行 o切换至插入模式，在光标上方建立一个新行 O切换至替换模式 R在插入模式和替换模式间切换 &lt;Insert&gt;在替换模式下，取消上一个替换的字符 &lt;BS&gt;可视模式下，添加 () 1可视模式下，添加 [] 2可视模式下，添加 &#123;&#125; 3可视模式下，添加 &quot;&quot; $$可视模式下，添加 &apos;&apos; $q粘贴至光标前，如果拷贝内容为一行则表示粘贴至前一行 P粘贴至光标后，如果拷贝内容为一行则表示粘贴至后一行 p交换当前光标及下一个字符 xp交换当前光标及下一个字符 Xp拷贝一整行 Y/yy拷贝单词及其后面的空白符 yw拷贝单词不包含后面的空白符 ye拷贝光标所在单词 yaw拷贝光标所在单词，不包含单词后的空格 yiw拷贝光标所在的 () 内的部分 ya(拷贝光标所在的 () 内的部分，不包含括号 yi(拷贝光标所在的 [] 内的部分 ya[拷贝光标所在的 [] 内的部分，不包含括号 yi[拷贝光标所在的 &#123;&#125; 内的部分 ya&#123;拷贝光标所在的 &#123;&#125; 内的部分，不包含括号 yi&#123;cscope find all references to the token under cursor CTRL-\ scscope global: find global definition(s) of the token under cursor CTRL-\ gcscope calls: find all calls to the function name under cursor CTRL-\ ccscope text: find all instances of the text under cursor CTRL-\ tcscope calls: find all calls to the function name under cursor CTRL-\ ecscope egrep: egrep search for the word under cursor CTRL-\ fcscope includes: find files that include the filename under cursor CTRL-\ icscope called: find functions that function under cursor calls CTRL-\ dcscope 在新建水平窗口打开 CTRL-\ hscscope 在新建垂直窗口打开 CTRL-\ vscscope 设置 cscope 从右边打开新建垂直窗口 :set splitrightcscope 设置结果显示至 quickfix 窗口 h cscopequickfixctrlp 设置 ctrlp 垂直分割打开窗口，防止和粘贴重复 let g:ctrlp_prompt_mappings = &#123; &apos;AcceptSelection(&quot;v&quot;)&apos;: [&apos;&lt;c-g&gt;&apos;] &#125;ctrlp 查看基本操作帮助 :h ctrlp-mappings打开命令行窗口 q:保存上一次会话 https://github.com/tmuxinator/tmuxinatorman 快速打开 man 帮助 :source $VIMRUNTIME/ftplugin/man.vim:nmap K :Man &lt;c-r&gt;&lt;c-w&gt;&lt;cr&gt;:echo $VIMRUNTIME 修改 man.vim 中的 new 为 vnewTumx从 window 连接 Ubuntu, 实在不喜欢太多窗口，只能用 Tmux 了参考http://www.cnblogs.com/congbo/archive/2012/08/30/2649420.htmlJupyter帮助：hWindows激活任务栏第 N 个任务：Win + 数字 极其常用Mac常用删除：command + del打开强制退出窗口：Command + Option + esc切换：Command + Tab截图截取全屏至文件：Command + Shift + 3截取全屏到剪贴板：Command + Shift + Control + 3截取所选屏幕区域到文件，或按空格键截取窗口：Command + Shift + 4截取所选屏幕区域到剪贴板，或按空格键截取窗口：Command + Shift + Control + 4Finder新建文件夹：Command + Shift + N调出直达窗口：Command + Shift + G重命名文件：Enter进入文件：Command + O剪切：Command + Option + V进入上级目录：Command + 上箭头删除：Command + Delete清倒废纸篓：Command + Shift + Delete预览：空格chrome光标直接跳至地址栏：Command + l转向下一个标签页：Control + Tab转向上一个标签页：Control + Shift + Tab放大页面：Command + 加号或等号缩小页面：Command + 减号zsh说实在的行编辑功能不如 shell, 比如删除单词、向前向后按单词移动移动移动到行首：ctrl + a移动到行尾：ctrl + e移动到前一个字符：ctrl + f移动到前一个字符：ctrl + b编辑剪切当前光标的字符：ctrl + d剪切光标之前的字符：ctrl + h剪切光标之前的单词：ctrl + w剪切整行：ctrl + u （本来 ctrl + u 是删至命令行首，但 iterm 中是删掉整行）剪切至行末尾：ctrl + k粘贴至光标后：ctrl + y交换光标处文本：ctrl + t历史上一条命令历史：ctrl + p下一条命令历史：ctrl + n搜索命令历史：ctrl + r其他清屏：ctrl + l]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>汇总</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用操作汇总]]></title>
    <url>%2F2017%2F11%2F11%2Fuseful_operate.html</url>
    <content type="text"><![CDATA[汇总一些琐碎的，非快捷键的操作，当某个工具的操作过多时再独立为一篇博客mac窗口切换原生的 MAC 窗口切换简直无法直视，最简单的一点，多个 Chrome 窗口都无法切换，于是找到两款不错的工具snap: 实现 Command + num 打开 DockHyperSwitch: 实现 Command + ` 切换同一个进程的多个窗口命令结果粘贴至剪切板ls |pbcopyjupyter.ipynb 转 .md1jupyter nbconvert --to markdown README.ipynb生成 jupyter 配置文件1jupyter notebook --generate --allow-root生成 ipython 配置文件1ipython profile createjupyter 取消密码编辑 /root/.jupyter/jupyter_notebook_config.py，然后重启 jupyter1c.NotebookApp.token = '';主题设置jt -t grade3 -fs 11 -nfs 12 -tfs 12 -tf sourcesans -nf sourcesans -cellw 88% -altp -f source显示多行结果修改前12345line1 = "this is from line 1"line2 = "this is from line 2"line1line2‘this is from line 2’修改永久生效，编辑.ipython/profile_default/ipython_config.py，然后重启 jupyter12ipython profile create # 如果没有默认配置文件， 则生成一个新的c.InteractiveShell.ast_node_interactivity = 'all'修改临时生效12from IPython.core.interactiveshell import InteractiveShellInteractiveShell.ast_node_interactivity = "all"修改后12345line1 = "this is from line 1"line2 = "this is from line 2"line1line2‘this is from line 1’‘this is from line 2’chrome分析网页加载速度在 chrome 流量器中按 F12 或者单击鼠标右键 -&gt;检查，打开调试栏 -&gt;Network, 刷新网页就可以看到以下信息了 -vimvim 粘贴格式错误最方便的方法就是在.vimrc 中加一句：set pastetoggle=以后在插入模式下，只要按 F9 键就可以切换自动缩进。无法 undo如果文件名中包含中文，则无法 undo保存折叠.vimrc 添加以下12au BufWinLeave *.* mkviewau BufWinEnter *.* silent loadview文本替换替换当前行中的内容替换第一个匹配项：:s/from/to/替换所有匹配项：:s/from/to/g替换所有匹配项，替换前需确认：:s/from/to/gc注意：这里的 from 和 to 都可以是任何字符串，其中 from 还可以是正则表达式替换某一行的内容当前行：:.s/from/to/g第 33 行：33s/from/to/g最后一行：:$s/from/to/g替换某些行的内容[10 行，20 行』: :10,20s/from/to/g[1 行，最后一行』: :1,$s/from/to/g[1 行，当前行』: :1,.s/from/to/g『当前行，最后一行』: :.,$s/from/to/g『标记 a 所在行，标记 b 所在行』: :&#39;a,&#39;bs/from/to/g所有行：:%s/from/to/g特殊情况替换空格为换行符 :s/ /\r/g替换命令的完整形式完整语法：:[range]s/from/to/[flags]s/from/to/ 表示 from 替换成 to, from 可以是正则表达式：[range] 可以为：光标所在的行：不写 range光标所在的行：.所有行：%第一行：1最后一行：$第 33 行：33标记 a 所在的行：&#39;a光标所在行的下一行：.+1光标所在行的上一行：$-1第 22 ~ 33 行：22,33第 1 行 ~ 最后一行：1,$第 1 行 到 当前行：1,.当前行 到 最后一行：.,$标记 a 所在的行 到 标记 b 所在的行：&#39;a,&#39;b从当前位置向上搜索，找到的第一个 chapter 所在的行：?chapter?从当前位置向下搜索，找到的第一个 chapter 所在的行：/chapter/注意，上面的所有用于 range 的表示方法都可以通过 +、- 操作来设置相对偏移量[flags] 可以为：替换第一个：无替换所有：g要求确认：c忽略错误：e注意：上面的所有 flags 都可以组合起来使用，比如 gc 表示对指定范围内的所有匹配项进行替换，并且在每一次替换之前都会请用户确认插入命令输出1:r !command内容排序选中需要排序的文本，执行 :sort1234:sort! 对全文逆序排列:sort u 对全文排序并去除重复行:sort! u 对全文逆序排列并去除重复行:sort i 对全文排序同时忽略大小写Linuxxsel 剪切板将 ls 命令输出的结果放入剪切板1ls |xsel]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>汇总</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法示例]]></title>
    <url>%2F2017%2F11%2F11%2Fhello-world.html</url>
    <content type="text"><![CDATA[本篇博文不仅仅包含 Markdown 基础语法，也有 Hexo 定义的一些标签，主要是自己 copy 起来方便，所有的章节一定是语法 + 示例，不用怀疑标题markdown 标题语法，# 号个数代表标题级别12345## 二级标题示例### 三级标题示例#### 四级标题示例##### 五级标题示例###### 六级标题示例二级标题示例三级标题示例四级标题示例五级标题示例六级标题示例列表无序列表懒得记，无序列表我只用 * 开头12345* 一级无序列表 * 二级无序列表 * 三级无序列表 * 四级无序列表* 一级无序列表一级无序列表二级无序列表三级无序列表四级无序列表一级无序列表有序列表有序列表以 1. 2. 3. 开头，注意第四行，真实显示的需要是自动生成的123451. 一级有序列表 1. 二级有序列表 2. 三级有序列表 4. 注意序号是自动生成的2. 有序列表一级有序列表二级有序列表二级有序列表注意序号是自动生成的有序列表待办列表语法应该就是 - [x] 开头的行1234- [x] @mentions, #refs, [links](), **formatting**, and &lt;del&gt;tags&lt;/del&gt; are supported - [x] list syntax is required (any unordered or ordered list supported) - [x] this is a complete item - [ ] this is an incomplete item@mentions, #refs, links, formatting, and tags are supportedlist syntax is required (any unordered or ordered list supported)this is a complete itemthis is an incomplete item引用标准引用引用以一个或多个 &gt; 开头，注意第四行的空行，如果没有空行第五行也会是三级引用12345&gt; 这是一级引用&gt;&gt; 这是二级引用&gt;&gt;&gt; 这是三级引用&gt; 这是一级引用这是一级引用这是二级引用这是三级引用这是一级引用centerquote 标签非常适合单行的引用，比较好看1&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125;blah blah blahblockquote 标签123&#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&#125;Every interaction is both precious and an opportunity to delight.&#123;% endblockquote %&#125;Every interaction is both precious and an opportunity to delight.Seth GodinWelcome to Island Marketingnote 标签1&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125;其中，class_name 可以是以下列表中的一个值：defaultprimarysuccessinfowarningdanger123&#123;% note warning %&#125;举个例子&#123;% endnote %&#125;举个例子代码块用 ``` 包围起来的就是代码块，这个没法演示，这里展示使用标签的方式，下面是代码标签的语法123&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125;举两个例子：最简单的例子123&#123;% codeblock %&#125;print(&apos;Hello World!&apos;);&#123;% endcodeblock %&#125;效果如下：1print(&apos;Hello World!&apos;);附加说明和网址，其中 [title] 是 compact, [lang:language] 是 lang:objc, [url] 是 http://underscorejs.org/#compact [link text] 是 Underscore.js123&#123;% codeblock lang:objc compact http://underscorejs.org/#compact Underscore.js %&#125;[rectangle setX: 10 y: 10 width: 20 height: 20];&#123;% endcodeblock %&#125;效果如下：compactUnderscore.js1[rectangle setX: 10 y: 10 width: 20 height: 20];链接行内式链接行内式链接的语法结构为 [链接的描述](link &quot;鼠标放到链接上后的提示&quot;)1这就是行内链接：[李阿昀的简书](http://www.jianshu.com &quot;李阿昀的简书&quot;)这就是行内链接：李阿昀的简书参考式链接12341. [李阿昀的简书][1]2. [Hexo 中文文档][2][1]: &lt;http://www.jianshu.com/p/250e36bb5690#fn_lemma_footer&gt;[2]: &lt;https://hexo.io/zh-cn/docs/tag-plugins.html&gt;李阿昀的简书Hexo 中文文档自动链接用 &lt;&gt; 包围的就是自动链接，没有 http 就不会显示12&lt;http://example.com/&gt;&lt;example.com/&gt;http://example.com/博客内部链接1&#123;% post_link &quot;Hash_implement&quot; %&#125;Hash 实现1&#123;% post_link &quot;hello-world&quot; &quot;Deploy to remote sites&quot; %&#125;Deploy to remote sites锚点点击位置1[点击跳转](#jump)目标位置1&lt;span id=&quot;jump&quot;&gt;跳转到的地方&lt;/span&gt;可以看到 jump 关联了点击位置和目标位置点击跳转图片插入图片与插入链接的语法很像，区别在一个！号，而且也有行内式和参考式两种。行内式图片行内式优势在于简单，图片语法为：![无法显示图片时的说明](图片地址或者链接 &quot;鼠标悬停提示&quot;)显示链接图片1![图灵社区](http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg)显示失效链接图片1![图灵社区](http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg1)显示本地图片1![github](/images/github-page.png)参考式图片参考式优势在于可以多次引用网址，类似声明 Constant 变量，参考式图片我没有找到使用本地图片的办法12![链接图片][3][3]: http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg标签显示图片标签显示图片的语法1&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125;基础应用1&#123;% img &apos;/images/github-page.png&apos; %&#125;标签放大显示图片优势是可以强调图片显示1&#123;% fi &apos;/images/github-page.png&apos;, alt, title %&#125;字体 / 行内代码 / 删除线使用**表示粗体，使用*表示斜体。符号和文字间不能有空格使用 `` 包围表示行内代码使用 ~~ 包围表示删除线123456**粗体***斜体*~~删除线~~*~~斜体删除线~~*``行内代码``普通字体粗体斜体删除线斜体删除线行内代码普通字体表格用|表示表格纵向边界，表头和表内容用 - 隔开，并可用：进行对齐设置，两边都有：则表示居中，若不加：则默认左对齐。详细说明：----:为右对齐:----为左对齐:---:为居中对齐-----为默认左对齐正常的表格12345dog | bird | cat----|------|----foo | foo | foobar | bar | barbaz | baz | bazdogbirdcatfoofoofoobarbarbarbazbazbaz复杂的表格12345| 序号 | 交易名 | 交易说明 | 备注 || ---: | :----: | :------- | ---- || 1 | prfcfg | 菜单配置 | 可以通过此交易查询到所有交易码和菜单的对应关系 || 2 | gentmo | 编译所有交易 | || 100000 | sysdba | 数据库表模型汇总 | |序号交易名交易说明备注1prfcfg菜单配置可以通过此交易查询到所有交易码和菜单的对应关系2gentmo编译所有交易100000sysdba数据库表模型汇总表格中插入 | 和代码块12345语法 | 说明----- | -----`a += x;` | 表格中插入代码a &amp;#124;= y; | 表格中插入 &amp;#124;&lt;code&gt;a &amp;#124;= y;&lt;/code&gt; | 表格代码中插入 &amp;#124;语法说明a += x;表格中插入代码a &#124;= y;表格中插入 &#124;a &#124;= y;表格代码中插入 &#124;设置表格宽度123456789101112131415161718192021&lt;style&gt;table th:nth-of-type(1) &#123; width: 100px;&#125;table th:nth-of-type(2) &#123; width: 300px;&#125;table th &#123; font-weight: bold; /*加粗*/ font-size: 12pt; text-align: center !important; /*内容居中，加上 !important 避免被 Markdown 样式覆盖*/ background: rgba(158,188,226,0.2); /*背景色*/&#125;&lt;/style&gt;|别名 | 命令 ||-------------- |--------------------- ||g | git ||ga | git add ||gaa | git add --all ||gapa | git add --patch |table th:nth-of-type(1){width:100px}table th:nth-of-type(2){width:300px}table th{font-weight:700;font-size:12pt;text-align:center!important;background:rgba(158,188,226,.2)}别名命令ggitgagit addgaagit add –allgapagit add –patch分割线使用---表示分割线，其他形式不管1---LaTeX 公式行内公式$ 表示行内公式1质能方程 $E=mc^2$质能方程 $E=mc^2$整行公式$$ 表示整行公式1$$\sum_&#123;i=1&#125;^n a_i=0$$$$\sum_{i=1}^n a_i=0$$访问 MathJax 参考更多使用方法。暂不使用的高级特性内嵌图标，更多的图标和玩法可以参看 font-awesome 官方网站。定义型列表注脚流程图，更多语法参考：流程图语法参考序列图，更多语法参考：序列图语法参考参考跳转到的地方李阿昀的简书Hexo 中文文档Github Page 官方帮助作业部落]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Github + Hexo 搭建个人博客]]></title>
    <url>%2F2017%2F11%2F11%2FGithub%2BHexo_BLOG.html</url>
    <content type="text"><![CDATA[Github 让个人技术博客的创建变得异常简单，Hexo 框架 + Next 主题提供了高度定制且美观的个人博客，本文记录了搭建过程Hexo 与 jekyll 框架的选择经过两天的折腾，彻底放弃使用 jekyll 搭建自己的技术 Blog, 究其原因就是目录、sitemap 无法自动生成，一个没有前端开发经验的我最终发现 Hexo。Hexo 能够满足我对 Blog 的所有想法：1、我只负责写内容，至于文章的按标签分类还是按日期归档我都不关心，但是我需要使用这些功能2、文章要有一个漂亮的内容导航栏，开发做多了，对始终能在一屏内了解当前文件的整体结构有着某种偏执3、sitemap、文章目录最好能够复用网页位置，以便留出更多的位置显示正文，尽量少的翻页绝对能提升生产效率个人博客搭建依次安装 git、node.js、hexo、next 主题安装 git官网 描述的很清楚我最常用的是 Ubuntu，只需要执行以下命令即可：1apt-get install git安装 node.js一开始，我以为使用的 Ubuntu-16.04LTS 已经很新了，所以就直接使用 apt-get 安装了，结果在安装 hexo 时出现错误。网上整了一堆高级方法都没能解决。最终参考 node.js 官网，直接 download 官方的首页的最新的 LTS 版本 node-v6.11.3-linux-x64.tar.xz，解压至 /usr 目录1tar -vxf node-v6.11.3-linux-x64.tar.xz -C /usr/默认 hexo 安装的位置与 npm 一致，所以如果没有把 npm 所在路径加入环境变量，则安装 hexo 后会发现无法找到 hexo 命令，所以建议将 node.js 的安装路径加入 ~/.bashrc1echo 'export PATH="/usr/node-v6.11.3-linux-x64/bin:$PATH' &gt;&gt; ~/.bashrc如果你和我一样使用 zsh，就放到 ~/.zshrc 中1echo 'export PATH="/usr/node-v6.11.3-linux-x64/bin:$PATH' &gt;&gt; ~/.zshrc添加环境变量后记得 source12source ~/.bashrcsource ~/.zshrc安装 hexo创建一个目录，比如 hexo_dir, 用于安装 hexo, 通过 npm 命令安装 hexo123mkdir hexo_dircd hexo_dirnpm install -g hexo-cli安装 next 主题hexo 的安装路径下有一个 themes 目录，hexo 默认会使用该目录下的主题，所以一定要在 hexo 安装目录下执行1git clone https://github.com/iissnan/hexo-theme-next themes/next如果你想能够更新 next 主题，且又想通过 github 管理你的主题定制信息，那么需要麻烦一些，可以参考下面的 多平台共同编辑博客Github 创建博客只需要在 github 上创建 用户名 +github.io 的 Repo 即可创建成功后，就可以通过 https:// 用户名.github.io/ 访问了，比如我就是通过 https://jiexiao111.github.io/ 访问站点配置文件修改在 hexo 安装目录下可以找到 config.yml 文件，这个文件就是站点配置文件，修改站点配置文件后，需要重起 hexo 服务，才能生效1hexo s启用 next 主题编辑站点配置文件1theme: next验证 next 主题，在 hexo 安装目录下执行 hexo s –debug，如果未出现错误，则在浏览器中访问以下位置1http://localhost:4000/修改默认标题、子标题、描述、作者、字符集编辑站点配置文件123456# Sitetitle: JieXiao's Blogsubtitle:description:author: JIE XIAOlanguage: zh-Hans主题配置文件修改hexo 目录下的 themes/next/ 子目录中也有一个 config.yml 文件，这个文件就是主题配置文件，修改主题配置文件后立即生效，无需重启 hexo 服务修改 Next 主题风格个人偏向于在一屏内显示更多的内容所以选择了 Mist 风格12345# Schemes# scheme: Musescheme: Mist# scheme: Pisces# scheme: Gemini设置侧边栏Next 主题的文章目录导航和作者介绍复用了侧边栏，非常不错123sidebar: position: left display: always修改字体12345678910111213141516171819202122232425262728293031font: enable: true # 外链字体库地址，例如 //fonts.googleapis.com （默认值） host: # 全局字体，应用在 body 元素上 global: external: true family: Monda # 标题字体 (h1, h2, h3, h4, h5, h6) headings: external: true family: Roboto Slab # 文章字体 posts: external: true family: # Logo 字体 logo: external: true family: Lobster Two size: 24 # 代码字体，应用于 code 以及代码块 codes: external: true family: PT Mono修改代码风格1highlight_theme: night侧边栏中增加社交信息123456social: GitHub: https://github.com/jiexiao111 E-Mail: mailto:jiexiao111@gmail.comsocial_icons: GitHub: github E-Mail: email开启背景动画1canvas_nest: true开启公式显示12mathjax: enable: true开启访问统计123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; 访问 site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 浏览 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; 阅读 page_pv_footer:第三方插件安装主要包括本地搜索服务、git 部署本地搜索插件考虑到博文多了以后方便自己查阅，搜索功能必不可少安装 searchdb1npm install hexo-generator-searchdb --save修改主题配置文件123# Local searchlocal_search: enable: true修改站点配置文件12345search: path: search.xml field: post format: html limit: 10000git 部署插件安装1npm install hexo-deployer-git --save修改站点配置文件1234deploy: type: git repository: git@github.com:jiexiao111/jiexiao111.github.io.git branch: master部署命令使用1hexo deploy压缩网页插件安装 hexo-neat1npm install hexo-neat --save修改站点配置，增加以下信息12345678910111213141516171819# hexo neat configneat_enable: trueneat_html: enable: true exclude:neat_css: enable: true exclude: - '*.min.css'neat_js: enable: true mangle: true output: compress: exclude: - '*.min.js'留言插件http://barrysite.me/2017/05/08/hexo%E7%BD%91%E7%AB%99NexT%E4%B8%BB%E9%A2%98%E5%A2%9E%E5%8A%A0%E7%95%99%E8%A8%80%E9%A1%B5/多平台共同编辑博客通常我们需要在多个环境下，编辑 / 发布博客生成秘钥git 官方帮助 描述的非常清楚，如果是 Linux 系统，首先通过命令生成秘钥，注意下面命令中的 jiexiao111@gmail.com 是你注册 github 时的邮箱1ssh-keygen -t rsa -C jiexiao111@gmail.com想办法把下面这个文件的内容拷贝出来1~/.ssh/id_rsa.pub然后打开你的 github 主页，依次点击 Settings-&gt;SSH and GPG keys-&gt;New SSH key, 然后 Title 随便取个名字，再把 ~/.ssh/id_rsa.pub 中的内容拷贝到 Key 中，Add SSH key 完成添加新建 repo 用于保存站点配置在 github 中新建 repo, 进入 hexo 安装目录，将以下文件 / 目录同步至 repo123456README.md_config.ymlpackage.jsonscaffoldssourcethemesfork Next 主题用于保存主题配置为了能够随时更新 Next 主题，又能保存自己的主题配置及相关修改，可以参考同步一个 fork 或者官方帮助第一步，fork Next 主题第二步，进入 hexo 的安装目录，将 fork 好的 Next 主题 clone 到本地，注意 hexo 目录下应该是默认存在 themes 目录的1git submodule add git@github.com:jiexiao111/hexo-theme-next.git themes/next第三步，进入 themes/next 目录，增加上游仓库12cd themes/nextgit remote add upstream https://github.com/iissnan/hexo-theme-next.git第四步，通过 git remote -v 确认执行结果正确12345$ git remote -vorigin git@github.com:jiexiao111/hexo-theme-next.git (fetch)origin git@github.com:jiexiao111/hexo-theme-next.git (push)upstream https://github.com/iissnan/hexo-theme-next.git (fetch)upstream https://github.com/iissnan/hexo-theme-next.git (push)第五步，获取变更（获取 next 主题最新的修改），切换到 master（一般不需要切换，可以通过 git branch 看到应该是处于 master 分支），合并更改（获取 next 主题主线版本的最新修改），最后把修改推送到 fork 的分支里1234git fetch upstreamgit checkout mastergit merge upstream/mastergit push origin master在新的环境上部署安装 git、node.js、hexo 后clone hexo 相关配置1git clone --recursive git@github.com:jiexiao111/hexo_jiexiao.git安装相关插件12cd hexo_jiexiaonpm install测试新环境的部署功能1hexo d -g其他设置及常用操作一些不好分类但是非常有用的设置及操作设置正文页面宽度编辑 hexo_dir/themes/next/source/css/_variables/custom.styl12345// 修改成你期望的宽度$content-desktop = 1000px// 当视窗超过 1600px 后的宽度$content-desktop-large = 1400px解决网页分类 / 标签显示错误1234rm db.jsonhexo cleanhexo ghexo s创建分类和标签在 hexo 安装目录下执行以下命令，用于增加标签和分类目录12hexo new page tagshexo new page categories在生成的文件中分别写入以下信息12345678910111213cat &gt; source/tags/index.md---title: tagsdate: 2017-09-10 12:21:49type: "tags"---cat &gt; source/categories/index.md---title: categoriesdate: 2017-09-10 12:25:38type: "categories"---使用 chrome 分析网页加载速度在 chrome 流量器中按 F12 或者单击鼠标右键 -&gt;检查，打开调试栏 -&gt;Network, 刷新网页就可以看到以下信息了Hexo 框架及 Next 主题相关文档链接提供一些高质量的链接，便于参考Hexo 的官方文档，满满的诚意next 官方文档，进去就充满了好感从 jekyll 转换到 hexo 多亏了下面这篇文章]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 性能分析]]></title>
    <url>%2F2017%2F11%2F08%2Fpython-perf.html</url>
    <content type="text"><![CDATA[预处理过程中，如果出现非常慢的情况，通常需要进行性能剖析cProfile 使用装饰器实现以下是从网上抄的装饰器123456789101112131415161718192021222324252627import cProfileimport pstatsimport os# 性能分析装饰器定义def do_cprofile(filename): """ Decorator for function profiling. """ def wrapper(func): def profiled_func(*args, **kwargs): # Flag for do profiling or not. DO_PROF = os.getenv("PROFILING") if DO_PROF: profile = cProfile.Profile() profile.enable() result = func(*args, **kwargs) profile.disable() # Sort stat by internal time. sortby = "tottime" ps = pstats.Stats(profile).sort_stats(sortby) ps.dump_stats(filename) else: result = func(*args, **kwargs) return result return profiled_func return wrapper装饰器使用装饰器的使用，下面的修改将使程序的 perf 信息保存至 mkm_run.prof 文件123# 应用装饰器来分析函数@do_cprofile("./mkm_run.prof")def run(self, **kwargs):需要注意的是，使用前需要导入环境变量，即，执行 pytyon 脚本前，执行一下 shell 指令1export PROFILING=y实际问题举例之前遇到一个实际的问题，我在读取 5W 个脚本进行预处理的时候，预计执行时间为 80 小时，使用 cProfile 分析后，发现根因是因为 5W 个文件是 mount 的远程目录，网络条件不好，导致处理非常缓慢，下面是我用于复现的简化代码，借此我们看看用 cProfile 是怎么描述这个问题的1234567891011import os# 读取 10 个文件的信息def test(dir_path): tmp = [] dir_child = os.walk(dir_path) for x in range(10): tmp.append(next(dir_child)) print(len(tmp))test('/root/workspace/ruby_data_local/')通过 time 查看，我仅仅是读取了 10 文件信息就使用了 5.675s123$ time python tmp.py10python tmp.py 0.07s user 0.01s system 1% cpu 5.675 total结合 cProfile 具体分析，看看输出是什么样子，以下是完整代码：12345678910111213141516171819202122232425262728293031323334353637import osimport cProfileimport pstats# 性能分析装饰器定义def do_cprofile(filename): """ Decorator for function profiling. """ def wrapper(func): def profiled_func(*args, **kwargs): # Flag for do profiling or not. DO_PROF = os.getenv("PROFILING") if DO_PROF: profile = cProfile.Profile() profile.enable() result = func(*args, **kwargs) profile.disable() # Sort stat by internal time. sortby = "tottime" ps = pstats.Stats(profile).sort_stats(sortby) ps.dump_stats(filename) else: result = func(*args, **kwargs) return result return profiled_func return wrapper@do_cprofile("./mkm_run.prof")def test(dir_path): tmp = [] dir_child = os.walk(dir_path) for x in range(10): tmp.append(next(dir_child)) print(len(tmp))test('/root/workspace/ruby_data/')执行 export PROFILING=y; python tmp.py, 执行后，会生成分析文件 mkm_run.prof, 然后启动 ipython 查看具体信息：12345678910111213141516171819202122232425262728293031323334353637In [1]: import pstatsIn [2]: p = pstats.Stats(&quot;./mkm_run.prof&quot;)In [3]: p.sort_stats(&apos;cumtime&apos;).print_stats(10, 1.0, &apos;.*&apos;)Wed Nov 8 20:11:57 2017 ./mkm_run.prof 501 function calls (352 primitive calls) in 5.813 seconds Ordered by: cumulative time List reduced from 18 to 10 due to restriction &lt;10&gt; ncalls tottime percall cumtime percall filename:lineno(function) 1 0.000 0.000 5.813 5.813 tmp.py:30(test) 125/10 2.906 0.023 5.813 0.581 &#123;built-in method builtins.next&#125; 51/17 0.001 0.000 5.813 0.342 os.py:277(walk) 9 0.000 0.000 2.129 0.237 posixpath.py:166(islink) 9 2.129 0.237 2.129 0.237 &#123;built-in method posix.lstat&#125; 10 0.775 0.078 0.775 0.078 &#123;built-in method posix.scandir&#125; 9 0.001 0.000 0.001 0.000 posixpath.py:73(join) 1 0.000 0.000 0.000 0.000 &#123;built-in method builtins.print&#125; 105 0.000 0.000 0.000 0.000 &#123;method &apos;is_dir&apos; of &apos;posix.DirEntry&apos; objects&#125; 9 0.000 0.000 0.000 0.000 posixpath.py:39(_get_sep)Out[3]: &lt;pstats.Stats at 0x7feb240e7d68&gt;In [4]: p.print_callees(&quot;test&quot;) Ordered by: cumulative time List reduced from 18 to 1 due to restriction &lt;&apos;test&apos;&gt;Function called... ncalls tottime cumtimetmp.py:30(test) -&gt; 1 0.000 0.000 &#123;built-in method builtins.len&#125; 10 0.000 5.813 &#123;built-in method builtins.next&#125; 1 0.000 0.000 &#123;built-in method builtins.print&#125; 10 0.000 0.000 &#123;method &apos;append&apos; of &apos;list&apos; objects&#125;其中 p.sort_stats(&#39;cumtime&#39;).print_stats(10, 1.0, &#39;.*&#39;) 输出的信息表示以下含义：ncalls：表示函数调用的次数；tottime：表示指定函数的总的运行时间，除掉函数中调用子函数的运行时间；percall：（第一个 percall）等于 tottime/ncalls；cumtime：表示该函数及其所有子函数的调用运行的时间，即函数开始调用到返回的时间；percall：（第二个 percall）即函数运行一次的平均时间，等于 cumtime/ncalls；filename:lineno(function)：每个函数调用的具体信息可以看出 tmp.py 文件中的第 30 行的 test 函数占用了 5.813s 时间，然后，执行 p.print_callees(&quot;test&quot;) 查看 test 函数调用了哪些函数，发现耗时的就是 walk 函数 返回的迭代器的 next 调用，于是就找到了性能瓶颈。pstats 使用1234567891011121314151617181920212223import pstats# 创建 Stats 对象p = pstats.Stats("result.out")# strip_dirs(): 去掉无关的路径信息# sort_stats(): 排序，支持的方式和上述的一致# print_stats(): 打印分析结果，可以指定打印前几行# 和直接运行 cProfile.run("test()") 的结果是一样的p.strip_dirs().sort_stats(-1).print_stats()# 按照函数名排序，只打印前 3 行函数的信息，参数还可为小数，表示前百分之几的函数信息p.strip_dirs().sort_stats("name").print_stats(3)# 按照运行时间和函数名进行排序p.strip_dirs().sort_stats("cumulative", "name").print_stats(0.5)# 如果想知道有哪些函数调用了 sum_nump.print_callers(0.5, "sum_num")# 查看 test() 函数中调用了哪些函数p.print_callees("test")分析数据可视化首先，安装两个包pip install gprof2dotbrew install graphviz如果是 Ubuntu 的话就是 apt-getapt-get install graphviz接下来就可以执行 gprof2dot -f pstats mkm_run.prof | dot -Tpng -o mkm_run.png, 得到下面这幅图了line_profiler第一步，安装 pip install line_profiler第二步，在代码中加入 @profile 装饰器，完整代码如下：1234567891011import os@profiledef test(dir_path): tmp = [] dir_child = os.walk(dir_path) for x in range(10): tmp.append(next(dir_child)) print(len(tmp))test('/root/workspace/ruby_data/')第三步，执行 kernprof.py -l -v tmp.py1234567891011121314151617$ kernprof -l -v tmp.pyWrote profile results to tmp.py.lprofTimer unit: 1e-06 sTotal time: 5.1088 sFile: tmp.pyFunction: test at line 30Line # Hits Time Per Hit % Time Line Contents============================================================== 30 @profile 31 def test(dir_path): 32 1 4 4.0 0.0 tmp = [] 33 1 12 12.0 0.0 dir_child = os.walk(dir_path) 34 11 76 6.9 0.0 for x in range(10): 35 10 5108549 510854.9 100.0 tmp.append(next(dir_child)) 36 1 159 159.0 0.0 print(len(tmp))可以很明显的看出 35 行为主要的性能瓶颈参考Python 优化第一步：性能分析实践Python 性能分析工具简介]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib 学习]]></title>
    <url>%2F2017%2F10%2F28%2Fmatplotlib.html</url>
    <content type="text"><![CDATA[绘图也算常用…Hello, Matplotlib1234import matplotpy.plot as pltimport numpy as npX = np.linematplotlib 查看可用的中文字体12345678910111213from matplotlib.font_manager import FontManagerimport subprocessfm = FontManager()mat_fonts = set(f.name for f in fm.ttflist)#print(mat_fonts)output = subprocess.check_output('fc-list :lang=zh -f "%&#123;family&#125;\n"', shell=True)#print( '*' * 10, '系统可用的中文字体', '*' * 10)#print (output)zh_fonts = set(f.split(',', 1)[0] for f in output.decode('utf-8').split('\n'))available = mat_fonts &amp; zh_fontsprint ('*' * 10, '可用的字体', '*' * 10)for f in available: print (f)matplotlib 显示中文的问题第一步：下载字体：msyh.ttf （微软雅黑）放在系统字体文件夹下：/usr/share/fonts同时我也复制了下放在 matplotlib 的字体文件夹下了（不知道这一步是不是必须）/usr/local/lib/python3.5/dist-packages/matplotlib/mpl-data/fonts/ttf/第二步：修改 matplotlib 配置文件：编辑 /usr/local/lib/python3.5/dist-packages/matplotlib/mpl-data/matplotlibrc删除 font.family 和 font.sans-serif 两行前的#，并在 font.sans-serif 后添加中文字体Microsoft YaHei, …（其余不变）第三步：删除~/.cache/matplotlib 下文件 fontList.py3k.cache第四步：代码里加入以下代码12from matplotlib import rcParamsrcParams['font.family'] = 'Microsoft YaHei'参考资料Matplotlib 教程给深度学习入门者的 Python 快速教程 - numpy 和 Matplotlib 篇]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2017%2F10%2F27%2Fregex.html</url>
    <content type="text"><![CDATA[经常用的工具 vi、grep、awk、sed、python 都涉及正则表达式的使用，经常在需要使用的时候想不起来，所以记录一下将常用的记录一下元字符常用代码说明.匹配除换行符以外的任意字符\w匹配字母或数字或下划线\s匹配任意的空白符\d匹配数字\b匹配单词的开始或结束^匹配字符串的开始$匹配字符串的结束\转义字符[xyz]匹配所包含的任意一个字符x&#124;y匹配 x 或 y反义代码说明\W匹配任意不是字母，数字，下划线的字符\S匹配任意不是空白符的字符\D匹配任意非数字的字符\B匹配不是单词开头或结束的位置[^aeiou]匹配除了 aeiou 这几个字母以外的任意字符分组分类代码语法 说明捕获(exp)匹配 exp, 并捕获文本到自动命名的组里捕获(?&lt;name&gt;exp)匹配 exp, 并捕获文本到名称为 name 的组里，也可以写成 (?’name’exp)捕获(?:exp)匹配 exp, 不捕获匹配的文本，也不给此分组分配组号零宽断言(?=exp)匹配 exp 前面的位置零宽断言(?&lt;=exp)匹配 exp 后面的位置零宽断言(?!exp)匹配后面跟的不是 exp 的位置零宽断言(?&lt;!exp)匹配前面不是 exp 的位置注释(?#comment)这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读启用“忽略模式里的空白符”选项1234567(?&lt;= # 断言要匹配的文本的前缀&lt;(\w+)&gt; # 查找尖括号括起来的字母或数字（即 HTML/XML 标签）) # 前缀结束.* # 匹配任意文本(?= # 断言要匹配的文本的后缀&lt;\/\1&gt; # 查找尖括号括起来的内容：前面是一个&quot;/&quot;，后面是先前捕获的标签) # 后缀结束限定符代码说明*重复零次或更多次+重复一次或更多次?重复零次或一次{n}重复 n 次{n,}重复 n 次或更多次{n,m}重复 n 到 m 次贪婪与懒惰代码说明*?重复任意次，但尽可能少重复+?重复 1 次或更多次，但尽可能少重复??重复 0 次或 1 次，但尽可能少重复{n,m}?重复 n 到 m 次，但尽可能少重复{n,}?重复 n 次以上，但尽可能少重复默认为贪婪，a.\*?b 和 a.\*b 同时作用于 aabaab，第一个正则表达式匹配整个字符串 aabaab， 第二个匹配 aab 和 aab为什么第一个匹配是 aab（第一到第三个字符）而不是 ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权vi/sed/ag/awk/python 区别环境\d() + &#124;分组零宽断言sed/vi/grep/n-r 或者添加 \yn参考资料正则表达式 30 分钟入门教程菜鸟教程——正则表达式]]></content>
      <categories>
        <category>编程技术</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow tfdbg]]></title>
    <url>%2F2017%2F10%2F17%2FTensorflow-tfdbg.html</url>
    <content type="text"><![CDATA[Tensorflow 中使用 python 描述计算图，再使用 C++ 后端进行训练时就非常不容跟踪调试，Tensorflow 提供了 tfdbg 模块用于解决这个问题，但是网上的资料较少，所以将自己的一些理解写出来供参考启用 tfdbg官网上 关于 tfdbug 的使用说的非常清楚，仅需要在创建 session 后，使用 session 前加入以下代码：12from tensorflow.python import debug as tf_debugsess = tf_debug.LocalCLIDebugWrapperSession(sess)然后像往常一样启动你的训练模型即可，启动后，可以看到以下界面：tfdbg 基本使用开始调试为了方便说明，就使用官方教程中的例子，执行以下命令：1python -m tensorflow.python.debug.examples.debug_mnist --debug注意：该例子会在第一次执行时从网上下载训练数据，务必保证能访问网络资源，公司内部的同事就需要配置代理第一步一般都是输入命令：run 就可以看到以下界面了print_tensor执行 run 之后，我们可以点击 list_tensors 列表中的带下划线的文字了，例如，点击 hidden/Wx_plus_b/MatMuls:0 就可以看到以下界面第一个问题，这个矩阵表示什么呢？首先，在/usr/local/lib/python3.6/site-packages/tensorflow/python/debug/examples/debug_mnist.py中找到对应的代码1234567891011121314def nn_layer(input_tensor, input_dim, output_dim, layer_name, act=tf.nn.relu): """Reusable code for making a simple neural net layer.""" # Adding a name scope ensures logical grouping of the layers in the graph. with tf.name_scope(layer_name): # This Variable will hold the state of the weights for the layer with tf.name_scope("weights"): weights = weight_variable([input_dim, output_dim]) with tf.name_scope("biases"): biases = bias_variable([output_dim]) with tf.name_scope("Wx_plus_b"): preactivate = tf.matmul(input_tensor, weights) + biases activations = act(preactivate) return activations其实，这个矩阵就是 preactivate 的值，为什么这里不直接显示 preactivate 的变量名呢？ 因为 Tensorflow 的后端根本不知道这个局部变量，后端能获取的只有 Tensor（比如 tf.Variable） 或者 Option（比如 tf.matmul）, 所以，我们得出结论，点击 list_tensors 列表中的 Tensor/Option 后，显示的就是这个 Tensor 的值或者 Option 的运算结果和维度信息，这对我们理解模型相当有帮助，比如，有些难以理解的运算我们可以根据运算结果演算一遍。第二个问题，hidden/Wx_plus_b/MatMuls:0 是怎么和代码对应起来的？Tensorflow 中，所有的 Tensor/Option 都有唯一的名字，命名的规则是 tf.name_scope + name 参数123456with tf.name_scope("Any_Scope"): with tf.name_scope("First_Scope"): V1 = tf.Variable(shape, name='First') with tf.name_scope("Second_Scope"): V2 = tf.Variable(shape) V3 = tf.Variable(shape)这段代码中，V1/V2/V3 对应的 Tensor 的名字分别为：Any_Scope/First_Scope/First、Any_Scope/Second_Scope/Variable、Any_Scope/Second_Scope/Variable_1 可以看出，如果不指定 name 参数 则默认为 Tensor/Option 的类名，如果相同 Scope 中有相同 name 的 Tensor/Option 则自动为名称添加序号在问题一中，layer_name 为 hidden，所以 preactivate = tf.matmul(input_tensor, weights) + biases 的名称就是 hidden/Wx_plus_b/MatMuls:0node_info输入及输出信息点击 hidden/Wx_plus_b/MatMuls:0 后默认显示的就是上一小节提到的 print_tensor，此时我们可以点击 node_info，点击后显示以下信息：红框中的信息包括：1、MatMul 操作通过 cpu 执行 2、两个操作数分别为训练的输入数据 x-input 和表示权重的 Variable 3、输出的结果被用于加法操作调用栈信息此时可以按 pagedown 向下滑动，查看代码调用栈：清晰的展示出，main 函数调用了 nn_layer 函数，然后执行了 87 行的 MatMuls 操作，同时，如果不清楚库函数定义所在的文件，也可以在这里找到。当前代码行对应的其他 Tensor/Option此时，可以点击 Line: 87, 就可以看到 87 行相关的其他 Tensor/Option 的信息了nn_layer 一共被调用了两次，且 87 行包含了两个操作 （MatMuls、add）, 所以一共是四个 Option 信息，此时，点击 softmax/Wx_plus_b/MatMuls:0 可以看到以下信息：list_inputs点击 list_inputs 可以看到 softmax/Wx_plus_b/MatMuls:0 详细输入：可以看出，softmax/Wx_plus_b/MatMuls:0 的左操作数是 hidden/Relu， 右操作数是 softmax/weights/Variable/read，hidden/Relu 只有一个操作数 hidden/Wx_plus_b/add, 依次类推，可以查看计算 softmax/Wx_plus_b/MatMuls:0 的每一步操作list_outputs点击 list_outputs 可以看到 softmax/Wx_plus_b/MatMuls:0 的输出的详细用途：首先，输出被用于 softmax/Wx_plus_b/MatMuls，依次类推，最终被用于加权平均run_info点击 run_info 可以看到以下信息：这里可以点击红框部分查看训练 / 测试样本的输入 / 输出单步运行输入 s 就可以单步调试了，s -t 10 可以执行 10 步，需要注意的是，一定是执行 run 命令后才可以执行 s 命令理解记忆调试命令鼠标点击能查看的信息毕竟有限，直接看 help 又不好理解，好在 tfdbg 中始终会显示当前显示信息所对应的命令：很明显 pt 就表示 print_tensor，如果需要了解 pt 的更多参数，就可以执行 help pt我们可以试试 pt -a accuracy/accuracy/Cast:0]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fast_AI]]></title>
    <url>%2F2017%2F10%2F14%2FFast-AI.html</url>
    <content type="text"><![CDATA[FastAI 学习笔记Lesson 1]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TODO]]></title>
    <url>%2F2017%2F10%2F14%2FTODO.html</url>
    <content type="text"><![CDATA[一些来不及整理的内容先保存在这里学习 git以下文件包含 git 常用命令的缩写1~/.oh-my-zsh/plugins/git解决 zsh 和 tmux 下，vim 配色显示不一致编辑~/.zshrc:alias tmux=&quot;TERM=screen-256color-bce tmux&quot;编辑 ~/.tmux.conf:set -g default-terminal &quot;xterm&quot;参考 [https://stackoverflow.com/questions/10158508/lose-vim-colorscheme-in-tmux-mode]python3 import docx 错误pip uninstall docx下载 python_docx-0.8.6-py2.py3-none-any.whlpip install python_docx-0.8.6-py2.py3-none-any.whl机器学习教程斯坦福大学 CS231n 卷积神经网络与图像识别吴恩达 Deep Learning SpecializationUdacity 免费深度学习课程Geoffrey Hinton 的 Neural Networks For Machine Learning斯坦福大学 CS224d 自然语言处理深度学习Ian Goodfellow 的 DeepLearning 书籍良心 GitHub 项目：各种机器学习任务的顶级结果（论文）汇总）apt-get 非正常退出后，出现 dpkg –configure -a 时，暴力解决rm /var/lib/apt/lists/lockrm /var/cache/apt/archives/lockrm /var/lib/dpkg/lockrm /var/lib/dpkg/updates/*latex如果你只用 latex 画图的话，可以只看 pgfmanual 这个宏包就行了，安装完 texlive，文档都会一起安装了安装在线体验《102 分钟学会 latex》「 Neural Networks and Deep Learning 」中文翻译（连载完毕）ubuntu 执行 mount 报错ubuntu 下如果 mount 的是 window 的共享目录，会出现以下错误：123# mount -t cifs -o XXX_PATH LOCAL_PATHmount: XXX_PATH is write-protected, mounting read-onlymount: cannot mount XXX_PATH read-only执行以下命令即可：1apt-get install -y cifs-utilsFlask 单元测试官方网站官方给出的例子如下：12345678910111213141516171819202122232425#coding=utf8from flask import Flask,jsonifyfrom flask_testing import TestCaseimport unittestapp = Flask(__name__)@app.route(&quot;/ajax/&quot;)def some_json(): return jsonify(success=True)class TestViews(TestCase): def create_app(self): app.config[&apos;TESTING&apos;] = True return app def test_some_json(self): response = self.client.get(&quot;/ajax/&quot;) &apos;&apos;&apos;&apos;&apos; 判断还回的 JSON 对像是不是&#123;&apos;success&apos;:True&#125; &apos;&apos;&apos; self.assertEqual(response.json, dict(success=True))if __name__ ==&apos;__main__&apos;: unittest.main()Structuring Your TensorFlow Modelshttps://github.com/tensorflow/models/blob/master/tutorials/rnn/ptb/ptb_word_lm.py存在的问题：整个 Graph 都定义在 PTBModel 的 init 函数中，可读性和重用性不太好https://github.com/tensorflow/models/blob/master/tutorials/embedding/word2vec_optimized.py存在的问题：直接将整个 init 函数拆分成了多份，但是整个计算图依然在 build_graph 一个函数中实现，正常的看代码的顺序是 main——train——self._train_thread_body——self._train——train——build_graph——init较为冗长的调用关系，重复的命名，无法直观的看出 train 就是我们计算图中关键的节点。根本原因是 build_graph 中集合了整张图的描述。按照我们的正常思维，计算图会有输入、预测函数、损失函数、优化函数、输出，如果按照以上部分将计算图分割，将能提高重用性和可读性http://danijar.com/structuring-your-tensorflow-models/弄两张 Scopes 对比，没有添加 Scopes 时的调试信息删除除了某个文件的其他文件1rm -rf !(*.zip)解压至压缩文件名创建的目录下12345678import osfile_names = os.listdir()zip_files = [x for x in file_names if os.path.splitext(x)[1] == '.zip']unzip_cmds = ['unzip %s -d %s' % (x, os.path.splitext(x)[0]) for x in zip_files]for cmd in unzip_cmds: os.system(cmd)解压目录下的所有文件123456789import osimport argparsefile_names = os.walk()zip_files = [(root, file) for root, dirs, files in file_names for file in files if os.path.splitext(file)[1] == '.zip']unzip_cmds = ['unzip -o %s -d %s' % (os.path.join(x[0], x[1]), x[0]) for x in zip_files]for cmd in unzip_cmds: os.system(cmd)outlook 联系人组https://support.office.com/zh-cn/article/%E5%9C%A8-Outlook%E2%80%8B%E2%80%8B-%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%81%94%E7%B3%BB%E4%BA%BA%E7%BB%84%E6%88%96%E9%80%9A%E8%AE%AF%E7%BB%84%E5%88%97%E8%A1%A8-88ff6c60-0a1d-4b54-8c9d-9e1a71bc3023?ui=zh-CN&amp;rs=zh-CN&amp;ad=CNpython 读取文件编码错误1open(file_name, encoding=encode_type, errors=&apos;ignore&apos;)python request 乱码http://xiaorui.cc/2016/02/19/%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90python-requests%E5%BA%93%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/5885 服务器启动报错12For success boot, you have to switch the auto-pxe on or permit the pxe request in Web-UICould not boot: Error 0x00000001 (http://ipxe.org/00000001)Google 了一下PXE发现是无盘启动技术，第一反应是启动顺序出错，默认进入了网络启动，于是在启动时按下F11进入启动顺序配置界面选择硬盘启动jupyter 配置按章节折叠1234pip install jupyter_contrib_nbextensionsjupyter contrib nbextension install --userpip install jupyter_nbextensions_configuratorjupyter nbextensions_configurator enable --user在Nbextensions选项卡中勾选Collapsible Headingshttp://blog.csdn.net/w371500241/article/details/78561237apt-get 安装告警1dpkg: warning: files list file for package &apos;x&apos; missing; assuming package has no files currently installed从告警来看，貌似是说假设这个包已经安装了，但是没有文件？网上找到的办法就是重新安装所有告警的包，但是从后续的工作来看，这些告警都是无害的。1apt-get install -y &quot;xxx&quot; | grep &quot;warning: files list file for package &apos;&quot; | grep -Po &quot;[^&apos;\n ]+&apos;&quot; | grep -Po &quot;[^&apos;]+&quot; |xargs -I &#123;&#125; apt-get install --reinstall &#123;&#125;bazel 构建报错12345678# root @ ubuntu in ~/workspace/mount/models-master [9:26:56]$ bazel build -c opt textsum/................................INFO: Analysed 7 targets (14 packages loaded).INFO: Found 7 targets...Unhandled exception thrown during build; message: /root/workspace/mount/models-master/bazel-out (Operation not supported)INFO: Elapsed time: 5.124sFAILED: Build did NOT complete successfully尝试了很多办法，最后发现这个错误的原因是 bazel 执行的路径不能在 mount 目录，拷贝出去即可优化配置调整 pep8 行内最大字符数如果需要调整 pep8 的最大行字符数，可以直接更改一下文件bundle/Python-mode-klen/pymode/libs/pylama/lint/pylama_pep8/pep8.py1MAX_LINE_LENGTH = 79vim 与系统剪切板连接mac 系统中，如果 tmux 下 vim 和系统的剪切板无法通用，可以通过以下命令查看是否启用 reattach-to-user-namespace12$ tmux show-option -gv default-commandreattach-to-user-namespace -l /bin/zshssh 超时断开cp /etc/ssh/sshd_config /etc/ssh/sshd_config_baksed -i “s/#ClientAliveInterval 0/ClientAliveInterval 60/g” /etc/ssh/sshd_configsed -i “s/#ClientAliveCountMax3/ClientAliveCountMax 3/g” /etc/ssh/sshd_configservice sshd restart配置 Ubuntu 可以通过 ssh 连接sed -i “s/#PermitRootLogin without-password/PermitRootLogin yes/g” /etc/ssh/sshd_configservice ssh restart代码格式化工具1pip install yapf代理配置12# npm config set proxy http://username:password@server:port# npm config set https-proxy http://username:pawword@server:porttar 错误tar: XXXXXX: Cannot change ownership to uid XXX, gid XXXX: Operation not permitted使用 -no-same-owner 选项UnicodeEncodeError: ‘ascii’ codec can’t encode character u’xxx’ in position xxx: ordinal not in range(128)export LC_ALL=’en_US.utf8’https://stackoverflow.com/questions/9942594/unicodeencodeerror-ascii-codec-cant-encode-character-u-xa0-in-position-20git 错误处理错误：fatal: unable to access ‘https://github.com/robbyrussell/oh-my-zsh.git/‘: server certificate verification failed. CAfile: /etc/ssl/certs/ca-certificates.crt CRLfile: none错误：Peer’s Certificate issuer is not recognized.方案：git config –global http.sslVerify false错误：error: RPC failed; curl 56 GnuTLS recv error (-110): The TLS connection was non-properly terminated方案：apt-get install build-essential fakeroot dpkg-devmkdir ~/git-opensslcd ~/git-opensslapt-get source gitapt-get build-dep gitapt-get install libcurl4-openssl-devdpkg-source -x git_2.7.4-0ubuntu1.dsccd git-2.7.4修改 vi debian/controllibcurl4-gnutls-dev 改为 libcurl4-openssl-dev编辑 vi debian/rules删除 TEST =testdpkg-buildpackage -rfakeroot -bdpkg -i ../git_2.7.4-0ubuntu1_amd64.debCan’t drop privileges for downloading as file ‘git_2.7.4.orig.tar.xz’ couldn’t be accessed by user ‘_apt’. - pkgAcquire::Run (13: Permission denied)sudo chown _apt /var/lib/update-notifier/package-data-downloads/partial/git 忘记 --recursivegit submodule initgit submodule updatehttp://blog.csdn.net/stupid_3/article/details/79167983]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>todo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Seq2Seq 模型分析及 Tensorflow NMT 源码分析]]></title>
    <url>%2F2017%2F10%2F14%2FLearn-Seq2Seq-Model.html</url>
    <content type="text"><![CDATA[近期主要任务为使用 Seq2Seq 模型，记录一些资料目录结构Tensorflow 的 NMT 项目 github 地址12345678910111213141516171819202122232425nmt nmt.py # 训练入口文件，主要实现参数解析 train.py # 训练 inference.py # 评估 inference_test.py # inference 单元测试 model.py # 不带 Attention 结构的模型 model_test.py # model 单元测试 attention_model.py # 不指定 --attention_architecture 时，带 Attention 结构的模型 gnmt_model.py # --attention_architecture 被指定为 gnmt 或 gnmt_v2 时，带 Attention 结构的模型 model_helper.py # 构造模型的通用函数 scripts # bleu.py # bleu 评分 rouge.py # utils # __init__.py # 模块 iterator_utils.py # 构造输入输出的通用函数 iterator_utils_test.py # iter 单元测试 misc_utils.py # 其他 misc_utils_test.py # misc 单元测试 vocab_utils.py # 构造词典 vocab_utils_test.py # vocab 单元测试 evaluation_utils.py # 预测相关 evaluation_utils_test.py # eval 单元测试 nmt_utils.py # 翻译 common_test_utils.py # common 单元测试参数说明network12345678--num_units # 每层网络的神经元个数，默认 32，Demo 中使用了 128--num_layers # 网络的深度，默认使用 2--num_encoder_layers # encodeer 的层数，默认等于 --num_layers--num_decoder_layers # decodeer 的层数，默认等于 --num_layers--encoder_type # 编码层的结构，默认 uni（单向 RNN），可以选择 bi（双向 RNN），gnmt（单双混合）--residual #--time_major #--num_embeddings_partitions #attention mechanisms1234--attention # 不指定时，模型将不带有 Attantion 结构--attention_architecture # 指定 --attention 才能生效--output_attention #--pass_hidden_state #optimizer1234567--optimizer #--learning_rate #--warmup_steps #--warmup_scheme #--decay_scheme # 学习率 decay 的策略，可以选三种：luong5/luong10/luong234 在 --num_train_steps 超过 0.5/0.5/0.66 后，学习率减半 5/10/4 次--num_train_steps # 训练次数，默认 12000--colocate_gradients_with_ops #initializer12--init_op # 模型初始化函数，默认 uniform, 可选 uniform | glorot_normal | glorot_uniform--init_weight # 当 --init_op 为 uniform 时生效，默认为 0.1data123456--src # 源文件后缀--tgt # 目标文件后缀--train_prefix # 训练数据文件全路径，不包含后缀--dev_prefix # 验证数据文件全路径，不包含后缀--test_prefix # 测试数据文件全路径，不包含后缀--out_dir # 模型存放目录Vocab12345--vocab_prefix # 词典文件全路径，不包含后缀--sos # 句子开始的标记--eos # 句子结束的标记--share_vocab # 输入输出是否使用同一个字典--check_special_token #Sequence lengths1234--src_max_len # 训练输入数据的最大长度，默认 50--tgt_max_len # 训练输出数据的最大长度，默认 50--src_max_len_infer #--tgt_max_len_infer #Default settings works well123456789--unit_type #--forget_bias #--dropout # 默认 0.2--max_gradient_norm #--source_reverse #--batch_size #--steps_per_stats # 每训练 N 次打印一次统计信息，默认 100--max_train #--num_buckets # 训练集分桶数量，默认 5SPM1--subword_option #Misc12345678--num_gpus # GPU 个数，默认 1，默认情况下多 GPU 无法获得性能提升--log_device_placement #--metrics # 翻译结果的评价函数，默认 bleu，可以多选，如，(bleu,rouge,accuracy)--steps_per_external_eval #--scope #--hparams_path #--random_seed #--override_loaded_hparams # 如果不指定该参数，则训练参数从 hparams 文件中读取Inference123456789--ckpt #--inference_input_file # 预测阶段的输入文件，用于区分训练和预测阶段--inference_list #--infer_batch_size #--inference_output_file #--inference_ref_file #--beam_width # 暂时没搞懂意图，但是在 inference 后，将结果写入文件时，影响 --num_translations_per_input 参数--length_penalty_weight #--num_translations_per_input # 模型在 inference 过程中，推荐的输出个数Job info12--jobid #--num_workers #函数调用关系注意：如果要对照 Tensorboard 中的 Graph 看代码要记得在 Tensorboard 左侧的下拉选项中选择 train_log, 否则看不到预处理相关节点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051main run_main create_or_load_hparams # train # create_train_model # 构建训练模型、输入输出、字典，指定 mode 为 TRAIN create_vocab_tables # 创建 token 与 id 的映射字典 get_iterator # 将训练数据处理成符合条件的输入输出 key_func # 训练数据按 bucket 分组 key_func # 训练数据按 bucket 分组 BatchedInput # 通过 name 访问 get_iterator 返回值的便利函数 AttentionModel:__init__ # model_creator 可能对应不同的 BaseModel 子类 BaseModel:__init__ # 构建训练模型 get_initializer # 选择 Variable 的初始化函数 BaseModel:init_embeddings # 创建 word embedding 矩阵 BaseModel:build_graph # 构建 Seq2Seq 计算图 Model:_build_encoder # 根据配置创建 uni/bi 结构的编码层，gnmt 结构重写了该函数 _build_encoder_cell # 创建编码层，直接调用了 create_rnn_cell，目前无重写 create_rnn_cell # 创建单层或者多层 RNN _cell_list # 创建多层 RNN _single_cell # 创建单层 RNN BaseModel:_build_decoder # BaseModel:_get_infer_maximum_iterations # Model:_build_decoder_cell # 每种模型都重写了该函数 get_device_str # BaseModel:_compute_loss # BaseModel:_get_learning_rate_warmup # BaseModel:_get_learning_rate_decay # gradient_clip # create_eval_model # create_infer_model # load_data # get_config_proto # create_or_load_model # run_full_eval # run_sample_decode # 抽样打印预测结果 create_or_load_model # 加载 infer 模型 _sample_decode # 抽取一个测试集中的一个样本，输出 nmt 的预测结果 run_internal_eval # 获取验证集、测试集的混淆值 create_or_load_model # 加载 infer 模型 _internal_eval # 获取混淆值，写入 tensorborad，注意 eval 的数据在这里喂入 compute_perplexity # 计算混淆值 BaseModel:eval # 计算 eval_loss/predict_count/batch_size safe_exp # 执行表达式，如果出现上溢则返回 inf run_external_eval # 计算测试和验证集的 bleu/rouge/accuracy create_or_load_model # 加载 infer 模型 _external_eval # _format_results # 格式化字符串，将 ppl/[bleu/rouge/accuracy] 的结果格式化 init_stats # update_stats # check_stats # add_summary #API 说明BatchedInput功能没有实现直接继承了 collections.namedtuple。 如果返回原始的 tuple， 则仅能通过 index 访问 item 。collections.namedtuple 可以通过 item 的 name 进行访问。可以将 namedtuple 理解为 c 中的 struct 结构，其首先将各个 item 命名，然后对每个 item 赋予数据。示例12345678$ ipython3In [1]: import collectionsIn [2]: coordinate = collections.namedtuple('Collections', ['x', 'y'])In [4]: co = coordinate(10, 20)In [5]: co.xOut[5]: 10In [6]: co.yOut[6]: 20get_iterator功能产生训练数据，需要注意的是仅当调用 BatchedInput.initializer 才会重新执行 shuffle/padding/batch 等数据预处理。而每次使用 BatchedInput 的其他任意成员都会默认调用 tf.data.Iterator 的 get_next() 函数示例123456789101112131415161718$ ipythonIn [1]: import tensorflow as tfIn [2]: from tensorflow.python.data import DatasetIn [3]: dataset = Dataset.range(5)In [4]: dataset = dataset.map(lambda x: (x, x))In [5]: d_iter = dataset.make_one_shot_iterator()In [6]: x, y = d_iter.get_next()In [7]: sess = tf.Session()In [8]: sess.run(x)Out[8]: 0In [9]: sess.run(x)Out[9]: 1In [10]: sess.run(y) # 前两次获取 x 第三次获取 y，但是 y 已经取到了 2，说明前两次 sess.run(x) 隐含调用了 get_next()Out[10]: 2In [12]: sess.run((x, y))Out[12]: (3, 3)In [13]: sess.run((x, y)) # 这里说明，每次 sess.run 才会调用一次 get_next()，而不是获取一次 x 或者 y 的值调用一次 get_next()Out[13]: (4, 4)参考资料论文：seq2seq 第一篇文章1409.3215.pdf加入 context vector，可以处理变长数据1406.1078.pdf加入 attention 机制1508.04025.pdf官网介绍：[https://www.tensorflow.org/tutorials/seq2seq]其他：seq2seq 学习笔记tensorflow 学习笔记（十一）：seq2seq Model 相关接口介绍深度学习笔记（六）：Encoder-Decoder 模型和 Attention 模型seq2seq 入门Tensorflow 源码解读（一）：Attention Seq2Seq 模型从 Encoder 到 Decoder 实现 Seq2Seq 模型序列到序列的语言翻译模型代码 (tensorflow) 解析谷歌神经网络机器翻译 NMT：人人可利用 TensorFlow 快速建立翻译模型（附教程）]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hash 实现]]></title>
    <url>%2F2017%2F09%2F10%2FHash_implement.html</url>
    <content type="text"><![CDATA[C 语言标准库中未实现 hashtable, 在编程练习时经常使用该数据结构，以备不时之需实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;typedef unsigned char u8_t;typedef char s8_t;typedef unsigned short u16_t;typedef signed short s16_t;typedef unsigned int u32_t;typedef signed int s32_t;typedef long long s64_t;typedef unsigned long long u64_t;typedef s32_t err_t;typedef unsigned long ulong_t;void* xxx_malloc(int size)&#123; void* ret = malloc(size); printf("malloc %p\n", ret); return ret;&#125;void xxx_free(void* ptr)&#123; printf("free %p\n", ptr); free(ptr);&#125;#define offset_of(type, member) ((unsigned long)&amp;((type *)0)-&gt;member)#define container_of(ptr, type, member) \ ((type *)((unsigned char *)ptr - offset_of(type,member)))#define hlist_entry(ptr, type, member) container_of(ptr,type,member)#define hlist_for_each(pos, head) for (pos = (head)-&gt;first; pos; pos = pos-&gt;next)#define hlist_for_each_safe(pos, n, head) \ for (pos = (head)-&gt;first; pos &amp;&amp; (n = pos-&gt;next, 1); pos = n)#define hlist_for_each_entry(type_pos, ptr, pos, head, member) \ for (pos = (head)-&gt;first; pos &amp;&amp; (ptr = hlist_entry(pos, type_pos, member), 1); pos = pos-&gt;next)#define hlist_for_each_entry_safe(type_pos, tpos, pos, n, head, member) \ for (pos = (head)-&gt;first; \ pos &amp;&amp; (&#123; n = pos-&gt;next; 1; &#125;) &amp;&amp; \ (&#123; tpos = hlist_entry(pos, type_pos, member); 1;&#125;); \ pos = n)#define INIT_HLIST_HEAD(ptr) ((ptr)-&gt;first = NULL)struct hlist_head &#123; struct hlist_node *first;&#125;;struct hlist_node &#123; struct hlist_node *next, **pprev;&#125;;static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)&#123; struct hlist_node *first = h-&gt;first; n-&gt;next = first; if (first) first-&gt;pprev = &amp;n-&gt;next; h-&gt;first = n; n-&gt;pprev = &amp;h-&gt;first;&#125;static inline void INIT_HLIST_NODE(struct hlist_node *h)&#123; h-&gt;next = NULL; h-&gt;pprev = NULL;&#125;static inline int hlist_unhashed(const struct hlist_node *h)&#123; return !h-&gt;pprev;&#125;static inline int hlist_empty(const struct hlist_head *h)&#123; return !h-&gt;first;&#125;static inline void __hlist_del(struct hlist_node *n)&#123; struct hlist_node *next = n-&gt;next; struct hlist_node **pprev = n-&gt;pprev; *pprev = next; if (next) next-&gt;pprev = pprev;&#125;static inline void hlist_del_init(struct hlist_node *n)&#123; if (!hlist_unhashed(n)) &#123; __hlist_del(n); &#125;&#125;typedef struct _xxx_hash_bucket_head &#123; struct hlist_head chain; // hash 桶的头结点&#125; xxx_hash_bucket_head;typedef struct _xxx_hashtable &#123; xxx_hash_bucket_head *tbl; // hash 表中的 hash 桶 s8_t *name; // hash 表的名称，未使用 u32_t cnt; // 保存关键字 hash 后的最大值 u32_t element_cnt; // 记录当前 hash 表中的元素数量 u32_t offset; // hlist_node 成员与包含该成员结构体的地址偏移 u32_t (*hash)(void *); // 关键字的 hash 算法函数 s32_t (*compare)(void *, void *); // 元素的比较函数 void (*destroy)(void *); // 反初始化时对每个元素的反初始化操作函数&#125; xxx_hashtable_t;void *hashtable_init(s8_t *name, u32_t cnt, u32_t offset, u32_t (*hash)(void *), s32_t (*compare)(void *, void *), void (*destroy)(void *))&#123; xxx_hashtable_t *tbl; u32_t i; u32_t size; assert(!(cnt &amp; (cnt - 1))); assert(NULL != hash); assert(NULL != compare); if (NULL == (tbl = (xxx_hashtable_t*)xxx_malloc(sizeof(xxx_hashtable_t)))) &#123; return NULL; &#125; size = sizeof(xxx_hash_bucket_head) * cnt; if (NULL == (tbl-&gt;tbl = xxx_malloc(size))) &#123; xxx_free(tbl); return NULL; &#125; tbl-&gt;name = name; tbl-&gt;cnt = cnt; tbl-&gt;element_cnt = 0; tbl-&gt;offset = offset; tbl-&gt;hash = hash; tbl-&gt;compare = compare; tbl-&gt;destroy = destroy; for (i = 0; i &lt; cnt; i++) &#123; INIT_HLIST_HEAD(&amp;(tbl-&gt;tbl[i].chain)); &#125; return tbl;&#125;void hashtable_fini(void *tbl)&#123; u32_t i; struct hlist_node *pos, *n; xxx_hash_bucket_head *h; u32_t size; u32_t offset; if (NULL == tbl) &#123; return; &#125; offset = ((xxx_hashtable_t *)tbl)-&gt;offset; for (i = 0; i &lt; ((xxx_hashtable_t *)tbl)-&gt;cnt; i++) &#123; h = &amp;((xxx_hashtable_t *)tbl)-&gt;tbl[i]; hlist_for_each_safe(pos, n, &amp;h-&gt;chain) &#123; if (NULL != ((xxx_hashtable_t *)tbl)-&gt;destroy) &#123; ((xxx_hashtable_t *)tbl)-&gt;destroy((void *)((u8_t *)pos - offset)); &#125; &#125; &#125; size = sizeof(struct hlist_head) * ((xxx_hashtable_t *)tbl)-&gt;cnt; xxx_free(((xxx_hashtable_t *)tbl)-&gt;tbl); xxx_free(tbl);&#125;static inline void *hashtable_find(void *tbl, void *elem)&#123; struct hlist_node *pos; xxx_hash_bucket_head *h; u32_t hash; hash = ((xxx_hashtable_t *)tbl)-&gt;hash(elem); assert(hash &lt; ((xxx_hashtable_t *)tbl)-&gt;cnt); h = &amp;((xxx_hashtable_t *)tbl)-&gt;tbl[hash]; hlist_for_each(pos, &amp;h-&gt;chain) &#123; if (!((xxx_hashtable_t *)tbl)-&gt;compare(elem, (u8_t *)pos - ((xxx_hashtable_t *)tbl)-&gt;offset)) &#123; return (void *)((u8_t *)pos - ((xxx_hashtable_t *)tbl)-&gt;offset); &#125; &#125; return NULL;&#125;static err_t hashtable_insert(void* hashtable, void* elem)&#123; struct hlist_node* pos; xxx_hash_bucket_head* bucket; u32_t hash; hash = ((xxx_hashtable_t *)hashtable)-&gt;hash(elem); assert(hash &lt; ((xxx_hashtable_t *)hashtable)-&gt;cnt); bucket = &amp;((xxx_hashtable_t *)hashtable)-&gt;tbl[hash]; hlist_for_each(pos, &amp;bucket-&gt;chain) &#123; if (!((xxx_hashtable_t *)hashtable)-&gt;compare(elem, (u8_t *)pos - ((xxx_hashtable_t *)hashtable)-&gt;offset)) &#123; return -1; &#125; &#125; hlist_add_head((struct hlist_node *)((u8_t *)elem + ((xxx_hashtable_t *)hashtable)-&gt;offset), &amp;bucket-&gt;chain); ((xxx_hashtable_t *)hashtable)-&gt;element_cnt++; return 0;&#125;static inline void hashtable_delete(void *hashtable, void *elem)&#123; xxx_hash_bucket_head *bucket; u32_t hash; hash = ((xxx_hashtable_t *)hashtable)-&gt;hash(elem); assert(hash &lt; ((xxx_hashtable_t *)hashtable)-&gt;cnt); bucket = &amp;((xxx_hashtable_t *)hashtable)-&gt;tbl[hash]; hlist_del_init((struct hlist_node *)((u8_t *)elem + ((xxx_hashtable_t *)hashtable)-&gt;offset)); if (NULL != ((xxx_hashtable_t *)hashtable)-&gt;destroy) &#123; ((xxx_hashtable_t *)hashtable)-&gt;destroy(elem); &#125; ((xxx_hashtable_t *)hashtable)-&gt;element_cnt--;&#125;/* Hash map 实现 */#define MAP_BUCKET_CNT (1 &lt;&lt; 6)typedef struct _str_map_t&#123; int m_value; struct hlist_node hash_node;&#125; str_map_t;/* 创建 str_map_t 对象 */str_map_t* str_map_init();/* 销毁 str_map_t 对象 */void str_map_fini(str_map_t* p_str_map);/* 插入元素 */void str_map_insert(str_map_t* p_str_map);/* 删除元素 */void str_map_erase(str_map_t* p_str_map);/* 查找元素 */void str_map_erase(str_map_t* p_str_map);/* 测试函数 */typedef struct _hlist_demo_t&#123; int m_value; struct hlist_node hash_node;&#125; hlist_demo_t;static u32_t demo_hash(void *pkt)&#123; return (u32_t)(((hlist_demo_t*)pkt)-&gt;m_value) % BUCKET_CNT;&#125;static s32_t demo_compare(void *pkt, void *pkt2)&#123; if (((hlist_demo_t*)pkt)-&gt;m_value == ((hlist_demo_t*)pkt2)-&gt;m_value) &#123; return 0; &#125; return -1;&#125;static void demo_destroy(void *arg)&#123; xxx_free(arg);&#125;int main()&#123;&#125;]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c 语言</tag>
      </tags>
  </entry>
</search>
