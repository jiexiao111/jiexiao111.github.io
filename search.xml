<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用 Github + Hexo 搭建个人博客]]></title>
    <url>%2F2017%2F09%2F14%2FGithub%2BHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E2%80%94%E2%80%94%E5%BE%85%E6%95%B4%E7%90%86.html</url>
    <content type="text"><![CDATA[Github 让个人技术博客的创建变得异常简单，Hexo 框架 + Next 主题提供了高度定制且美观的个人博客，本文记录了搭建过程 Hexo 与 jekyll 框架的选择经过两天的折腾，彻底放弃使用 jekyll 搭建自己的技术 Blog，究其原因就是目录、sitemap无法自动生成，一个没有前端开发经验的我最终发现Hexo。 Hexo能够满足我对Blog的所有想法：1、我只负责写内容，至于文章的按标签分类还是按日期归档我都不关心，但是我需要使用这些功能2、文章要有一个漂亮的内容导航栏，开发做多了，对始终能在一屏内了解当前文件的整体结构有着某种偏执3、sitemap、文章目录最好能够复用网页位置，以便留出更多的位置显示正文，尽量少的翻页绝对能提升生产效率 个人博客搭建依次安装 git、node.js、hexo、next主题 安装 git官网描述的很清楚我最常用的是Ubuntu，只需要执行以下命令即可:1apt-get install git 安装 node.js一开始，我以为使用的 Ubuntu-16.04LTS 已经很新了，所以就直接使用 apt-get 安装了，结果在安装 hexo 时出现错误。网上整了一堆高级方法都没能解决。最终参考node.js 官网，直接download官方的首页的最新的LTS版本 node-v6.11.3-linux-x64.tar.xz，解压至 /usr 目录1tar -vxf node-v6.11.3-linux-x64.tar.xz -C /usr/ 默认 hexo 安装的位置与 npm 一致，所以如果没有把 npm 所在路径加入环境变量，则安装 hexo 后会发现无法找到 hexo 命令，所以建议将 node.js 的安装路径加入 ~/.bashrc1echo 'export PATH="/usr/node-v6.11.3-linux-x64/bin:$PATH' &gt;&gt; ~/.bashrc 如果你和我一样使用 zsh，就放到 ~/.zshrc 中1echo 'export PATH="/usr/node-v6.11.3-linux-x64/bin:$PATH' &gt;&gt; ~/.zshrc 添加环境变量后记得 source12source ~/.bashrcsource ~/.zshrc 安装 hexo创建一个目录, 比如 hexo_dir, 用于安装 hexo, 通过 npm 命令安装 hexo123mkdir hexo_dircd hexo_dirnpm install -g hexo-cli 安装 next 主题hexo 的安装路径下有一个 themes 目录，hexo 默认会使用该目录下的主题，所以一定要在 hexo 安装目录下执行1git clone https://github.com/iissnan/hexo-theme-next themes/next 如果你想能够更新 next 主题，且又想通过 github 管理你的主题定制信息，那么需要麻烦一些, 可以参考下面的 多平台共同编辑博客 Github 创建博客只需要在 github 上创建 用户名+github.io 的 Repo 即可创建成功后，就可以通过 https://用户名.github.io/ 访问了, 比如我就是通过 https://jiexiao111.github.io/ 访问 站点配置文件修改在 hexo 安装目录下可以找到 _config.yml 文件, 这个文件就是站点配置文件, 修改站点配置文件后，需要重起 hexo 服务，才能生效 1hexo s 启用 next 主题编辑站点配置文件1theme: next 验证next主题，在 hexo 安装目录下执行 hexo s –debug，如果未出现错误，则在浏览器中访问以下位置1http://localhost:4000/ 修改默认标题、子标题、描述、作者、字符集编辑站点配置文件123456# Sitetitle: JieXiao's Blogsubtitle:description:author: JIE XIAOlanguage: zh-Hans 主题配置文件修改hexo 目录下的 themes/next/ 子目录中也有一个 _config.yml 文件, 这个文件就是主题配置文件，修改主题配置文件后立即生效，无需重启 hexo 服务 修改 Next 主题风格个人偏向于在一屏内显示更多的内容所以选择了 Mist 风格12345# Schemes# scheme: Musescheme: Mist# scheme: Pisces# scheme: Gemini 设置侧边栏Next 主题的文章目录导航和作者介绍复用了侧边栏，非常不错123sidebar: position: left display: always 修改字体12345678910111213141516171819202122232425262728293031font: enable: true # 外链字体库地址，例如 //fonts.googleapis.com (默认值) host: # 全局字体，应用在 body 元素上 global: external: true family: Monda # 标题字体 (h1, h2, h3, h4, h5, h6) headings: external: true family: Roboto Slab # 文章字体 posts: external: true family: # Logo 字体 logo: external: true family: Lobster Two size: 24 # 代码字体，应用于 code 以及代码块 codes: external: true family: PT Mono 修改代码风格1highlight_theme: night 侧边栏中增加社交信息123456social: GitHub: https://github.com/jiexiao111 E-Mail: mailto:jiexiao111@gmail.comsocial_icons: GitHub: github E-Mail: email 开启背景动画1canvas_nest: true 开启公式显示12mathjax: enable: true 开启访问统计123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; 访问 site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 浏览 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; 阅读 page_pv_footer: 第三方插件安装主要包括本地搜索服务、git部署 本地搜索插件考虑到博文多了以后方便自己查阅，搜索功能必不可少 安装 searchdb 1npm install hexo-generator-searchdb --save 修改主题配置文件 123# Local searchlocal_search: enable: true 修改站点配置文件 12345search: path: search.xml field: post format: html limit: 10000 git部署插件 安装 1npm install hexo-deployer-git --save 修改站点配置文件 1234deploy: type: git repository: git@github.com:jiexiao111/jiexiao111.github.io.git branch: master 部署命令使用 1hexo deploy 压缩网页插件使用 chrome 分析网页加载速度在 chrome 流量器中按 F12 或者单击鼠标右键-&gt;检查, 打开调试栏-&gt;Network, 刷新网页就可以看到以下信息了 多平台共同编辑博客通常我们需要在多个环境下，编辑/发布博客 生成秘钥 git 官方帮助 描述的非常清楚, 如果是 Linux 系统, 首先通过命令生成秘钥, 注意下面命令中的 jiexiao111@gmail.com 是你注册 github 时的邮箱 1ssh-keygen -t rsa -C jiexiao111@gmail.com 想办法把下面这个文件的内容拷贝出来 1~/.ssh/id_rsa.pub 然后打开你的 github 主页, 依次点击 Settings-&gt;SSH and GPG keys-&gt;New SSH key, 然后 Title 随便取个名字，再把 ~/.ssh/id_rsa.pub 中的内容拷贝到 Key 中, Add SSH key 完成添加 新建 repo 用于保存站点配置在 github 中新建 repo, 进入 hexo 安装目录, 将以下文件/目录同步至 repo123456README.md _config.ymlpackage.jsonscaffolds source themes fork Next 主题用于保存主题配置为了能够随时更新 Next 主题, 又能保存自己的主题配置及相关修改, 可以参考同步一个 fork或者官方帮助 第一步, fork Next 主题 第二步, 进入 hexo 的安装目录, 将 fork 好的 Next 主题 clone 到本地, 注意 hexo 目录下应该是默认存在 themes 目录的 1git clone git@github.com:jiexiao111/hexo-theme-next.git themes/next 第三步, 进入 themes/next 目录, 增加上游仓库 12cd themes/nextgit remote add upstream https://github.com/iissnan/hexo-theme-next.git 第四步, 通过git remote -v确认执行结果正确 12345$ git remote -vorigin git@github.com:jiexiao111/hexo-theme-next.git (fetch)origin git@github.com:jiexiao111/hexo-theme-next.git (push)upstream https://github.com/iissnan/hexo-theme-next.git (fetch)upstream https://github.com/iissnan/hexo-theme-next.git (push) 第五步, 获取变更（获取next主题最新的修改），切换到master（一般不需要切换，可以通过git branch看到应该是处于 master 分支），合并更改(获取next主题主线版本的最新修改)，最后把修改推送到fork的分支里 1234git fetch upstreamgit checkout mastergit merge upstream/mastergit push origin master 在新的环境上部署 安装 git、node.js、hexo 后 clone hexo相关配置 12git clone git@github.com:jiexiao111/hexo_jiexiao.gitcd hexo_jiexiao clone hexo相关配置 1git clone git@github.com:jiexiao111/hexo-theme-next.git themes/next 安装相关插件 1npm install 测试新环境的部署功能 1hexo d -g 其他设置及常用操作一些不好分类但是非常有用的设置及操作 设置正文页面宽度编辑hexo_dir/themes/next/source/css/_variables/custom.styl12345// 修改成你期望的宽度$content-desktop = 1000px// 当视窗超过 1600px 后的宽度$content-desktop-large = 1400px 解决网页分类/标签显示错误1234rm db.jsonhexo cleanhexo ghexo s 创建分类和标签在 hexo 安装目录下执行以下命令, 用于增加标签和分类目录12hexo new page tagshexo new page categories 在生成的文件中分别写入以下信息12345678910111213cat &gt; source/tags/index.md ---title: tagsdate: 2017-09-10 12:21:49type: "tags"---cat &gt; source/categories/index.md---title: categoriesdate: 2017-09-10 12:25:38type: "categories"--- Hexo 框架及 Next 主题相关文档链接提供一些高质量的链接，便于参考 Hexo 的官方文档，满满的诚意next 官方文档，进去就充满了好感从 jekyll 转换到 hexo 多亏了下面这篇文章]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hash 实现]]></title>
    <url>%2F2017%2F09%2F10%2FHash%20%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[C语言标准库中未实现hashtable, 在编程练习时经常使用该数据结构，以备不时之需 实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;typedef unsigned char u8_t;typedef char s8_t;typedef unsigned short u16_t;typedef signed short s16_t;typedef unsigned int u32_t;typedef signed int s32_t;typedef long long s64_t;typedef unsigned long long u64_t;typedef s32_t err_t;typedef unsigned long ulong_t;void* xxx_malloc(int size)&#123; void* ret = malloc(size); printf("malloc %p\n", ret); return ret;&#125;void xxx_free(void* ptr)&#123; printf("free %p\n", ptr); free(ptr);&#125;#define offset_of(type, member) ((unsigned long)&amp;((type *)0)-&gt;member)#define container_of(ptr, type, member) \ ((type *)((unsigned char *)ptr - offset_of(type,member)))#define hlist_entry(ptr, type, member) container_of(ptr,type,member)#define hlist_for_each(pos, head) for (pos = (head)-&gt;first; pos; pos = pos-&gt;next)#define hlist_for_each_safe(pos, n, head) \ for (pos = (head)-&gt;first; pos &amp;&amp; (n = pos-&gt;next, 1); pos = n)#define hlist_for_each_entry(type_pos, ptr, pos, head, member) \ for (pos = (head)-&gt;first; pos &amp;&amp; (ptr = hlist_entry(pos, type_pos, member), 1); pos = pos-&gt;next)#define hlist_for_each_entry_safe(type_pos, tpos, pos, n, head, member) \ for (pos = (head)-&gt;first; \ pos &amp;&amp; (&#123; n = pos-&gt;next; 1; &#125;) &amp;&amp; \ (&#123; tpos = hlist_entry(pos, type_pos, member); 1;&#125;); \ pos = n)#define INIT_HLIST_HEAD(ptr) ((ptr)-&gt;first = NULL)struct hlist_head &#123; struct hlist_node *first;&#125;;struct hlist_node &#123; struct hlist_node *next, **pprev;&#125;;static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)&#123; struct hlist_node *first = h-&gt;first; n-&gt;next = first; if (first) first-&gt;pprev = &amp;n-&gt;next; h-&gt;first = n; n-&gt;pprev = &amp;h-&gt;first;&#125;static inline void INIT_HLIST_NODE(struct hlist_node *h)&#123; h-&gt;next = NULL; h-&gt;pprev = NULL;&#125;static inline int hlist_unhashed(const struct hlist_node *h)&#123; return !h-&gt;pprev;&#125;static inline int hlist_empty(const struct hlist_head *h)&#123; return !h-&gt;first;&#125;static inline void __hlist_del(struct hlist_node *n)&#123; struct hlist_node *next = n-&gt;next; struct hlist_node **pprev = n-&gt;pprev; *pprev = next; if (next) next-&gt;pprev = pprev;&#125;static inline void hlist_del_init(struct hlist_node *n)&#123; if (!hlist_unhashed(n)) &#123; __hlist_del(n); &#125;&#125;typedef struct _xxx_hash_bucket_head &#123; struct hlist_head chain; // hash 桶的头结点&#125; xxx_hash_bucket_head;typedef struct _xxx_hashtable &#123; xxx_hash_bucket_head *tbl; // hash 表中的 hash 桶 s8_t *name; // hash 表的名称, 未使用 u32_t cnt; // 保存关键字 hash 后的最大值 u32_t element_cnt; // 记录当前 hash 表中的元素数量 u32_t offset; // hlist_node 成员与包含该成员结构体的地址偏移 u32_t (*hash)(void *); // 关键字的 hash 算法函数 s32_t (*compare)(void *, void *); // 元素的比较函数 void (*destroy)(void *); // 反初始化时对每个元素的反初始化操作函数&#125; xxx_hashtable_t;void *hashtable_init(s8_t *name, u32_t cnt, u32_t offset, u32_t (*hash)(void *), s32_t (*compare)(void *, void *), void (*destroy)(void *))&#123; xxx_hashtable_t *tbl; u32_t i; u32_t size; assert(!(cnt &amp; (cnt - 1))); assert(NULL != hash); assert(NULL != compare); if (NULL == (tbl = (xxx_hashtable_t*)xxx_malloc(sizeof(xxx_hashtable_t)))) &#123; return NULL; &#125; size = sizeof(xxx_hash_bucket_head) * cnt; if (NULL == (tbl-&gt;tbl = xxx_malloc(size))) &#123; xxx_free(tbl); return NULL; &#125; tbl-&gt;name = name; tbl-&gt;cnt = cnt; tbl-&gt;element_cnt = 0; tbl-&gt;offset = offset; tbl-&gt;hash = hash; tbl-&gt;compare = compare; tbl-&gt;destroy = destroy; for (i = 0; i &lt; cnt; i++) &#123; INIT_HLIST_HEAD(&amp;(tbl-&gt;tbl[i].chain)); &#125; return tbl;&#125;void hashtable_fini(void *tbl)&#123; u32_t i; struct hlist_node *pos, *n; xxx_hash_bucket_head *h; u32_t size; u32_t offset; if (NULL == tbl) &#123; return; &#125; offset = ((xxx_hashtable_t *)tbl)-&gt;offset; for (i = 0; i &lt; ((xxx_hashtable_t *)tbl)-&gt;cnt; i++) &#123; h = &amp;((xxx_hashtable_t *)tbl)-&gt;tbl[i]; hlist_for_each_safe(pos, n, &amp;h-&gt;chain) &#123; if (NULL != ((xxx_hashtable_t *)tbl)-&gt;destroy) &#123; ((xxx_hashtable_t *)tbl)-&gt;destroy((void *)((u8_t *)pos - offset)); &#125; &#125; &#125; size = sizeof(struct hlist_head) * ((xxx_hashtable_t *)tbl)-&gt;cnt; xxx_free(((xxx_hashtable_t *)tbl)-&gt;tbl); xxx_free(tbl);&#125;static inline void *hashtable_find(void *tbl, void *elem)&#123; struct hlist_node *pos; xxx_hash_bucket_head *h; u32_t hash; hash = ((xxx_hashtable_t *)tbl)-&gt;hash(elem); assert(hash &lt; ((xxx_hashtable_t *)tbl)-&gt;cnt); h = &amp;((xxx_hashtable_t *)tbl)-&gt;tbl[hash]; hlist_for_each(pos, &amp;h-&gt;chain) &#123; if (!((xxx_hashtable_t *)tbl)-&gt;compare(elem, (u8_t *)pos - ((xxx_hashtable_t *)tbl)-&gt;offset)) &#123; return (void *)((u8_t *)pos - ((xxx_hashtable_t *)tbl)-&gt;offset); &#125; &#125; return NULL;&#125;static err_t hashtable_insert(void* hashtable, void* elem)&#123; struct hlist_node* pos; xxx_hash_bucket_head* bucket; u32_t hash; hash = ((xxx_hashtable_t *)hashtable)-&gt;hash(elem); assert(hash &lt; ((xxx_hashtable_t *)hashtable)-&gt;cnt); bucket = &amp;((xxx_hashtable_t *)hashtable)-&gt;tbl[hash]; hlist_for_each(pos, &amp;bucket-&gt;chain) &#123; if (!((xxx_hashtable_t *)hashtable)-&gt;compare(elem, (u8_t *)pos - ((xxx_hashtable_t *)hashtable)-&gt;offset)) &#123; return -1; &#125; &#125; hlist_add_head((struct hlist_node *)((u8_t *)elem + ((xxx_hashtable_t *)hashtable)-&gt;offset), &amp;bucket-&gt;chain); ((xxx_hashtable_t *)hashtable)-&gt;element_cnt++; return 0;&#125;static inline void hashtable_delete(void *hashtable, void *elem)&#123; xxx_hash_bucket_head *bucket; u32_t hash; hash = ((xxx_hashtable_t *)hashtable)-&gt;hash(elem); assert(hash &lt; ((xxx_hashtable_t *)hashtable)-&gt;cnt); bucket = &amp;((xxx_hashtable_t *)hashtable)-&gt;tbl[hash]; hlist_del_init((struct hlist_node *)((u8_t *)elem + ((xxx_hashtable_t *)hashtable)-&gt;offset)); if (NULL != ((xxx_hashtable_t *)hashtable)-&gt;destroy) &#123; ((xxx_hashtable_t *)hashtable)-&gt;destroy(elem); &#125; ((xxx_hashtable_t *)hashtable)-&gt;element_cnt--;&#125;/* Hash map 实现 */#define MAP_BUCKET_CNT (1 &lt;&lt; 6)typedef struct _str_map_t&#123; int m_value; struct hlist_node hash_node;&#125; str_map_t;/* 创建 str_map_t 对象 */str_map_t* str_map_init();/* 销毁 str_map_t 对象 */void str_map_fini(str_map_t* p_str_map);/* 插入元素 */void str_map_insert(str_map_t* p_str_map);/* 删除元素 */void str_map_erase(str_map_t* p_str_map);/* 查找元素 */void str_map_erase(str_map_t* p_str_map);/* 测试函数 */typedef struct _hlist_demo_t&#123; int m_value; struct hlist_node hash_node;&#125; hlist_demo_t;static u32_t demo_hash(void *pkt)&#123; return (u32_t)(((hlist_demo_t*)pkt)-&gt;m_value) % BUCKET_CNT;&#125;static s32_t demo_compare(void *pkt, void *pkt2)&#123; if (((hlist_demo_t*)pkt)-&gt;m_value == ((hlist_demo_t*)pkt2)-&gt;m_value) &#123; return 0; &#125; return -1;&#125;static void demo_destroy(void *arg)&#123; xxx_free(arg);&#125;int main()&#123;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>hash</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F09%2F10%2Fhello-world.html</url>
    <content type="text"><![CDATA[用于展示不同的MarkDown语法 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. blah blah blah 斜体字 Hash 实现 Deploy to remote sites Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>教程实例</category>
      </categories>
      <tags>
        <tag>demo</tag>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
