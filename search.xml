<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Tensorflow tfdbg]]></title>
    <url>%2F2017%2F10%2F17%2FTensorflow-tfdbg.html</url>
    <content type="text"><![CDATA[Tensorflow 中使用 python 描述计算图，再使用 C++ 后端进行训练时就非常不容跟踪调试，Tensorflow 提供了 tfdbg 模块用于解决这个问题，但是网上的资料较少，所以将自己的一些理解写出来供参考启用 tfdbg官网上 关于 tfdbug 的使用说的非常清楚，仅需要在创建 session 后，使用 session 前加入以下代码：12from tensorflow.python import debug as tf_debugsess = tf_debug.LocalCLIDebugWrapperSession(sess)然后像往常一样启动你的训练模型即可，启动后，可以看到以下界面：tfdbg 基本使用开始调试为了方便说明，就使用官方教程中的例子，执行以下命令：1python -m tensorflow.python.debug.examples.debug_mnist --debug注意：该例子会在第一次执行时从网上下载训练数据，务必保证能访问网络资源，公司内部的同事就需要配置代理第一步一般都是输入命令：run 就可以看到以下界面了print_tensor执行 run 之后，我们可以点击 list_tensors 列表中的带下划线的文字了，例如，点击 hidden/Wx_plus_b/MatMuls:0 就可以看到以下界面第一个问题，这个矩阵表示什么呢？首先，在/usr/local/lib/python3.6/site-packages/tensorflow/python/debug/examples/debug_mnist.py中找到对应的代码1234567891011121314def nn_layer(input_tensor, input_dim, output_dim, layer_name, act=tf.nn.relu): """Reusable code for making a simple neural net layer.""" # Adding a name scope ensures logical grouping of the layers in the graph. with tf.name_scope(layer_name): # This Variable will hold the state of the weights for the layer with tf.name_scope("weights"): weights = weight_variable([input_dim, output_dim]) with tf.name_scope("biases"): biases = bias_variable([output_dim]) with tf.name_scope("Wx_plus_b"): preactivate = tf.matmul(input_tensor, weights) + biases activations = act(preactivate) return activations其实，这个矩阵就是 preactivate 的值，为什么这里不直接显示 preactivate 的变量名呢？ 因为 Tensorflow 的后端根本不知道这个局部变量，后端能获取的只有 Tensor（比如 tf.Variable） 或者 Option（比如 tf.matmul）, 所以，我们得出结论，点击 list_tensors 列表中的 Tensor/Option 后，显示的就是这个 Tensor 的值或者 Option 的运算结果和维度信息，这对我们理解模型相当有帮助，比如，有些难以理解的运算我们可以根据运算结果演算一遍。第二个问题，hidden/Wx_plus_b/MatMuls:0 是怎么和代码对应起来的？Tensorflow 中，所有的 Tensor/Option 都有唯一的名字，命名的规则是 tf.name_scope + name 参数123456with tf.name_scope("Any_Scope"): with tf.name_scope("First_Scope"): V1 = tf.Variable(shape, name='First') with tf.name_scope("Second_Scope"): V2 = tf.Variable(shape) V3 = tf.Variable(shape)这段代码中，V1/V2/V3 对应的 Tensor 的名字分别为：Any_Scope/First_Scope/First、Any_Scope/Second_Scope/Variable、Any_Scope/Second_Scope/Variable_1 可以看出，如果不指定 name 参数 则默认为 Tensor/Option 的类名，如果相同 Scope 中有相同 name 的 Tensor/Option 则自动为名称添加序号在问题一中，layer_name 为 hidden，所以 preactivate = tf.matmul(input_tensor, weights) + biases 的名称就是 hidden/Wx_plus_b/MatMuls:0node_info输入及输出信息点击 hidden/Wx_plus_b/MatMuls:0 后默认显示的就是上一小节提到的 print_tensor，此时我们可以点击 node_info，点击后显示以下信息：红框中的信息包括：1、MatMul 操作通过 cpu 执行 2、两个操作数分别为训练的输入数据 x-input 和表示权重的 Variable 3、输出的结果被用于加法操作调用栈信息此时可以按 pagedown 向下滑动，查看代码调用栈：清晰的展示出，main 函数调用了 nn_layer 函数，然后执行了 87 行的 MatMuls 操作，同时，如果不清楚库函数定义所在的文件，也可以在这里找到。当前代码行对应的其他 Tensor/Option此时，可以点击 Line: 87, 就可以看到 87 行相关的其他 Tensor/Option 的信息了nn_layer 一共被调用了两次，且 87 行包含了两个操作 （MatMuls、add）, 所以一共是四个 Option 信息，此时，点击 softmax/Wx_plus_b/MatMuls:0 可以看到以下信息：list_inputs点击 list_inputs 可以看到 softmax/Wx_plus_b/MatMuls:0 详细输入：可以看出，softmax/Wx_plus_b/MatMuls:0 的左操作数是 hidden/Relu， 右操作数是 softmax/weights/Variable/read，hidden/Relu 只有一个操作数 hidden/Wx_plus_b/add, 依次类推，可以查看计算 softmax/Wx_plus_b/MatMuls:0 的每一步操作list_outputs点击 list_outputs 可以看到 softmax/Wx_plus_b/MatMuls:0 的输出的详细用途：首先，输出被用于 softmax/Wx_plus_b/MatMuls，依次类推，最终被用于加权平均run_info点击 run_info 可以看到以下信息：这里可以点击红框部分查看训练 / 测试样本的输入 / 输出单步运行输入 s 就可以单步调试了，s -t 10 可以执行 10 步，需要注意的是，一定是执行 run 命令后才可以执行 s 命令理解记忆调试命令鼠标点击能查看的信息毕竟有限，直接看 help 又不好理解，好在 tfdbg 中始终会显示当前显示信息所对应的命令：很明显 pt 就表示 print_tensor，如果需要了解 pt 的更多参数，就可以执行 help pt我们可以试试 pt -a accuracy/accuracy/Cast:0]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用 Github + Hexo 搭建个人博客]]></title>
    <url>%2F2017%2F10%2F15%2FGithub%2BHexo_BLOG.html</url>
    <content type="text"><![CDATA[Github 让个人技术博客的创建变得异常简单，Hexo 框架 + Next 主题提供了高度定制且美观的个人博客，本文记录了搭建过程Hexo 与 jekyll 框架的选择经过两天的折腾，彻底放弃使用 jekyll 搭建自己的技术 Blog, 究其原因就是目录、sitemap 无法自动生成，一个没有前端开发经验的我最终发现 Hexo。Hexo 能够满足我对 Blog 的所有想法：1、我只负责写内容，至于文章的按标签分类还是按日期归档我都不关心，但是我需要使用这些功能2、文章要有一个漂亮的内容导航栏，开发做多了，对始终能在一屏内了解当前文件的整体结构有着某种偏执3、sitemap、文章目录最好能够复用网页位置，以便留出更多的位置显示正文，尽量少的翻页绝对能提升生产效率个人博客搭建依次安装 git、node.js、hexo、next 主题安装 git官网 描述的很清楚我最常用的是 Ubuntu，只需要执行以下命令即可：1apt-get install git安装 node.js一开始，我以为使用的 Ubuntu-16.04LTS 已经很新了，所以就直接使用 apt-get 安装了，结果在安装 hexo 时出现错误。网上整了一堆高级方法都没能解决。最终参考 node.js 官网，直接 download 官方的首页的最新的 LTS 版本 node-v6.11.3-linux-x64.tar.xz，解压至 /usr 目录1tar -vxf node-v6.11.3-linux-x64.tar.xz -C /usr/默认 hexo 安装的位置与 npm 一致，所以如果没有把 npm 所在路径加入环境变量，则安装 hexo 后会发现无法找到 hexo 命令，所以建议将 node.js 的安装路径加入 ~/.bashrc1echo 'export PATH="/usr/node-v6.11.3-linux-x64/bin:$PATH' &gt;&gt; ~/.bashrc如果你和我一样使用 zsh，就放到 ~/.zshrc 中1echo 'export PATH="/usr/node-v6.11.3-linux-x64/bin:$PATH' &gt;&gt; ~/.zshrc添加环境变量后记得 source12source ~/.bashrcsource ~/.zshrc安装 hexo创建一个目录，比如 hexo_dir, 用于安装 hexo, 通过 npm 命令安装 hexo123mkdir hexo_dircd hexo_dirnpm install -g hexo-cli安装 next 主题hexo 的安装路径下有一个 themes 目录，hexo 默认会使用该目录下的主题，所以一定要在 hexo 安装目录下执行1git clone https://github.com/iissnan/hexo-theme-next themes/next如果你想能够更新 next 主题，且又想通过 github 管理你的主题定制信息，那么需要麻烦一些，可以参考下面的 多平台共同编辑博客Github 创建博客只需要在 github 上创建 用户名 +github.io 的 Repo 即可创建成功后，就可以通过 https:// 用户名.github.io/ 访问了，比如我就是通过 https://jiexiao111.github.io/ 访问站点配置文件修改在 hexo 安装目录下可以找到 config.yml 文件，这个文件就是站点配置文件，修改站点配置文件后，需要重起 hexo 服务，才能生效1hexo s启用 next 主题编辑站点配置文件1theme: next验证 next 主题，在 hexo 安装目录下执行 hexo s –debug，如果未出现错误，则在浏览器中访问以下位置1http://localhost:4000/修改默认标题、子标题、描述、作者、字符集编辑站点配置文件123456# Sitetitle: JieXiao's Blogsubtitle:description:author: JIE XIAOlanguage: zh-Hans主题配置文件修改hexo 目录下的 themes/next/ 子目录中也有一个 config.yml 文件，这个文件就是主题配置文件，修改主题配置文件后立即生效，无需重启 hexo 服务修改 Next 主题风格个人偏向于在一屏内显示更多的内容所以选择了 Mist 风格12345# Schemes# scheme: Musescheme: Mist# scheme: Pisces# scheme: Gemini设置侧边栏Next 主题的文章目录导航和作者介绍复用了侧边栏，非常不错123sidebar: position: left display: always修改字体12345678910111213141516171819202122232425262728293031font: enable: true # 外链字体库地址，例如 //fonts.googleapis.com （默认值） host: # 全局字体，应用在 body 元素上 global: external: true family: Monda # 标题字体 (h1, h2, h3, h4, h5, h6) headings: external: true family: Roboto Slab # 文章字体 posts: external: true family: # Logo 字体 logo: external: true family: Lobster Two size: 24 # 代码字体，应用于 code 以及代码块 codes: external: true family: PT Mono修改代码风格1highlight_theme: night侧边栏中增加社交信息123456social: GitHub: https://github.com/jiexiao111 E-Mail: mailto:jiexiao111@gmail.comsocial_icons: GitHub: github E-Mail: email开启背景动画1canvas_nest: true开启公式显示12mathjax: enable: true开启访问统计123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; 访问 site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 浏览 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; 阅读 page_pv_footer:第三方插件安装主要包括本地搜索服务、git 部署本地搜索插件考虑到博文多了以后方便自己查阅，搜索功能必不可少安装 searchdb1npm install hexo-generator-searchdb --save修改主题配置文件123# Local searchlocal_search: enable: true修改站点配置文件12345search: path: search.xml field: post format: html limit: 10000git 部署插件安装1npm install hexo-deployer-git --save修改站点配置文件1234deploy: type: git repository: git@github.com:jiexiao111/jiexiao111.github.io.git branch: master部署命令使用1hexo deploy压缩网页插件安装 hexo-neat1npm install hexo-neat --save修改站点配置，增加以下信息12345678910111213141516171819# hexo neat configneat_enable: trueneat_html: enable: true exclude:neat_css: enable: true exclude: - '*.min.css'neat_js: enable: true mangle: true output: compress: exclude: - '*.min.js'留言插件http://barrysite.me/2017/05/08/hexo%E7%BD%91%E7%AB%99NexT%E4%B8%BB%E9%A2%98%E5%A2%9E%E5%8A%A0%E7%95%99%E8%A8%80%E9%A1%B5/多平台共同编辑博客通常我们需要在多个环境下，编辑 / 发布博客生成秘钥git 官方帮助 描述的非常清楚，如果是 Linux 系统，首先通过命令生成秘钥，注意下面命令中的 jiexiao111@gmail.com 是你注册 github 时的邮箱1ssh-keygen -t rsa -C jiexiao111@gmail.com想办法把下面这个文件的内容拷贝出来1~/.ssh/id_rsa.pub然后打开你的 github 主页，依次点击 Settings-&gt;SSH and GPG keys-&gt;New SSH key, 然后 Title 随便取个名字，再把 ~/.ssh/id_rsa.pub 中的内容拷贝到 Key 中，Add SSH key 完成添加新建 repo 用于保存站点配置在 github 中新建 repo, 进入 hexo 安装目录，将以下文件 / 目录同步至 repo123456README.md_config.ymlpackage.jsonscaffoldssourcethemesfork Next 主题用于保存主题配置为了能够随时更新 Next 主题，又能保存自己的主题配置及相关修改，可以参考同步一个 fork 或者官方帮助第一步，fork Next 主题第二步，进入 hexo 的安装目录，将 fork 好的 Next 主题 clone 到本地，注意 hexo 目录下应该是默认存在 themes 目录的1git submodule add git@github.com:jiexiao111/hexo-theme-next.git themes/next第三步，进入 themes/next 目录，增加上游仓库12cd themes/nextgit remote add upstream https://github.com/iissnan/hexo-theme-next.git第四步，通过 git remote -v 确认执行结果正确12345$ git remote -vorigin git@github.com:jiexiao111/hexo-theme-next.git (fetch)origin git@github.com:jiexiao111/hexo-theme-next.git (push)upstream https://github.com/iissnan/hexo-theme-next.git (fetch)upstream https://github.com/iissnan/hexo-theme-next.git (push)第五步，获取变更（获取 next 主题最新的修改），切换到 master（一般不需要切换，可以通过 git branch 看到应该是处于 master 分支），合并更改（获取 next 主题主线版本的最新修改），最后把修改推送到 fork 的分支里1234git fetch upstreamgit checkout mastergit merge upstream/mastergit push origin master在新的环境上部署安装 git、node.js、hexo 后clone hexo 相关配置1git clone --recursive git@github.com:jiexiao111/hexo_jiexiao.git安装相关插件12cd hexo_jiexiaonpm install测试新环境的部署功能1hexo d -g其他设置及常用操作一些不好分类但是非常有用的设置及操作设置正文页面宽度编辑 hexo_dir/themes/next/source/css/_variables/custom.styl12345// 修改成你期望的宽度$content-desktop = 1000px// 当视窗超过 1600px 后的宽度$content-desktop-large = 1400px解决网页分类 / 标签显示错误1234rm db.jsonhexo cleanhexo ghexo s创建分类和标签在 hexo 安装目录下执行以下命令，用于增加标签和分类目录12hexo new page tagshexo new page categories在生成的文件中分别写入以下信息12345678910111213cat &gt; source/tags/index.md---title: tagsdate: 2017-09-10 12:21:49type: "tags"---cat &gt; source/categories/index.md---title: categoriesdate: 2017-09-10 12:25:38type: "categories"---使用 chrome 分析网页加载速度在 chrome 流量器中按 F12 或者单击鼠标右键 -&gt;检查，打开调试栏 -&gt;Network, 刷新网页就可以看到以下信息了Hexo 框架及 Next 主题相关文档链接提供一些高质量的链接，便于参考Hexo 的官方文档，满满的诚意next 官方文档，进去就充满了好感从 jekyll 转换到 hexo 多亏了下面这篇文章]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用快捷键汇总]]></title>
    <url>%2F2017%2F10%2F15%2Fkeboard_shortcuts.html</url>
    <content type="text"><![CDATA[日常使用的快捷键太多，分散存储不易查找，得益于 Next 主题优秀的目录导航，可以将所有的快捷键统一记录Item2Mac 下的 Item2 真心好用标签新建标签：command + t关闭标签：command + w关闭标签：command + z切换标签：command + 数字选择标签：command + 左右方向键 或者 command + { 或 command + }窗口垂直分屏：command + d水平分屏：command + shift + d最大化当前分屏：command + shift + Enter切换屏幕：command + option + 方向键 或者 command + [ 或 command + ]预览所有窗口 + 搜索：command + option + e历史查看命令历史：command + ;查看剪贴板历史：command + shift + h其他切换全屏：command + enter查找：command + f高亮光标：command + /标记：command + shift + m跳转：command + shift + jChrome通常只需要查看帮助 [?] 即可，不过自己写的东西理解起来还是要容易些滚动向下滚动：j向上滚动：k向左滚动：h向右滚动：l滚动到最上方：gg滚动到最下方：G滚动到最左方：zH滚动到最右方：zL向下滚动半页：d向上滚动半页：u常用后退：H前进：L刷新：r查找：/下一个匹配：n上一个匹配：N选中地址栏：command/Ctrl + l隐藏标签栏：Ctrl + Shift + BURL 相关操作拷贝当前 URL: yy拷贝指定 URL: yf *相当于鼠标右键 -&gt;复制链接*打开上一级 URL: gu打开最上级 URL: gU在当前标签打开链接：f *最常用的键，相当于鼠标左键*在新建标签打开链接：F在当前标签页中打开剪切板中的 URL: p在新建标签页中打开剪切板中的 URL: P输入进入编辑模式：i *比如说要在 jupyter 中编辑的时候，要先切换至编辑模式，否则快捷键均被覆盖*选择输入框：gi *相当于鼠标左键点击输入框*选择下一个 frame: gf *很多页面只有一个 frame 所以不常用*选择上一个 frame: gF快速检索打开快速检索窗口，搜索书签 / 历史记录：o打开快速检索窗口，搜索书签 / 历史记录，在新建标签中打开链接：O打开快速检索窗口，搜索书签：b打开快速检索窗口，搜索书签，在新建标签中打开链接：B打开快速检索窗口，将当前 URL 自动填入便于编辑：ge打开快速检索窗口，将当前 URL 自动填入便于编辑，在新建标签中打开链接：gE打开快速检索窗口，搜索 Tab 标签：T *在 Tab 页很多的时候很好用*Tab 页新建 Tab 页：t关闭当前标签页：x打开最近关闭的标签页：X选择上一个 Tab 页：J/gT *经常遇到不能使用 vimium 的网页只能使用 Tab 键替代*选择下一个 Tab 页：K/gt *经常遇到不能使用 vimium 的网页只能使用 Shift Tab 键替代*选择最近浏览的 Tab 页：^选择第一个 Tab 页：g0选择最后一个 Tab 页：g$将当前标签页向左移动：&lt;&lt;将当前标签页向右移动：&gt;&gt;在新建页中打开当前页面：yt *很常用，相当于 yy 复制当前链接，P 打开新的链接*将当前标签移至新窗口：W *相当于鼠标拖拽标签页至窗口外*其他帮助：?查看网页源码：gs不知道能干什么…Open multiple links in a new tab: &lt; a-f &gt;Enter visual mode: vEnter visual line mode: VFollow the link labeled previous or &lt;: [[Follow the link labeled next or &gt;: ]]Create a new mark: mGo to a mark: `Pin or unpin current tab: &lt; a-p &gt;Mute or unmute current tab: &lt; a-m &gt;Vimvim 需要记得太多了，用了几年有些都还不知道，汇总一下实用的，不常用的就不罗列了普通模式折叠zi 在 vim 中取消、生效折叠移动左右左移：h右移：l行尾：$行首：0非空行首：^前向行内查找：f{char}后向行内查找：F{char}前向行内查找，目标字符前一个位置：t{char}后向行内查找，目标字符后一个位置：T{char}重复行内查找：;反向重复行内查找：,上下上移：k下移：j至尾行：G至首行：gg至第 n 尾行：nG至全文件 %n 处：n%文本对象向右 N 个单词：w向右 N 个单词，停在词尾：e向右 N 个空白隔开的单词：W向右 N 个空白隔开的单词，停在词尾：E向左 N 个单词：b向左 N 个单词，停在词尾：ge向左 N 个空白隔开的单词：B向左 N 个空白隔开的单词，停在词尾：gE向前 N 个句子：)向后 N 个句子：(向前 N 个段落：}向后 N 个段落：{查找向前查找{: ]]向后查找{: [[向前查找}: ][向后查找}: []第一个 [ 表示方向，重复的找 {, 不同的找 }向前查找): ])向后查找(: [(向前查找}: ]}向后查找{: [{向前查找 #else 或 #endif: ]#向后查找 #if 或 #else: [#向前查找 */: ]*向后查找 /*: [*查找：/反向查找：?重复查找：n反向重复查找：N可以使用正则表达式按光标下的单词查找：*按光标下的单词反向查找：#查找高亮的文本：{visual} *反向查找高亮的文本：{visual} #查找光标下的局部变量：gd查找光标下的全局变量：gD标记与跳转标记：m{a-zA-Z}文件内跳转：&#39;{a-z}全局跳转：&#39;{A-Z}跳转至文件最后被改动的位置：&#39;.列出活动的位置标记：:marks向后跳转：Ctrl + o向前跳转：Ctrl + i列出跳转列表：:ju转到当前光标下标签的定义：Ctrl + ]跳转至本行中{ ( [等的对称位置：%窗口顶部：H窗口底部：L窗口中部：M滚动向下滚动一行：Ctrl + e向上滚动一行：Ctrl + y向左滚动一列：zh向右滚动一列：zl向下滚动半屏：Ctrl + d向上滚动半屏：Ctrl + u向左滚动半屏：zH向右滚动半屏：zL当前行置为窗口顶部：zt当前行置为窗口中部：zz当前行置为窗口底部：zb编辑删除整行：dd复制整行：yy删除行内容：D连接行：J连接行，但不插入空格：gJ粘贴至光标后：p粘贴至光标前：P粘贴至光标后，缩进与光标所在行一致：]p粘贴至光标前，缩进与光标所在行一致：]P粘贴至光标后，光标停留在粘贴文本后：gp粘贴至光标前，光标停留在粘贴文本后：gP交换当前光标及下一个字符：xp交换当前光标及上一个字符：Xp替换字符：r替换字符并不影响布局：gr将光标之上或之后的数值增加 N: CTRL-A将光标之上或之后的数值减少 N: CTRL-X进入 visual 模式以字符方式开始高亮：v使用上一次的可视区域开始高亮：gv以行方式开始高亮：V以列块方式开始高亮：CTRL-V选择一个单词：aw选择一个单词，不包括词尾空格：iw选择一段不包含空白符的字串：aW选择一段不包含空白符的字串，不包含词尾空格：iW进入编辑模式光标前插入：i光标后插入：a行首非空插入：I行首插入：gI行末插入：A当前行下方插入新行：o当前行上方插入新行：O插入光标下方的字符：Ctrl + e插入光标上方的字符：Ctrl + y进入替换模式：R进入替换模式，但不影响布局：gR删除行，并进入插入模式：cc删除字符，并进入插入模式：s翻转大小写并前进光标：~编辑模式快捷键补全路径：Ctrl + x Ctrl + f向前删除单词：Ctrl + w删除一段时间内输入的字符：Ctrl + u增加缩进：Ctrl + t减少当前行的缩进：Ctrl + dvisual 模式删除高亮的文本：d删除高亮的文本，进入编辑模式：c删除高亮的行，进入编辑模式：C复制高亮的文本：y替换高亮的文本：r连接高亮行：J连接高亮行，但不插入空格：gJ翻转高亮文本的大小写：~改高亮的文本为小写：u改高亮的文本为大写：U交换高亮区域的开始处和光标位置：o选择 “一个句子” (sentence): as选择 “内含句子”: is选择 “一个段落” (paragraph): ap选择 “内含段落”: ip选择 “一个块” （从 “[(“ 至 “])”) (block): ab选择 “内含块” （从 “[(“ 到 “])”): ib选择 “一个大块” （从 “[{“ 到 “]}”) (Block): aB选择 “内含大块” （从 “[{“ 到 “]}”): iB选择 “一个 &lt;&gt; 块”: a&gt;选择 “内含 &lt;&gt; 块”: i&gt;选择 “一个标签块” （从到) (tag): at选择 “内含标签块” （从到): it选择 “一个单引号字符串”: a&#39;选择 “内含单引号字符串”: i&#39;选择 “一个双引号字符串”: a&quot;选择 “内含双引号字符串”: i&quot;选择 “一个反引号字符串”: ``a1选择 &quot;内含反引号字符串&quot;: ``i命令行将文件的内容插入到下一行：:r {file}将命令结果插入到下一行：:r {file}显示寄存器的内容：:regmotion删除动作 {motion} 覆盖的文本，并进入插入模式：c{motion}将动作 {motion} 覆盖的文本翻转大小写：g~{motion}将动作 {motion} 覆盖的文本改为小写：gu{motion}将动作 {motion} 覆盖的文本改为大写：gU{motion}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665改变文本重复最近一次改动 （将计数改为 N): ``.``记录键入的字符，存入寄存器 &#123;a-z&#125;: ``q&#123;a-z&#125;``记录键入的字符，添加进寄存器 &#123;a-z&#125;: ``q&#123;A-Z&#125;``终止记录：``q``执行寄存器 &#123;a-z&#125; 的内容 (N 次）: ``@&#123;a-z&#125;``重复上次的 @&#123;a-z&#125; 操作 (N 次）: ``@@``将寄存器 &#123;a-z&#125; 的内容当作 Ex 命令来执行：``:@&#123;a-z&#125;``重复上次的 :@&#123;a-z&#125; 操作：``:@@``撤销最近的 N 此改动：``u``重做最近的 N 个被撤销的改动：``CTRL-r``恢复最近被改动的行：``U``执行 shell 命令：``:!&#123;command&#125;``查看光标下的标识符的 man 帮助：``K``显示第 [nr] 个错误 （缺省为同一错误）: ``:cc [nr]``显示下一个错误：``:cn``显示上一个错误：``:cp``列出所有错误：``:cl``显示 quickfix 窗口：``:cw``以十进制、十六进制和八进制显示当前光标下的字符：``ga``重新载入当前文件：``:e``编辑第 N 个轮换文件名：``CTRL-^``显示所有的轮换文件名：``:files``编辑光标下的文件名对应的文件：``gf``显示当前目录名：``:pwd``切换当前目录到 [path]: ``:cd [path]``回到上一次当前目录：``:cd -``将当前文件目录设置为工作目录：``,cd``置光标于第 [num] 行 （缺省：末行）: ``+[num]``置光标于第一次出现 &#123;pat&#125; 的地方：``+/&#123;pat&#125; &#123;file&#125; ..``写入当前文件改动，并退出：``ZZ``放弃当前文件修改退出：``ZQ``挂起 vim: ``CTRL-z``回复 vim: ``fg``写入所有改动的缓冲区并退出：``:xa``退出 Vim，放弃所有改动：``:qa!``快速保存：``,w``分隔窗口并在其中一个编辑 &#123;file&#125;: ``:split &#123;file&#125;``同上，但垂直分割：``:vsplit &#123;file&#125;``分割窗口并跳转到光标下的标签：``CTRL-W ]``分割窗口并编辑光标下的文件名 (file): ``CTRL-W f``分割窗口并编辑轮换文件：``CTRL-W ^``创建新空白窗口 (new): ``CTRL-W n``退出编辑并关闭窗口 (quit): ``CTRL-W q``隐藏当前缓冲区并关闭窗口 (close): ``CTRL-W c``使当前窗口成为唯一窗口 (only): ``CTRL-W o``跳转到下方窗口：``CTRL-j``跳转到上方窗口：``CTRL-k``跳转到左方窗口：``CTRL-h``跳转到右方窗口：``CTRL-l``跳转到顶端窗口 (top): ``CTRL-W t``跳转到底端窗口 (bottom): ``CTRL-W b``跳转到上一次激活的窗口 (previous): ``CTRL-W p``向下旋转窗口 (rotate): ``CTRL-W r``向上旋转窗口 (Rotate): ``CTRL-W R``将当前窗口与下一个窗口对调 (eXchange): ``CTRL-W x``使所有窗口等高：``CTRL-W =``减少当前窗口高度：``CTRL-W -``增加当前窗口高度：``CTRL-W +``设置当前窗口高度 （缺省：很高）: ``CTRL-W _``将当前窗口移动到右侧：``Ctrl + w L``将当前窗口移动到左侧：``Ctrl + w H``将当前窗口移动到下面：``Ctrl + w J``将当前窗口移动到上面：``Ctrl + w K``折叠删除光标下的一个折叠 (delete)zd折叠删除光标下的所有折叠 (Delete)zD折叠打开光标下的折叠 (open)zo折叠打开光标下的所有折叠 (Open)zO折叠关闭光标下的一个折叠 (close)zc折叠关闭光标下的所有折叠 (Close)zC折叠折起更多：减少 &apos;foldlevel&apos; (more)zm折叠关闭所有折叠：置 &apos;foldlevel&apos; 为 0zM折叠减少折叠：增加 &apos;foldlevel&apos; (reduce)zr折叠打开所有折叠：置 &apos;foldlevel&apos; 为最大zR折叠不折叠：复位 &apos;foldenable&apos; (none)zn折叠正常折叠：置位 &apos;foldenable&apos; (Normal)zN折叠反转 &apos;foldenable&apos; (invert)ziMRU打开最近访问的文件，fMRU在当前窗口打开EnterMRU在新建水平窗口打开该文件oMRU在新建垂直打开该文件OMRU只读打开vMRU在新的 tab 打开tMRU在新的 tab 打开错误修改 mru.vim 中对应行 exe &apos;tabnew &apos; . a:esc_fnameCtrlp打开文件模糊搜索Ctrl + Fctrlp设置 ctrlp 垂直分割打开窗口，防止和粘贴重复let g:ctrlp_prompt_mappings = &#123; &apos;AcceptSelection(&quot;v&quot;)&apos;: [&apos;&lt;c-g&gt;&apos;] &#125;ctrlp查看基本操作帮助:csNERD TreeNERDTreeToggle，nnNERD TreeNERDTreeFromBookmark，nbNERD TreeNERDTreeFind，nfNERD Tree打开 / 关闭帮助?tab新建一个标签页，tntab关闭其他标签，totab关闭标签，tctab移动便签至指定标签之后，tmtab打开指定标签，t，tab打开最近访问的标签，tltab打开新的标签页，新页的内容与当前页一致，tetab打开上一标签gTtab打开下一标签gtbuffers关闭当前 buffer，bdbuffers关闭所有 buffer，babuffers显示当前所有 buffers，oAg快速搜索，gAg选取模式下，搜索选中的内容gvAg选取模式下，搜索并替换选中的内容，rAg在新建窗口中显示结果，ccAg在新建窗口显示下一个搜索结果，nAg在新建窗口显示上一个搜索结果，pAg帮助信息:h ag-mappingsbasic.vim取消高亮，&lt;cr&gt;Goyo开启 goyo 模式，zoption设置查找时忽略大小写:set ignorecaseoption设置查找时大小写敏感:set noignorecasesurround可视模式下，添加 ()1surround可视模式下，添加 []2surround可视模式下，添加 &#123;&#125;3surround可视模式下，添加 &quot;&quot;$$surround可视模式下，添加 &apos;&apos;$q命令组合搜索并将 int 替换为 s32_t/intcws32_t&lt;esc&gt;n.cscopefind all references to the token under cursorCTRL-\ scscopeglobal: find global definition(s) of the token under cursorCTRL-\ gcscopecalls: find all calls to the function name under cursorCTRL-\ ccscopetext: find all instances of the text under cursorCTRL-\ tcscopecalls: find all calls to the function name under cursorCTRL-\ ecscopeegrep: egrep search for the word under cursorCTRL-\ fcscopeincludes: find files that include the filename under cursorCTRL-\ icscopecalled: find functions that function under cursor callsCTRL-\ dcscope在新建水平窗口打开CTRL-\ sscscope在新建垂直窗口打开CTRL-\ CTRL-\ scscope设置 cscope 从右边打开新建垂直窗口:set splitrightcscope设置结果显示至 quickfix 窗口h cscopequickfixman快速打开 man 帮助:source $VIMRUNTIME/ftplugin/man.vim:nmap K :Man &lt;c-r&gt;&lt;c-w&gt;&lt;cr&gt;:echo $VIMRUNTIME 修改 man.vim 中的 new 为 vnewYankRing在插入模式下选择上一个粘贴的内容CTRL-pYankRing在插入模式下选择下一个粘贴的内容CTRL-nYankRing显示所有剪切内容:YRShowBufExplorer查看帮助F1commentary注释 / 反注释单行gcccommentary注释 / 反注释高亮部分&#123;visual&#125; gcSnipMate打开可选的补全列表 / 选择可选的补全列表&lt;Tab&gt;SnipMate选择上一个可选项Ctrl - pSnipMate选择下一个可选项Ctrl - nMRU 打开最近访问的文件 ，fMRU 在当前窗口打开 EnterMRU 在新建水平窗口打开该文件 oMRU 在新建垂直打开该文件 oMRU 只读打开 vMRU 在新的 tab 打开 tCtrlp 打开文件模糊搜索 Ctrl + FNERD Tree NERDTreeToggle ，nnNERD Tree NERDTreeFromBookmark ，nbNERD Tree NERDTreeFind ，nftab 新建一个标签页 ，tntab 关闭其他标签 ，totab 关闭标签 ，tctab 移动便签至指定标签之后 ，tmtab 打开指定标签 ，t，tab 打开最近访问的标签 ，tltab 打开新的标签页，新页的内容与当前页一致 ，tetab 打开上一标签 gTtab 打开下一标签 gtwindows 切换至左边窗口 Ctrl + hwindows 切换至下边窗口 Ctrl + jwindows 切换至上边窗口 Ctrl + kwindows 切换至右边窗口 Ctrl + lwindows 打开水平窗口 spwindows 打开垂直窗口 vswindows 关闭非激活窗口 onlywindows 将当前窗口移动到右侧 Ctrl + w Lwindows 将当前窗口移动到左侧 Ctrl + w Hwindows 将当前窗口移动到下面 Ctrl + w Jwindows 将当前窗口移动到上面 Ctrl + w Kwindows 关闭所有窗口 :qawindows 保存所有窗口 :wawindows 保存并关闭所有窗口 :wqawindows 放弃保存并关闭所有窗口 :qa!buffers 关闭当前 buffer ，bdbuffers 关闭所有 buffer ，babuffers 显示当前所有 buffers ，oAck 暂时不知道 ACK 怎么指定搜索路径，可以在 Vim 中通过 cd 命令进入指定目录再搜索 Ag 快速搜索 ，gAg 选取模式下，搜索选中的内容 gvAg 选取模式下，搜索并替换选中的内容 ，rAg 在新建窗口中显示结果 ，ccAg 未知 ，coAg 在新建窗口显示下一个搜索结果 ，nAg 在新建窗口显示上一个搜索结果 ，pbasic.vim 取消高亮 ，&lt;cr&gt;basic.vim 将工作目录指定为当前标签的路径 ，cdbasic.vim 前向搜索 spacebasic.vim 前向搜索光标所在单词 *basic.vim 后向搜索光标所在单词 #合并行 J撤销 u重做 Ctrl + r代码补全 Ctrl + N/P保存文件并退出 vi ZZ放弃更改并退出 vi :q!Goyo 开启 goyo 模式 ，z挂起 vim Ctrl + z恢复 vim fg执行 shell 命令 ！ 动作：文本对象 光标向前移动到下一个单词的词首 w动作：文本对象 光标向后移动到上一个单词的词首 b动作：文本对象 光标向前移动到下一个单词的词末 e动作：文本对象 光标向后移动到上一个单词的词末 ge动作：文本对象 光标向前移动到下一个字串的词首 W动作：文本对象 光标向后移动到上一个字串的词首 B动作：文本对象 光标向前移动到下一个字串的词末 E动作：文本对象 光标向后移动到上一个字串的词末 gE动作：左右 至当前行（加上 N-1 后续行）的行尾 N $动作：左右 至屏幕行（加上 N-1 后续行）的行尾 N g$动作：左右 至当前行的第一个非空字符 ^动作：左右 至屏幕行的第一个非空字符 g^动作：左右 至当前行的第一个字符 0动作：左右 至屏幕行的第一个字符 g0动作：左右 至屏幕行的中点 gm动作：左右 至第 N 列 N |动作：左右 至右边第 N 次出现 &#123;char&#125; 之处——find N f&#123;char&#125;动作：左右 至左边第 N 次出现 &#123;char&#125; 之处——Find N F&#123;char&#125;动作：左右 至右边第 N 次出现 &#123;char&#125; 之前——till N t&#123;char&#125;动作：左右 至左边第 N 次出现 &#123;char&#125; 之前——Till N T&#123;char&#125;动作：左右 重复上次 f、t、F、T 命令 N 次 N ;动作：左右 反方向重复上次 f、t、F、T 命令 N 次 N ,移动到匹配的括号上 %移动到第 n 行 nG移动到第一行 gg移动到最后一行 G移动到视野中接近上方的行 H移动到视野中中部的行 M移动到视野中接近下方的行 L向下滚动一行 Ctrl + y向上滚动一行 Ctrl + e向下滚动一屏 Ctrl + f向上滚动一屏 Ctrl + b向下滚动半屏 Ctrl + d向上滚动半屏 Ctrl + u滚动屏幕使当前行成为靠上的行 zt滚动屏幕使当前行成为靠下的行 zb滚动屏幕使当前行成为靠中的行 zz前向查找字符串 /反向查找字符串 ?重复前一次查找 n反方向重复前一次查找 N设置查找时忽略大小写 :set ignorecase设置查找时大小写敏感 :set noignorecase查找上一次字符串 /&lt;up&gt;查找上一次以 a 开头的字符串 /a&lt;up&gt;向前查找光标下的单词 *向后查找光标下的单词 #查找整个单词 the，其中 \&lt;、\&gt; 分别匹配单词的开头和结尾 /\&lt;the\&gt;查找处于行尾的 the /the$查找处于行首的 the /^the查找 com 或者 cam /c.m查找 .com /\.com在两个位置间跳转，跳转指的是移动到本行以外的命令，但是不包括 j、k 命令 &apos;&apos;跳转至函数定义 Ctrl + ]跳转至一个较新的位置 Ctrl + o跳转至一个较旧的位置 Ctrl + i输出可以跳往的位置 :jumps增加书签，参数可以选择 26 个字母，所以最多可以设置 26 个书签 ma跳转至书签 &apos;a跳转至最近编辑的光标位置 ,&quot;跳转至最近修改的开始位置 ,[跳转至最近修改的结束位置 ,]删除一整行 dd删除 4 个单词 d4w从当前位置一直删除到本行末尾 d$删除一个单词并切换到插入模式 cw修改一整行 cc删除当前光标下的字符，表示 dl x删除光标左边的字符，表示 dh X删除当前位置到行尾，表示 d$ D修改当前位置到行尾，表示 c$ C修改一个字符，表示 c1 s修改一整行，表示 cc S替换一个字符 r修改光标下字符的大小写，并移动到下一个字符 ~使多个字符被同一个字符 x 替换 5rx重复同一个修改 .将 int 型替换为 s32_t /int cws32_t&lt;esc&gt; n .切换至可视模式 v切换至可视模式，按行选择 V切换至可视模式，按列选择 Ctrl + V可视模式下，进行批量插入，编辑完后&lt;ESC&gt;&lt;CR&gt;可完成批量修改 I可视模式下，移动光标至对角上 o可视模式下，移动光标至同一行的另一个角上 O切换至插入模式，在光标前插入字符 i切换至插入模式，在当前行的第一个非空字符处插入 I切换至插入模式，在当前行的末尾插入字符 A切换至插入模式，在光标下方建立一个新的空行 o切换至插入模式，在光标上方建立一个新行 O切换至替换模式 R在插入模式和替换模式间切换 &lt;Insert&gt;在替换模式下，取消上一个替换的字符 &lt;BS&gt;可视模式下，添加 () 1可视模式下，添加 [] 2可视模式下，添加 &#123;&#125; 3可视模式下，添加 &quot;&quot; $$可视模式下，添加 &apos;&apos; $q粘贴至光标前，如果拷贝内容为一行则表示粘贴至前一行 P粘贴至光标后，如果拷贝内容为一行则表示粘贴至后一行 p交换当前光标及下一个字符 xp交换当前光标及下一个字符 Xp拷贝一整行 Y/yy拷贝单词及其后面的空白符 yw拷贝单词不包含后面的空白符 ye拷贝光标所在单词 yaw拷贝光标所在单词，不包含单词后的空格 yiw拷贝光标所在的 () 内的部分 ya(拷贝光标所在的 () 内的部分，不包含括号 yi(拷贝光标所在的 [] 内的部分 ya[拷贝光标所在的 [] 内的部分，不包含括号 yi[拷贝光标所在的 &#123;&#125; 内的部分 ya&#123;拷贝光标所在的 &#123;&#125; 内的部分，不包含括号 yi&#123;cscope find all references to the token under cursor CTRL-\ scscope global: find global definition(s) of the token under cursor CTRL-\ gcscope calls: find all calls to the function name under cursor CTRL-\ ccscope text: find all instances of the text under cursor CTRL-\ tcscope calls: find all calls to the function name under cursor CTRL-\ ecscope egrep: egrep search for the word under cursor CTRL-\ fcscope includes: find files that include the filename under cursor CTRL-\ icscope called: find functions that function under cursor calls CTRL-\ dcscope 在新建水平窗口打开 CTRL-\ hscscope 在新建垂直窗口打开 CTRL-\ vscscope 设置 cscope 从右边打开新建垂直窗口 :set splitrightcscope 设置结果显示至 quickfix 窗口 h cscopequickfixctrlp 设置 ctrlp 垂直分割打开窗口，防止和粘贴重复 let g:ctrlp_prompt_mappings = &#123; &apos;AcceptSelection(&quot;v&quot;)&apos;: [&apos;&lt;c-g&gt;&apos;] &#125;ctrlp 查看基本操作帮助 :h ctrlp-mappings打开命令行窗口 q:保存上一次会话 https://github.com/tmuxinator/tmuxinatorman 快速打开 man 帮助 :source $VIMRUNTIME/ftplugin/man.vim:nmap K :Man &lt;c-r&gt;&lt;c-w&gt;&lt;cr&gt;:echo $VIMRUNTIME 修改 man.vim 中的 new 为 vnewTumx从 window 连接 Ubuntu, 实在不喜欢太多窗口，只能用 Tmux 了参考http://www.cnblogs.com/congbo/archive/2012/08/30/2649420.htmlJupyter帮助：hWindows激活任务栏第 N 个任务：Win + 数字 极其常用Mac常用删除：command + del打开强制退出窗口：Command + Option + esc切换：Command + Tab截图截取全屏至文件：Command + Shift + 3截取全屏到剪贴板：Command + Shift + Control + 3截取所选屏幕区域到文件，或按空格键截取窗口：Command + Shift + 4截取所选屏幕区域到剪贴板，或按空格键截取窗口：Command + Shift + Control + 4Finder新建文件夹：Command + Shift + N调出直达窗口：Command + Shift + G重命名文件：Enter进入文件：Command + O剪切：Command + Option + V进入上级目录：Command + 上箭头删除：Command + Delete清倒废纸篓：Command + Shift + Delete预览：空格chrome光标直接跳至地址栏：Command + l转向下一个标签页：Control + Tab转向上一个标签页：Control + Shift + Tab放大页面：Command + 加号或等号缩小页面：Command + 减号zsh说实在的行编辑功能不如 shell, 比如删除单词、向前向后按单词移动移动移动到行首：ctrl + a移动到行尾：ctrl + e移动到前一个字符：ctrl + f移动到前一个字符：ctrl + b编辑剪切当前光标的字符：ctrl + d剪切光标之前的字符：ctrl + h剪切光标之前的单词：ctrl + w剪切整行：ctrl + u （本来 ctrl + u 是删至命令行首，但 iterm 中是删掉整行）剪切至行末尾：ctrl + k粘贴至光标后：ctrl + y交换光标处文本：ctrl + t历史上一条命令历史：ctrl + p下一条命令历史：ctrl + n搜索命令历史：ctrl + r其他清屏：ctrl + l]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用操作汇总]]></title>
    <url>%2F2017%2F10%2F15%2Fuseful_operate.html</url>
    <content type="text"><![CDATA[汇总一些琐碎的，非快捷键的操作，当某个工具的操作过多时再独立为一篇博客mac窗口切换原生的 MAC 窗口切换简直无法直视，最简单的一点，多个 Chrome 窗口都无法切换，于是找到两款不错的工具snap: 实现 Command + num 打开 DockHyperSwitch: 实现 Command + ` 切换同一个进程的多个窗口jupyter.ipynb 转 .md1jupyter nbconvert --to markdown README.ipynbjupyter 取消密码生成配置文件1jupyter notebook --generate --allow-root编辑 /root/.jupyter/jupyter_notebook_config.py，然后重启 jupyter1c.NotebookApp.token = '';主题设置jt -t grade3 -fs 11 -nfs 12 -tfs 12 -tf sourcesans -nf sourcesans -cellw 88% -altp -f source显示多行结果修改前12345line1 = "this is from line 1"line2 = "this is from line 2"line1line2‘this is from line 2’修改永久生效，编辑.ipython/profile_default/ipython_config.py，然后重启 jupyter12ipython profile create # 如果没有默认配置文件， 则生成一个新的c.InteractiveShell.ast_node_interactivity = 'all'修改临时生效12from IPython.core.interactiveshell import InteractiveShellInteractiveShell.ast_node_interactivity = "all"修改后12345line1 = "this is from line 1"line2 = "this is from line 2"line1line2‘this is from line 1’‘this is from line 2’git保存提交密码更好的方式是使用秘钥1git config --global credential.helper store生成秘钥git 官方帮助 描述的非常清楚，如果是 Linux 系统，首先通过命令生成秘钥，注意下面命令中的 jiexiao111@gmail.com 是你注册 github 时的邮箱1ssh-keygen -t rsa -C jiexiao111@gmail.com想办法把下面这个文件的内容拷贝出来1~/.ssh/id_rsa.pub然后打开你的 github 主页，依次点击 Settings-&gt;SSH and GPG keys-&gt;New SSH key, 然后 Title 随便取个名字，再把 ~/.ssh/id_rsa.pub 中的内容拷贝到 Key 中，Add SSH key 完成添加解决 git 中文乱码1git config --global core.quotepath false撤销 commit 但是保留修改1git reset --soft [commit_id] 就可以回滚到某一个 commit，然后保留下修改的内容比较文件https://gist.github.com/jhjguxin/3271961chrome分析网页加载速度在 chrome 流量器中按 F12 或者单击鼠标右键 -&gt;检查，打开调试栏 -&gt;Network, 刷新网页就可以看到以下信息了vim无法 undo如果文件名中包含中文，则无法 undo保存折叠.vimrc 添加以下12au BufWinLeave *.* mkviewau BufWinEnter *.* silent loadview文本替换替换当前行中的内容替换第一个匹配项：:s/from/to/替换所有匹配项：:s/from/to/g替换所有匹配项，替换前需确认：:s/from/to/gc注意：这里的 from 和 to 都可以是任何字符串，其中 from 还可以是正则表达式替换某一行的内容当前行：:.s/from/to/g第 33 行：33s/from/to/g最后一行：:$s/from/to/g替换某些行的内容[10 行，20 行』: :10,20s/from/to/g[1 行，最后一行』: :1,$s/from/to/g[1 行，当前行』: :1,.s/from/to/g『当前行，最后一行』: :.,$s/from/to/g『标记 a 所在行，标记 b 所在行』: :&#39;a,&#39;bs/from/to/g所有行：:%s/from/to/g替换命令的完整形式完整语法：:[range]s/from/to/[flags]s/from/to/ 表示 from 替换成 to, from 可以是正则表达式：[range] 可以为：光标所在的行：不写 range光标所在的行：.所有行：%第一行：1最后一行：$第 33 行：33标记 a 所在的行：&#39;a光标所在行的下一行：.+1光标所在行的上一行：$-1第 22 ~ 33 行：22,33第 1 行 ~ 最后一行：1,$第 1 行 到 当前行：1,.当前行 到 最后一行：.,$标记 a 所在的行 到 标记 b 所在的行：&#39;a,&#39;b从当前位置向上搜索，找到的第一个 chapter 所在的行：?chapter?从当前位置向下搜索，找到的第一个 chapter 所在的行：/chapter/注意，上面的所有用于 range 的表示方法都可以通过 +、- 操作来设置相对偏移量[flags] 可以为：替换第一个：无替换所有：g要求确认：c忽略错误：e注意：上面的所有 flags 都可以组合起来使用，比如 gc 表示对指定范围内的所有匹配项进行替换，并且在每一次替换之前都会请用户确认插入命令输出1:r !command内容排序选中需要排序的文本，执行 :sort1234:sort! 对全文逆序排列:sort u 对全文排序并去除重复行:sort! u 对全文逆序排列并去除重复行:sort i 对全文排序同时忽略大小写Linuxxsel 剪切板将 ls 命令输出的结果放入剪切板1ls |xsel]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fast_AI]]></title>
    <url>%2F2017%2F10%2F14%2FFast-AI.html</url>
    <content type="text"><![CDATA[FastAI 学习笔记Lesson 1]]></content>
  </entry>
  <entry>
    <title><![CDATA[TODO]]></title>
    <url>%2F2017%2F10%2F14%2FTODO.html</url>
    <content type="text"><![CDATA[一些来不及整理的内容先保存在这里多版本切换 anaconda[http://www.jianshu.com/p/d2e15200ee9b]1234# 显示可用的 python 环境conda info --envs# 激活 python 环境source activate py2学习 git以下文件包含 git 常用命令的缩写1~/.oh-my-zsh/plugins/git解决 zsh 和 tmux 下，vim 配色显示不一致编辑~/.zshrc:alias tmux=&quot;TERM=screen-256color-bce tmux&quot;编辑 ~/.tmux.conf:set -g default-terminal &quot;xterm&quot;参考 [https://stackoverflow.com/questions/10158508/lose-vim-colorscheme-in-tmux-mode]修改 CapsLock 为 CtrlWin7点击 Win+R 键在输入框键入 regedit，打开注册表进入 HKEY_LOCAL_MACHINE -&gt; System -&gt; CurrentControlSet -&gt; Control -&gt; KeyBoard Layout。记住，一定是 keyBoard Layout，而不是 KeyBoard Layouts右键菜单，然后选择 New -&gt; Binary value重命名 New Value #1 -&gt; Scancode Map右键菜单 Scancode Map -&gt; Modify输入如下值，保存0000 00 00 00 00 00 00 00 000008 03 00 00 00 1D 00 3A 000010 3A 00 1D 00 00 00 00 000018MAC选取苹果菜单 &gt;“系统偏好设置”，然后点按“键盘”。点按“修饰键”按钮。从想要更改的修饰键旁边的弹出式菜单中选取一项操作，然后点按“好”。python3 import docx 错误pip uninstall docx下载 python_docx-0.8.6-py2.py3-none-any.whlpip install python_docx-0.8.6-py2.py3-none-any.whl]]></content>
  </entry>
  <entry>
    <title><![CDATA[Learn_Seq2Seq_Model]]></title>
    <url>%2F2017%2F10%2F14%2FLearn-Seq2Seq-Model.html</url>
    <content type="text"><![CDATA[近期主要任务为使用 Seq2Seq 模型，记录一些资料参考资料论文：seq2seq 第一篇文章1409.3215.pdf加入 context vector，可以处理变长数据1406.1078.pdf加入 attention 机制1508.04025.pdf官网介绍：[https://www.tensorflow.org/tutorials/seq2seq]其他：[http://blog.csdn.net/Jerr__y/article/details/53749693][http://blog.csdn.net/u012436149/article/details/52976413][http://blog.csdn.net/u014595019/article/details/52826423][http://www.jianshu.com/p/1d3de928f40c][https://zhuanlan.zhihu.com/p/27769667]]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法示例]]></title>
    <url>%2F2017%2F09%2F10%2Fhello-world.html</url>
    <content type="text"><![CDATA[本篇博文不仅仅包含 Markdown 基础语法, 也有 Hexo 定义的一些标签, 主要是自己 copy 起来方便, 所有的章节一定是语法+示例, 不用怀疑标题markdown 标题语法, # 号个数代表标题级别12345## 二级标题示例### 三级标题示例#### 四级标题示例##### 五级标题示例###### 六级标题示例二级标题示例三级标题示例四级标题示例五级标题示例六级标题示例列表无序列表懒得记, 无序列表我只用 * 开头12345* 一级无序列表 * 二级无序列表 * 三级无序列表 * 四级无序列表* 一级无序列表一级无序列表二级无序列表三级无序列表四级无序列表一级无序列表有序列表有序列表以 1. 2. 3. 开头, 注意第四行, 真实显示的需要是自动生成的123451. 一级有序列表 1. 二级有序列表 2. 三级有序列表 4. 注意序号是自动生成的2. 有序列表一级有序列表二级有序列表二级有序列表注意序号是自动生成的有序列表待办列表语法应该就是 - [x] 开头的行1234- [x] @mentions, #refs, [links](), **formatting**, and &lt;del&gt;tags&lt;/del&gt; are supported - [x] list syntax is required (any unordered or ordered list supported) - [x] this is a complete item - [ ] this is an incomplete item@mentions, #refs, links, formatting, and tags are supportedlist syntax is required (any unordered or ordered list supported)this is a complete itemthis is an incomplete item引用标准引用引用以一个或多个 &gt; 开头, 注意第四行的空行, 如果没有空行第五行也会是三级引用12345&gt; 这是一级引用&gt;&gt; 这是二级引用&gt;&gt;&gt; 这是三级引用&gt; 这是一级引用这是一级引用这是二级引用这是三级引用这是一级引用centerquote 标签非常适合单行的引用, 比较好看1&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125;blah blah blahblockquote 标签123&#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&#125;Every interaction is both precious and an opportunity to delight.&#123;% endblockquote %&#125;Every interaction is both precious and an opportunity to delight.Seth GodinWelcome to Island Marketingnote 标签1&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125;其中，class_name 可以是以下列表中的一个值：defaultprimarysuccessinfowarningdanger123&#123;% note warning %&#125;举个例子&#123;% endnote %&#125;举个例子代码块用 ``` 包围起来的就是代码块, 这个没法演示, 这里展示使用标签的方式, 下面是代码标签的语法123&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125;举两个例子:最简单的例子123&#123;% codeblock %&#125;print(&apos;Hello World!&apos;);&#123;% endcodeblock %&#125;效果如下:1print(&apos;Hello World!&apos;);附加说明和网址, 其中 [title] 是 _.compact, [lang:language] 是 lang:objc, [url] 是 http://underscorejs.org/#compact [link text] 是 Underscore.js123&#123;% codeblock lang:objc _.compact http://underscorejs.org/#compact Underscore.js %&#125;[rectangle setX: 10 y: 10 width: 20 height: 20];&#123;% endcodeblock %&#125;效果如下:_.compactUnderscore.js1[rectangle setX: 10 y: 10 width: 20 height: 20];链接行内式链接行内式链接的语法结构为 [链接的描述](link &quot;鼠标放到链接上后的提示&quot;)1这就是行内链接：[李阿昀的简书](http://www.jianshu.com &quot;李阿昀的简书&quot;)这就是行内链接：李阿昀的简书参考式链接12341. [李阿昀的简书][1]2. [Hexo 中文文档][2][1]: &lt;http://www.jianshu.com/p/250e36bb5690#fn_lemma_footer&gt;[2]: &lt;https://hexo.io/zh-cn/docs/tag-plugins.html&gt;李阿昀的简书Hexo 中文文档自动链接用 &lt;&gt; 包围的就是自动链接, 没有 http 就不会显示12&lt;http://example.com/&gt;&lt;example.com/&gt;http://example.com/博客内部链接1&#123;% post_link &quot;Hash_implement&quot; %&#125;Hash 实现1&#123;% post_link &quot;hello-world&quot; &quot;Deploy to remote sites&quot; %&#125;Deploy to remote sites锚点点击位置1[点击跳转](#jump)目标位置1&lt;span id=&quot;jump&quot;&gt;跳转到的地方&lt;/span&gt;可以看到 jump 关联了点击位置和目标位置点击跳转图片插入图片与插入链接的语法很像，区别在一个!号，而且也有行内式和参考式两种。行内式图片行内式优势在于简单, 图片语法为：![无法显示图片时的说明](图片地址或者链接 &quot;鼠标悬停提示&quot;)显示链接图片1![图灵社区](http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg)显示失效链接图片1![图灵社区](http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg1)显示本地图片1![github](/images/github-page.png)参考式图片参考式优势在于可以多次引用网址, 类似声明 Constant 变量, 参考式图片我没有找到使用本地图片的办法12![链接图片][3][3]: http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg标签显示图片标签显示图片的语法1&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125;基础应用1&#123;% img &apos;/images/github-page.png&apos; %&#125;标签放大显示图片优势是可以强调图片显示1&#123;% fi &apos;/images/github-page.png&apos;, alt, title %&#125;字体/行内代码/删除线使用**表示粗体, 使用*表示斜体。符号和文字间不能有空格使用 `` 包围表示行内代码使用 ~~ 包围表示删除线123456**粗体***斜体*~~删除线~~*~~斜体删除线~~*``行内代码``普通字体粗体斜体删除线斜体删除线行内代码普通字体表格用|表示表格纵向边界，表头和表内容用-隔开，并可用:进行对齐设置，两边都有:则表示居中，若不加:则默认左对齐。详细说明：----:为右对齐:----为左对齐:---:为居中对齐-----为默认左对齐正常的表格12345dog | bird | cat----|------|----foo | foo | foobar | bar | barbaz | baz | bazdogbirdcatfoofoofoobarbarbarbazbazbaz复杂的表格12345| 序号 | 交易名 | 交易说明 | 备注 || ---: | :----: | :------- | ---- || 1 | prfcfg | 菜单配置 | 可以通过此交易查询到所有交易码和菜单的对应关系 || 2 | gentmo | 编译所有交易 | || 100000 | sysdba | 数据库表模型汇总 | |序号交易名交易说明备注1prfcfg菜单配置可以通过此交易查询到所有交易码和菜单的对应关系2gentmo编译所有交易100000sysdba数据库表模型汇总分割线使用---表示分割线, 其他形式不管1---LaTeX 公式行内公式$ 表示行内公式1质能方程 $E=mc^2$质能方程 $E=mc^2$整行公式$$ 表示整行公式1$$\sum_&#123;i=1&#125;^n a_i=0$$$$\sum_{i=1}^n a_i=0$$访问 MathJax 参考更多使用方法。暂不使用的高级特性内嵌图标, 更多的图标和玩法可以参看 font-awesome 官方网站。定义型列表注脚流程图, 更多语法参考：流程图语法参考序列图, 更多语法参考：序列图语法参考参考跳转到的地方李阿昀的简书Hexo 中文文档Github Page 官方帮助作业部落]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hash 实现]]></title>
    <url>%2F2017%2F09%2F10%2FHash_implement.html</url>
    <content type="text"><![CDATA[C语言标准库中未实现hashtable, 在编程练习时经常使用该数据结构，以备不时之需实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;typedef unsigned char u8_t;typedef char s8_t;typedef unsigned short u16_t;typedef signed short s16_t;typedef unsigned int u32_t;typedef signed int s32_t;typedef long long s64_t;typedef unsigned long long u64_t;typedef s32_t err_t;typedef unsigned long ulong_t;void* xxx_malloc(int size)&#123; void* ret = malloc(size); printf("malloc %p\n", ret); return ret;&#125;void xxx_free(void* ptr)&#123; printf("free %p\n", ptr); free(ptr);&#125;#define offset_of(type, member) ((unsigned long)&amp;((type *)0)-&gt;member)#define container_of(ptr, type, member) \ ((type *)((unsigned char *)ptr - offset_of(type,member)))#define hlist_entry(ptr, type, member) container_of(ptr,type,member)#define hlist_for_each(pos, head) for (pos = (head)-&gt;first; pos; pos = pos-&gt;next)#define hlist_for_each_safe(pos, n, head) \ for (pos = (head)-&gt;first; pos &amp;&amp; (n = pos-&gt;next, 1); pos = n)#define hlist_for_each_entry(type_pos, ptr, pos, head, member) \ for (pos = (head)-&gt;first; pos &amp;&amp; (ptr = hlist_entry(pos, type_pos, member), 1); pos = pos-&gt;next)#define hlist_for_each_entry_safe(type_pos, tpos, pos, n, head, member) \ for (pos = (head)-&gt;first; \ pos &amp;&amp; (&#123; n = pos-&gt;next; 1; &#125;) &amp;&amp; \ (&#123; tpos = hlist_entry(pos, type_pos, member); 1;&#125;); \ pos = n)#define INIT_HLIST_HEAD(ptr) ((ptr)-&gt;first = NULL)struct hlist_head &#123; struct hlist_node *first;&#125;;struct hlist_node &#123; struct hlist_node *next, **pprev;&#125;;static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)&#123; struct hlist_node *first = h-&gt;first; n-&gt;next = first; if (first) first-&gt;pprev = &amp;n-&gt;next; h-&gt;first = n; n-&gt;pprev = &amp;h-&gt;first;&#125;static inline void INIT_HLIST_NODE(struct hlist_node *h)&#123; h-&gt;next = NULL; h-&gt;pprev = NULL;&#125;static inline int hlist_unhashed(const struct hlist_node *h)&#123; return !h-&gt;pprev;&#125;static inline int hlist_empty(const struct hlist_head *h)&#123; return !h-&gt;first;&#125;static inline void __hlist_del(struct hlist_node *n)&#123; struct hlist_node *next = n-&gt;next; struct hlist_node **pprev = n-&gt;pprev; *pprev = next; if (next) next-&gt;pprev = pprev;&#125;static inline void hlist_del_init(struct hlist_node *n)&#123; if (!hlist_unhashed(n)) &#123; __hlist_del(n); &#125;&#125;typedef struct _xxx_hash_bucket_head &#123; struct hlist_head chain; // hash 桶的头结点&#125; xxx_hash_bucket_head;typedef struct _xxx_hashtable &#123; xxx_hash_bucket_head *tbl; // hash 表中的 hash 桶 s8_t *name; // hash 表的名称, 未使用 u32_t cnt; // 保存关键字 hash 后的最大值 u32_t element_cnt; // 记录当前 hash 表中的元素数量 u32_t offset; // hlist_node 成员与包含该成员结构体的地址偏移 u32_t (*hash)(void *); // 关键字的 hash 算法函数 s32_t (*compare)(void *, void *); // 元素的比较函数 void (*destroy)(void *); // 反初始化时对每个元素的反初始化操作函数&#125; xxx_hashtable_t;void *hashtable_init(s8_t *name, u32_t cnt, u32_t offset, u32_t (*hash)(void *), s32_t (*compare)(void *, void *), void (*destroy)(void *))&#123; xxx_hashtable_t *tbl; u32_t i; u32_t size; assert(!(cnt &amp; (cnt - 1))); assert(NULL != hash); assert(NULL != compare); if (NULL == (tbl = (xxx_hashtable_t*)xxx_malloc(sizeof(xxx_hashtable_t)))) &#123; return NULL; &#125; size = sizeof(xxx_hash_bucket_head) * cnt; if (NULL == (tbl-&gt;tbl = xxx_malloc(size))) &#123; xxx_free(tbl); return NULL; &#125; tbl-&gt;name = name; tbl-&gt;cnt = cnt; tbl-&gt;element_cnt = 0; tbl-&gt;offset = offset; tbl-&gt;hash = hash; tbl-&gt;compare = compare; tbl-&gt;destroy = destroy; for (i = 0; i &lt; cnt; i++) &#123; INIT_HLIST_HEAD(&amp;(tbl-&gt;tbl[i].chain)); &#125; return tbl;&#125;void hashtable_fini(void *tbl)&#123; u32_t i; struct hlist_node *pos, *n; xxx_hash_bucket_head *h; u32_t size; u32_t offset; if (NULL == tbl) &#123; return; &#125; offset = ((xxx_hashtable_t *)tbl)-&gt;offset; for (i = 0; i &lt; ((xxx_hashtable_t *)tbl)-&gt;cnt; i++) &#123; h = &amp;((xxx_hashtable_t *)tbl)-&gt;tbl[i]; hlist_for_each_safe(pos, n, &amp;h-&gt;chain) &#123; if (NULL != ((xxx_hashtable_t *)tbl)-&gt;destroy) &#123; ((xxx_hashtable_t *)tbl)-&gt;destroy((void *)((u8_t *)pos - offset)); &#125; &#125; &#125; size = sizeof(struct hlist_head) * ((xxx_hashtable_t *)tbl)-&gt;cnt; xxx_free(((xxx_hashtable_t *)tbl)-&gt;tbl); xxx_free(tbl);&#125;static inline void *hashtable_find(void *tbl, void *elem)&#123; struct hlist_node *pos; xxx_hash_bucket_head *h; u32_t hash; hash = ((xxx_hashtable_t *)tbl)-&gt;hash(elem); assert(hash &lt; ((xxx_hashtable_t *)tbl)-&gt;cnt); h = &amp;((xxx_hashtable_t *)tbl)-&gt;tbl[hash]; hlist_for_each(pos, &amp;h-&gt;chain) &#123; if (!((xxx_hashtable_t *)tbl)-&gt;compare(elem, (u8_t *)pos - ((xxx_hashtable_t *)tbl)-&gt;offset)) &#123; return (void *)((u8_t *)pos - ((xxx_hashtable_t *)tbl)-&gt;offset); &#125; &#125; return NULL;&#125;static err_t hashtable_insert(void* hashtable, void* elem)&#123; struct hlist_node* pos; xxx_hash_bucket_head* bucket; u32_t hash; hash = ((xxx_hashtable_t *)hashtable)-&gt;hash(elem); assert(hash &lt; ((xxx_hashtable_t *)hashtable)-&gt;cnt); bucket = &amp;((xxx_hashtable_t *)hashtable)-&gt;tbl[hash]; hlist_for_each(pos, &amp;bucket-&gt;chain) &#123; if (!((xxx_hashtable_t *)hashtable)-&gt;compare(elem, (u8_t *)pos - ((xxx_hashtable_t *)hashtable)-&gt;offset)) &#123; return -1; &#125; &#125; hlist_add_head((struct hlist_node *)((u8_t *)elem + ((xxx_hashtable_t *)hashtable)-&gt;offset), &amp;bucket-&gt;chain); ((xxx_hashtable_t *)hashtable)-&gt;element_cnt++; return 0;&#125;static inline void hashtable_delete(void *hashtable, void *elem)&#123; xxx_hash_bucket_head *bucket; u32_t hash; hash = ((xxx_hashtable_t *)hashtable)-&gt;hash(elem); assert(hash &lt; ((xxx_hashtable_t *)hashtable)-&gt;cnt); bucket = &amp;((xxx_hashtable_t *)hashtable)-&gt;tbl[hash]; hlist_del_init((struct hlist_node *)((u8_t *)elem + ((xxx_hashtable_t *)hashtable)-&gt;offset)); if (NULL != ((xxx_hashtable_t *)hashtable)-&gt;destroy) &#123; ((xxx_hashtable_t *)hashtable)-&gt;destroy(elem); &#125; ((xxx_hashtable_t *)hashtable)-&gt;element_cnt--;&#125;/* Hash map 实现 */#define MAP_BUCKET_CNT (1 &lt;&lt; 6)typedef struct _str_map_t&#123; int m_value; struct hlist_node hash_node;&#125; str_map_t;/* 创建 str_map_t 对象 */str_map_t* str_map_init();/* 销毁 str_map_t 对象 */void str_map_fini(str_map_t* p_str_map);/* 插入元素 */void str_map_insert(str_map_t* p_str_map);/* 删除元素 */void str_map_erase(str_map_t* p_str_map);/* 查找元素 */void str_map_erase(str_map_t* p_str_map);/* 测试函数 */typedef struct _hlist_demo_t&#123; int m_value; struct hlist_node hash_node;&#125; hlist_demo_t;static u32_t demo_hash(void *pkt)&#123; return (u32_t)(((hlist_demo_t*)pkt)-&gt;m_value) % BUCKET_CNT;&#125;static s32_t demo_compare(void *pkt, void *pkt2)&#123; if (((hlist_demo_t*)pkt)-&gt;m_value == ((hlist_demo_t*)pkt2)-&gt;m_value) &#123; return 0; &#125; return -1;&#125;static void demo_destroy(void *arg)&#123; xxx_free(arg);&#125;int main()&#123;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>hash</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
</search>
